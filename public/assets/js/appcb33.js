!(function (t) {
  var e = {};
  function n(i) {
    if (e[i]) return e[i].exports;
    var r = (e[i] = { i: i, l: !1, exports: {} });
    return t[i].call(r.exports, r, r.exports, n), (r.l = !0), r.exports;
  }
  (n.m = t),
    (n.c = e),
    (n.d = function (t, e, i) {
      n.o(t, e) || Object.defineProperty(t, e, { enumerable: !0, get: i });
    }),
    (n.r = function (t) {
      "undefined" != typeof Symbol &&
        Symbol.toStringTag &&
        Object.defineProperty(t, Symbol.toStringTag, { value: "Module" }),
        Object.defineProperty(t, "__esModule", { value: !0 });
    }),
    (n.t = function (t, e) {
      if ((1 & e && (t = n(t)), 8 & e)) return t;
      if (4 & e && "object" == typeof t && t && t.__esModule) return t;
      var i = Object.create(null);
      if (
        (n.r(i),
        Object.defineProperty(i, "default", { enumerable: !0, value: t }),
        2 & e && "string" != typeof t)
      )
        for (var r in t)
          n.d(
            i,
            r,
            function (e) {
              return t[e];
            }.bind(null, r)
          );
      return i;
    }),
    (n.n = function (t) {
      var e =
        t && t.__esModule
          ? function () {
              return t.default;
            }
          : function () {
              return t;
            };
      return n.d(e, "a", e), e;
    }),
    (n.o = function (t, e) {
      return Object.prototype.hasOwnProperty.call(t, e);
    }),
    (n.p = "/"),
    n((n.s = 0));
})({
  0: function (t, e, n) {
    n("ng4s"), n("NlKh"), (t.exports = n("mPeE"));
  },
  "2SVd": function (t, e, n) {
    "use strict";
    t.exports = function (t) {
      return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(t);
    };
  },
  "5oMp": function (t, e, n) {
    "use strict";
    t.exports = function (t, e) {
      return e ? t.replace(/\/+$/, "") + "/" + e.replace(/^\/+/, "") : t;
    };
  },
  "8oxB": function (t, e) {
    var n,
      i,
      r = (t.exports = {});
    function s() {
      throw new Error("setTimeout has not been defined");
    }
    function o() {
      throw new Error("clearTimeout has not been defined");
    }
    function a(t) {
      if (n === setTimeout) return setTimeout(t, 0);
      if ((n === s || !n) && setTimeout)
        return (n = setTimeout), setTimeout(t, 0);
      try {
        return n(t, 0);
      } catch (e) {
        try {
          return n.call(null, t, 0);
        } catch (e) {
          return n.call(this, t, 0);
        }
      }
    }
    !(function () {
      try {
        n = "function" == typeof setTimeout ? setTimeout : s;
      } catch (t) {
        n = s;
      }
      try {
        i = "function" == typeof clearTimeout ? clearTimeout : o;
      } catch (t) {
        i = o;
      }
    })();
    var l,
      c = [],
      u = !1,
      h = -1;
    function d() {
      u &&
        l &&
        ((u = !1), l.length ? (c = l.concat(c)) : (h = -1), c.length && p());
    }
    function p() {
      if (!u) {
        var t = a(d);
        u = !0;
        for (var e = c.length; e; ) {
          for (l = c, c = []; ++h < e; ) l && l[h].run();
          (h = -1), (e = c.length);
        }
        (l = null),
          (u = !1),
          (function (t) {
            if (i === clearTimeout) return clearTimeout(t);
            if ((i === o || !i) && clearTimeout)
              return (i = clearTimeout), clearTimeout(t);
            try {
              i(t);
            } catch (e) {
              try {
                return i.call(null, t);
              } catch (e) {
                return i.call(this, t);
              }
            }
          })(t);
      }
    }
    function f(t, e) {
      (this.fun = t), (this.array = e);
    }
    function m() {}
    (r.nextTick = function (t) {
      var e = new Array(arguments.length - 1);
      if (arguments.length > 1)
        for (var n = 1; n < arguments.length; n++) e[n - 1] = arguments[n];
      c.push(new f(t, e)), 1 !== c.length || u || a(p);
    }),
      (f.prototype.run = function () {
        this.fun.apply(null, this.array);
      }),
      (r.title = "browser"),
      (r.browser = !0),
      (r.env = {}),
      (r.argv = []),
      (r.version = ""),
      (r.versions = {}),
      (r.on = m),
      (r.addListener = m),
      (r.once = m),
      (r.off = m),
      (r.removeListener = m),
      (r.removeAllListeners = m),
      (r.emit = m),
      (r.prependListener = m),
      (r.prependOnceListener = m),
      (r.listeners = function (t) {
        return [];
      }),
      (r.binding = function (t) {
        throw new Error("process.binding is not supported");
      }),
      (r.cwd = function () {
        return "/";
      }),
      (r.chdir = function (t) {
        throw new Error("process.chdir is not supported");
      }),
      (r.umask = function () {
        return 0;
      });
  },
  "9rSQ": function (t, e, n) {
    "use strict";
    var i = n("xTJ+");
    function r() {
      this.handlers = [];
    }
    (r.prototype.use = function (t, e, n) {
      return (
        this.handlers.push({
          fulfilled: t,
          rejected: e,
          synchronous: !!n && n.synchronous,
          runWhen: n ? n.runWhen : null,
        }),
        this.handlers.length - 1
      );
    }),
      (r.prototype.eject = function (t) {
        this.handlers[t] && (this.handlers[t] = null);
      }),
      (r.prototype.forEach = function (t) {
        i.forEach(this.handlers, function (e) {
          null !== e && t(e);
        });
      }),
      (t.exports = r);
  },
  "9tPo": function (t, e) {
    t.exports = function (t) {
      var e = "undefined" != typeof window && window.location;
      if (!e) throw new Error("fixUrls requires window.location");
      if (!t || "string" != typeof t) return t;
      var n = e.protocol + "//" + e.host,
        i = n + e.pathname.replace(/\/[^\/]*$/, "/");
      return t.replace(
        /url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi,
        function (t, e) {
          var r,
            s = e
              .trim()
              .replace(/^"(.*)"$/, function (t, e) {
                return e;
              })
              .replace(/^'(.*)'$/, function (t, e) {
                return e;
              });
          return /^(#|data:|http:\/\/|https:\/\/|file:\/\/\/|\s*$)/i.test(s)
            ? t
            : ((r =
                0 === s.indexOf("//")
                  ? s
                  : 0 === s.indexOf("/")
                  ? n + s
                  : i + s.replace(/^\.\//, "")),
              "url(" + JSON.stringify(r) + ")");
        }
      );
    };
  },
  BFHv: function (t, e, n) {
    var i, r, s;
    !(function (o) {
      "use strict";
      (r = [n("EVdn")]),
        void 0 ===
          (s =
            "function" ==
            typeof (i = function (t) {
              var e = -1,
                n = -1,
                i = function (t) {
                  return parseFloat(t) || 0;
                },
                r = function (e) {
                  var n = t(e),
                    r = null,
                    s = [];
                  return (
                    n.each(function () {
                      var e = t(this),
                        n = e.offset().top - i(e.css("margin-top")),
                        o = s.length > 0 ? s[s.length - 1] : null;
                      null === o
                        ? s.push(e)
                        : Math.floor(Math.abs(r - n)) <= 1
                        ? (s[s.length - 1] = o.add(e))
                        : s.push(e),
                        (r = n);
                    }),
                    s
                  );
                },
                s = function (e) {
                  var n = {
                    byRow: !0,
                    property: "height",
                    target: null,
                    remove: !1,
                  };
                  return "object" == typeof e
                    ? t.extend(n, e)
                    : ("boolean" == typeof e
                        ? (n.byRow = e)
                        : "remove" === e && (n.remove = !0),
                      n);
                },
                o = (t.fn.matchHeight = function (e) {
                  var n = s(e);
                  if (n.remove) {
                    var i = this;
                    return (
                      this.css(n.property, ""),
                      t.each(o._groups, function (t, e) {
                        e.elements = e.elements.not(i);
                      }),
                      this
                    );
                  }
                  return this.length <= 1 && !n.target
                    ? this
                    : (o._groups.push({ elements: this, options: n }),
                      o._apply(this, n),
                      this);
                });
              (o.version = "0.7.2"),
                (o._groups = []),
                (o._throttle = 80),
                (o._maintainScroll = !1),
                (o._beforeUpdate = null),
                (o._afterUpdate = null),
                (o._rows = r),
                (o._parse = i),
                (o._parseOptions = s),
                (o._apply = function (e, n) { 
                  var a = s(n),
                    l = t(e),
                    c = [l],
                    u = t(window).scrollTop(),
                    h = t("html").outerHeight(!0),
                    d = l.parents().filter(":hidden");
                  return (
                    d.each(function () {
                      var e = t(this);
                      e.data("style-cache", e.attr("style"));
                    }),
                    d.css("display", "block"),
                    a.byRow &&
                      !a.target &&
                      (l.each(function () {
                        var e = t(this),
                          n = e.css("display");
                        "inline-block" !== n &&
                          "flex" !== n &&
                          "inline-flex" !== n &&
                          (n = "block"),
                          e.data("style-cache", e.attr("style")),
                          e.css({
                            display: n,
                            "padding-top": "0",
                            "padding-bottom": "0",
                            "margin-top": "0",
                            "margin-bottom": "0",
                            "border-top-width": "0",
                            "border-bottom-width": "0",
                            height: "100px",
                            overflow: "hidden",
                          });
                      }),
                      (c = r(l)),
                      l.each(function () {
                        var e = t(this);
                        e.attr("style", e.data("style-cache") || "");
                      })),
                    t.each(c, function (e, n) {
                      var r = t(n),
                        s = 0;
                      if (a.target) s = a.target.outerHeight(!1);
                      else {
                        if (a.byRow && r.length <= 1)
                          return void r.css(a.property, "");
                        r.each(function () {
                          var e = t(this),
                            n = e.attr("style"),
                            i = e.css("display");
                          "inline-block" !== i &&
                            "flex" !== i &&
                            "inline-flex" !== i &&
                            (i = "block");
                          var r = { display: i };
                          (r[a.property] = ""),
                            e.css(r),
                            e.outerHeight(!1) > s && (s = e.outerHeight(!1)),
                            n ? e.attr("style", n) : e.css("display", "");
                        });
                      }
                      r.each(function () {
                        var e = t(this),
                          n = 0;
                        (a.target && e.is(a.target)) ||
                          ("border-box" !== e.css("box-sizing") &&
                            ((n +=
                              i(e.css("border-top-width")) +
                              i(e.css("border-bottom-width"))),
                            (n +=
                              i(e.css("padding-top")) +
                              i(e.css("padding-bottom")))),
                          e.css(a.property, s - n + "px"));
                      });
                    }),
                    d.each(function () {
                      var e = t(this);
                      e.attr("style", e.data("style-cache") || null);
                    }),
                    o._maintainScroll &&
                      t(window).scrollTop((u / h) * t("html").outerHeight(!0)),
                    this
                  );
                }),
                (o._applyDataApi = function () {
                  var e = {};
                  t("[data-match-height], [data-mh]").each(function () {
                    var n = t(this),
                      i = n.attr("data-mh") || n.attr("data-match-height");
                    e[i] = i in e ? e[i].add(n) : n;
                  }),
                    t.each(e, function () {
                      this.matchHeight(!0);
                    });
                });
              var a = function (e) {
                o._beforeUpdate && o._beforeUpdate(e, o._groups),
                  t.each(o._groups, function () {
                    o._apply(this.elements, this.options);
                  }),
                  o._afterUpdate && o._afterUpdate(e, o._groups);
              };
              (o._update = function (i, r) {
                if (r && "resize" === r.type) {
                  var s = t(window).width();
                  if (s === e) return;
                  e = s;
                }
                i
                  ? -1 === n &&
                    (n = setTimeout(function () {
                      a(r), (n = -1);
                    }, o._throttle))
                  : a(r);
              }),
                t(o._applyDataApi);
              var l = t.fn.on ? "on" : "bind";
              t(window)[l]("load", function (t) {
                o._update(!1, t);
              }),
                t(window)[l]("resize orientationchange", function (t) {
                  o._update(!0, t);
                });
            })
              ? i.apply(e, r)
              : i) || (t.exports = s);
    })();
  },
  CgaS: function (t, e, n) {
    "use strict";
    var i = n("xTJ+"),
      r = n("MLWZ"),
      s = n("9rSQ"),
      o = n("UnBK"),
      a = n("SntB"),
      l = n("hIuj"),
      c = l.validators;
    function u(t) {
      (this.defaults = t),
        (this.interceptors = { request: new s(), response: new s() });
    }
    (u.prototype.request = function (t) {
      "string" == typeof t
        ? ((t = arguments[1] || {}).url = arguments[0])
        : (t = t || {}),
        (t = a(this.defaults, t)).method
          ? (t.method = t.method.toLowerCase())
          : this.defaults.method
          ? (t.method = this.defaults.method.toLowerCase())
          : (t.method = "get");
      var e = t.transitional;
      void 0 !== e &&
        l.assertOptions(
          e,
          {
            silentJSONParsing: c.transitional(c.boolean, "1.0.0"),
            forcedJSONParsing: c.transitional(c.boolean, "1.0.0"),
            clarifyTimeoutError: c.transitional(c.boolean, "1.0.0"),
          },
          !1
        );
      var n = [],
        i = !0;
      this.interceptors.request.forEach(function (e) {
        ("function" == typeof e.runWhen && !1 === e.runWhen(t)) ||
          ((i = i && e.synchronous), n.unshift(e.fulfilled, e.rejected));
      });
      var r,
        s = [];
      if (
        (this.interceptors.response.forEach(function (t) {
          s.push(t.fulfilled, t.rejected);
        }),
        !i)
      ) {
        var u = [o, void 0];
        for (
          Array.prototype.unshift.apply(u, n),
            u = u.concat(s),
            r = Promise.resolve(t);
          u.length;

        )
          r = r.then(u.shift(), u.shift());
        return r;
      }
      for (var h = t; n.length; ) {
        var d = n.shift(),
          p = n.shift();
        try {
          h = d(h);
        } catch (t) {
          p(t);
          break;
        }
      }
      try {
        r = o(h);
      } catch (t) {
        return Promise.reject(t);
      }
      for (; s.length; ) r = r.then(s.shift(), s.shift());
      return r;
    }),
      (u.prototype.getUri = function (t) {
        return (
          (t = a(this.defaults, t)),
          r(t.url, t.params, t.paramsSerializer).replace(/^\?/, "")
        );
      }),
      i.forEach(["delete", "get", "head", "options"], function (t) {
        u.prototype[t] = function (e, n) {
          return this.request(
            a(n || {}, { method: t, url: e, data: (n || {}).data })
          );
        };
      }),
      i.forEach(["post", "put", "patch"], function (t) {
        u.prototype[t] = function (e, n, i) {
          return this.request(a(i || {}, { method: t, url: e, data: n }));
        };
      }),
      (t.exports = u);
  },
  DfZB: function (t, e, n) {
    "use strict";
    t.exports = function (t) {
      return function (e) {
        return t.apply(null, e);
      };
    };
  },
  EVdn: function (t, e, n) {
    var i;
    !(function (e, n) {
      "use strict";
      "object" == typeof t.exports
        ? (t.exports = e.document
            ? n(e, !0)
            : function (t) {
                if (!t.document)
                  throw new Error("jQuery requires a window with a document");
                return n(t);
              })
        : n(e);
    })("undefined" != typeof window ? window : this, function (n, r) {
      "use strict";
      var s = [],
        o = Object.getPrototypeOf,
        a = s.slice,
        l = s.flat
          ? function (t) {
              return s.flat.call(t);
            }
          : function (t) {
              return s.concat.apply([], t);
            },
        c = s.push,
        u = s.indexOf,
        h = {},
        d = h.toString,
        p = h.hasOwnProperty,
        f = p.toString,
        m = f.call(Object),
        g = {},
        v = function (t) {
          return (
            "function" == typeof t &&
            "number" != typeof t.nodeType &&
            "function" != typeof t.item
          );
        },
        y = function (t) {
          return null != t && t === t.window;
        },
        x = n.document,
        b = { type: !0, src: !0, nonce: !0, noModule: !0 };
      function _(t, e, n) {
        var i,
          r,
          s = (n = n || x).createElement("script");
        if (((s.text = t), e))
          for (i in b)
            (r = e[i] || (e.getAttribute && e.getAttribute(i))) &&
              s.setAttribute(i, r);
        n.head.appendChild(s).parentNode.removeChild(s);
      }
      function w(t) {
        return null == t
          ? t + ""
          : "object" == typeof t || "function" == typeof t
          ? h[d.call(t)] || "object"
          : typeof t;
      }
      var S = function (t, e) {
        return new S.fn.init(t, e);
      };
      function M(t) {
        var e = !!t && "length" in t && t.length,
          n = w(t);
        return (
          !v(t) &&
          !y(t) &&
          ("array" === n ||
            0 === e ||
            ("number" == typeof e && e > 0 && e - 1 in t))
        );
      }
      (S.fn = S.prototype =
        {
          jquery: "3.6.0",
          constructor: S,
          length: 0,
          toArray: function () {
            return a.call(this);
          },
          get: function (t) {
            return null == t
              ? a.call(this)
              : t < 0
              ? this[t + this.length]
              : this[t];
          },
          pushStack: function (t) {
            var e = S.merge(this.constructor(), t);
            return (e.prevObject = this), e;
          },
          each: function (t) {
            return S.each(this, t);
          },
          map: function (t) {
            return this.pushStack(
              S.map(this, function (e, n) {
                return t.call(e, n, e);
              })
            );
          },
          slice: function () {
            return this.pushStack(a.apply(this, arguments));
          },
          first: function () {
            return this.eq(0);
          },
          last: function () {
            return this.eq(-1);
          },
          even: function () {
            return this.pushStack(
              S.grep(this, function (t, e) {
                return (e + 1) % 2;
              })
            );
          },
          odd: function () {
            return this.pushStack(
              S.grep(this, function (t, e) {
                return e % 2;
              })
            );
          },
          eq: function (t) {
            var e = this.length,
              n = +t + (t < 0 ? e : 0);
            return this.pushStack(n >= 0 && n < e ? [this[n]] : []);
          },
          end: function () {
            return this.prevObject || this.constructor();
          },
          push: c,
          sort: s.sort,
          splice: s.splice,
        }),
        (S.extend = S.fn.extend =
          function () {
            var t,
              e,
              n,
              i,
              r,
              s,
              o = arguments[0] || {},
              a = 1,
              l = arguments.length,
              c = !1;
            for (
              "boolean" == typeof o && ((c = o), (o = arguments[a] || {}), a++),
                "object" == typeof o || v(o) || (o = {}),
                a === l && ((o = this), a--);
              a < l;
              a++
            )
              if (null != (t = arguments[a]))
                for (e in t)
                  (i = t[e]),
                    "__proto__" !== e &&
                      o !== i &&
                      (c && i && (S.isPlainObject(i) || (r = Array.isArray(i)))
                        ? ((n = o[e]),
                          (s =
                            r && !Array.isArray(n)
                              ? []
                              : r || S.isPlainObject(n)
                              ? n
                              : {}),
                          (r = !1),
                          (o[e] = S.extend(c, s, i)))
                        : void 0 !== i && (o[e] = i));
            return o;
          }),
        S.extend({
          expando: "jQuery" + ("3.6.0" + Math.random()).replace(/\D/g, ""),
          isReady: !0,
          error: function (t) {
            throw new Error(t);
          },
          noop: function () {},
          isPlainObject: function (t) {
            var e, n;
            return (
              !(!t || "[object Object]" !== d.call(t)) &&
              (!(e = o(t)) ||
                ("function" ==
                  typeof (n = p.call(e, "constructor") && e.constructor) &&
                  f.call(n) === m))
            );
          },
          isEmptyObject: function (t) {
            var e;
            for (e in t) return !1;
            return !0;
          },
          globalEval: function (t, e, n) {
            _(t, { nonce: e && e.nonce }, n);
          },
          each: function (t, e) {
            var n,
              i = 0;
            if (M(t))
              for (n = t.length; i < n && !1 !== e.call(t[i], i, t[i]); i++);
            else for (i in t) if (!1 === e.call(t[i], i, t[i])) break;
            return t;
          },
          makeArray: function (t, e) {
            var n = e || [];
            return (
              null != t &&
                (M(Object(t))
                  ? S.merge(n, "string" == typeof t ? [t] : t)
                  : c.call(n, t)),
              n
            );
          },
          inArray: function (t, e, n) {
            return null == e ? -1 : u.call(e, t, n);
          },
          merge: function (t, e) {
            for (var n = +e.length, i = 0, r = t.length; i < n; i++)
              t[r++] = e[i];
            return (t.length = r), t;
          },
          grep: function (t, e, n) {
            for (var i = [], r = 0, s = t.length, o = !n; r < s; r++)
              !e(t[r], r) !== o && i.push(t[r]);
            return i;
          },
          map: function (t, e, n) {
            var i,
              r,
              s = 0,
              o = [];
            if (M(t))
              for (i = t.length; s < i; s++)
                null != (r = e(t[s], s, n)) && o.push(r);
            else for (s in t) null != (r = e(t[s], s, n)) && o.push(r);
            return l(o);
          },
          guid: 1,
          support: g,
        }),
        "function" == typeof Symbol &&
          (S.fn[Symbol.iterator] = s[Symbol.iterator]),
        S.each(
          "Boolean Number String Function Array Date RegExp Object Error Symbol".split(
            " "
          ),
          function (t, e) {
            h["[object " + e + "]"] = e.toLowerCase();
          }
        );
      var T = (function (t) {
        var e,
          n,
          i,
          r,
          s,
          o,
          a,
          l,
          c,
          u,
          h,
          d,
          p,
          f,
          m,
          g,
          v,
          y,
          x,
          b = "sizzle" + 1 * new Date(),
          _ = t.document,
          w = 0,
          S = 0,
          M = lt(),
          T = lt(),
          E = lt(),
          A = lt(),
          C = function (t, e) {
            return t === e && (h = !0), 0;
          },
          L = {}.hasOwnProperty,
          R = [],
          P = R.pop,
          D = R.push,
          k = R.push,
          I = R.slice,
          N = function (t, e) {
            for (var n = 0, i = t.length; n < i; n++) if (t[n] === e) return n;
            return -1;
          },
          O =
            "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
          z = "[\\x20\\t\\r\\n\\f]",
          H =
            "(?:\\\\[\\da-fA-F]{1,6}" +
            z +
            "?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+",
          B =
            "\\[" +
            z +
            "*(" +
            H +
            ")(?:" +
            z +
            "*([*^$|!~]?=)" +
            z +
            "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" +
            H +
            "))|)" +
            z +
            "*\\]",
          U =
            ":(" +
            H +
            ")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|" +
            B +
            ")*)|.*)\\)|)",
          F = new RegExp(z + "+", "g"),
          V = new RegExp(
            "^" + z + "+|((?:^|[^\\\\])(?:\\\\.)*)" + z + "+$",
            "g"
          ),
          W = new RegExp("^" + z + "*," + z + "*"),
          G = new RegExp("^" + z + "*([>+~]|" + z + ")" + z + "*"),
          j = new RegExp(z + "|>"),
          q = new RegExp(U),
          $ = new RegExp("^" + H + "$"),
          X = {
            ID: new RegExp("^#(" + H + ")"),
            CLASS: new RegExp("^\\.(" + H + ")"),
            TAG: new RegExp("^(" + H + "|[*])"),
            ATTR: new RegExp("^" + B),
            PSEUDO: new RegExp("^" + U),
            CHILD: new RegExp(
              "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" +
                z +
                "*(even|odd|(([+-]|)(\\d*)n|)" +
                z +
                "*(?:([+-]|)" +
                z +
                "*(\\d+)|))" +
                z +
                "*\\)|)",
              "i"
            ),
            bool: new RegExp("^(?:" + O + ")$", "i"),
            needsContext: new RegExp(
              "^" +
                z +
                "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
                z +
                "*((?:-\\d)?\\d*)" +
                z +
                "*\\)|)(?=[^-]|$)",
              "i"
            ),
          },
          J = /HTML$/i,
          Y = /^(?:input|select|textarea|button)$/i,
          Z = /^h\d$/i,
          Q = /^[^{]+\{\s*\[native \w/,
          K = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
          tt = /[+~]/,
          et = new RegExp(
            "\\\\[\\da-fA-F]{1,6}" + z + "?|\\\\([^\\r\\n\\f])",
            "g"
          ),
          nt = function (t, e) {
            var n = "0x" + t.slice(1) - 65536;
            return (
              e ||
              (n < 0
                ? String.fromCharCode(n + 65536)
                : String.fromCharCode((n >> 10) | 55296, (1023 & n) | 56320))
            );
          },
          it = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
          rt = function (t, e) {
            return e
              ? "\0" === t
                ? "�"
                : t.slice(0, -1) +
                  "\\" +
                  t.charCodeAt(t.length - 1).toString(16) +
                  " "
              : "\\" + t;
          },
          st = function () {
            d();
          },
          ot = bt(
            function (t) {
              return (
                !0 === t.disabled && "fieldset" === t.nodeName.toLowerCase()
              );
            },
            { dir: "parentNode", next: "legend" }
          );
        try {
          k.apply((R = I.call(_.childNodes)), _.childNodes),
            R[_.childNodes.length].nodeType;
        } catch (t) {
          k = {
            apply: R.length
              ? function (t, e) {
                  D.apply(t, I.call(e));
                }
              : function (t, e) {
                  for (var n = t.length, i = 0; (t[n++] = e[i++]); );
                  t.length = n - 1;
                },
          };
        }
        function at(t, e, i, r) {
          var s,
            a,
            c,
            u,
            h,
            f,
            v,
            y = e && e.ownerDocument,
            _ = e ? e.nodeType : 9;
          if (
            ((i = i || []),
            "string" != typeof t || !t || (1 !== _ && 9 !== _ && 11 !== _))
          )
            return i;
          if (!r && (d(e), (e = e || p), m)) {
            if (11 !== _ && (h = K.exec(t)))
              if ((s = h[1])) {
                if (9 === _) {
                  if (!(c = e.getElementById(s))) return i;
                  if (c.id === s) return i.push(c), i;
                } else if (
                  y &&
                  (c = y.getElementById(s)) &&
                  x(e, c) &&
                  c.id === s
                )
                  return i.push(c), i;
              } else {
                if (h[2]) return k.apply(i, e.getElementsByTagName(t)), i;
                if (
                  (s = h[3]) &&
                  n.getElementsByClassName &&
                  e.getElementsByClassName
                )
                  return k.apply(i, e.getElementsByClassName(s)), i;
              }
            if (
              n.qsa &&
              !A[t + " "] &&
              (!g || !g.test(t)) &&
              (1 !== _ || "object" !== e.nodeName.toLowerCase())
            ) {
              if (((v = t), (y = e), 1 === _ && (j.test(t) || G.test(t)))) {
                for (
                  ((y = (tt.test(t) && vt(e.parentNode)) || e) === e &&
                    n.scope) ||
                    ((u = e.getAttribute("id"))
                      ? (u = u.replace(it, rt))
                      : e.setAttribute("id", (u = b))),
                    a = (f = o(t)).length;
                  a--;

                )
                  f[a] = (u ? "#" + u : ":scope") + " " + xt(f[a]);
                v = f.join(",");
              }
              try {
                return k.apply(i, y.querySelectorAll(v)), i;
              } catch (e) {
                A(t, !0);
              } finally {
                u === b && e.removeAttribute("id");
              }
            }
          }
          return l(t.replace(V, "$1"), e, i, r);
        }
        function lt() {
          var t = [];
          return function e(n, r) {
            return (
              t.push(n + " ") > i.cacheLength && delete e[t.shift()],
              (e[n + " "] = r)
            );
          };
        }
        function ct(t) {
          return (t[b] = !0), t;
        }
        function ut(t) {
          var e = p.createElement("fieldset");
          try {
            return !!t(e);
          } catch (t) {
            return !1;
          } finally {
            e.parentNode && e.parentNode.removeChild(e), (e = null);
          }
        }
        function ht(t, e) {
          for (var n = t.split("|"), r = n.length; r--; )
            i.attrHandle[n[r]] = e;
        }
        function dt(t, e) {
          var n = e && t,
            i =
              n &&
              1 === t.nodeType &&
              1 === e.nodeType &&
              t.sourceIndex - e.sourceIndex;
          if (i) return i;
          if (n) for (; (n = n.nextSibling); ) if (n === e) return -1;
          return t ? 1 : -1;
        }
        function pt(t) {
          return function (e) {
            return "input" === e.nodeName.toLowerCase() && e.type === t;
          };
        }
        function ft(t) {
          return function (e) {
            var n = e.nodeName.toLowerCase();
            return ("input" === n || "button" === n) && e.type === t;
          };
        }
        function mt(t) {
          return function (e) {
            return "form" in e
              ? e.parentNode && !1 === e.disabled
                ? "label" in e
                  ? "label" in e.parentNode
                    ? e.parentNode.disabled === t
                    : e.disabled === t
                  : e.isDisabled === t || (e.isDisabled !== !t && ot(e) === t)
                : e.disabled === t
              : "label" in e && e.disabled === t;
          };
        }
        function gt(t) {
          return ct(function (e) {
            return (
              (e = +e),
              ct(function (n, i) {
                for (var r, s = t([], n.length, e), o = s.length; o--; )
                  n[(r = s[o])] && (n[r] = !(i[r] = n[r]));
              })
            );
          });
        }
        function vt(t) {
          return t && void 0 !== t.getElementsByTagName && t;
        }
        for (e in ((n = at.support = {}),
        (s = at.isXML =
          function (t) {
            var e = t && t.namespaceURI,
              n = t && (t.ownerDocument || t).documentElement;
            return !J.test(e || (n && n.nodeName) || "HTML");
          }),
        (d = at.setDocument =
          function (t) {
            var e,
              r,
              o = t ? t.ownerDocument || t : _;
            return o != p && 9 === o.nodeType && o.documentElement
              ? ((f = (p = o).documentElement),
                (m = !s(p)),
                _ != p &&
                  (r = p.defaultView) &&
                  r.top !== r &&
                  (r.addEventListener
                    ? r.addEventListener("unload", st, !1)
                    : r.attachEvent && r.attachEvent("onunload", st)),
                (n.scope = ut(function (t) {
                  return (
                    f.appendChild(t).appendChild(p.createElement("div")),
                    void 0 !== t.querySelectorAll &&
                      !t.querySelectorAll(":scope fieldset div").length
                  );
                })),
                (n.attributes = ut(function (t) {
                  return (t.className = "i"), !t.getAttribute("className");
                })),
                (n.getElementsByTagName = ut(function (t) {
                  return (
                    t.appendChild(p.createComment("")),
                    !t.getElementsByTagName("*").length
                  );
                })),
                (n.getElementsByClassName = Q.test(p.getElementsByClassName)),
                (n.getById = ut(function (t) {
                  return (
                    (f.appendChild(t).id = b),
                    !p.getElementsByName || !p.getElementsByName(b).length
                  );
                })),
                n.getById
                  ? ((i.filter.ID = function (t) {
                      var e = t.replace(et, nt);
                      return function (t) {
                        return t.getAttribute("id") === e;
                      };
                    }),
                    (i.find.ID = function (t, e) {
                      if (void 0 !== e.getElementById && m) {
                        var n = e.getElementById(t);
                        return n ? [n] : [];
                      }
                    }))
                  : ((i.filter.ID = function (t) {
                      var e = t.replace(et, nt);
                      return function (t) {
                        var n =
                          void 0 !== t.getAttributeNode &&
                          t.getAttributeNode("id");
                        return n && n.value === e;
                      };
                    }),
                    (i.find.ID = function (t, e) {
                      if (void 0 !== e.getElementById && m) {
                        var n,
                          i,
                          r,
                          s = e.getElementById(t);
                        if (s) {
                          if ((n = s.getAttributeNode("id")) && n.value === t)
                            return [s];
                          for (
                            r = e.getElementsByName(t), i = 0;
                            (s = r[i++]);

                          )
                            if ((n = s.getAttributeNode("id")) && n.value === t)
                              return [s];
                        }
                        return [];
                      }
                    })),
                (i.find.TAG = n.getElementsByTagName
                  ? function (t, e) {
                      return void 0 !== e.getElementsByTagName
                        ? e.getElementsByTagName(t)
                        : n.qsa
                        ? e.querySelectorAll(t)
                        : void 0;
                    }
                  : function (t, e) {
                      var n,
                        i = [],
                        r = 0,
                        s = e.getElementsByTagName(t);
                      if ("*" === t) {
                        for (; (n = s[r++]); ) 1 === n.nodeType && i.push(n);
                        return i;
                      }
                      return s;
                    }),
                (i.find.CLASS =
                  n.getElementsByClassName &&
                  function (t, e) {
                    if (void 0 !== e.getElementsByClassName && m)
                      return e.getElementsByClassName(t);
                  }),
                (v = []),
                (g = []),
                (n.qsa = Q.test(p.querySelectorAll)) &&
                  (ut(function (t) {
                    var e;
                    (f.appendChild(t).innerHTML =
                      "<a id='" +
                      b +
                      "'></a><select id='" +
                      b +
                      "-\r\\' msallowcapture=''><option selected=''></option></select>"),
                      t.querySelectorAll("[msallowcapture^='']").length &&
                        g.push("[*^$]=" + z + "*(?:''|\"\")"),
                      t.querySelectorAll("[selected]").length ||
                        g.push("\\[" + z + "*(?:value|" + O + ")"),
                      t.querySelectorAll("[id~=" + b + "-]").length ||
                        g.push("~="),
                      (e = p.createElement("input")).setAttribute("name", ""),
                      t.appendChild(e),
                      t.querySelectorAll("[name='']").length ||
                        g.push(
                          "\\[" + z + "*name" + z + "*=" + z + "*(?:''|\"\")"
                        ),
                      t.querySelectorAll(":checked").length ||
                        g.push(":checked"),
                      t.querySelectorAll("a#" + b + "+*").length ||
                        g.push(".#.+[+~]"),
                      t.querySelectorAll("\\\f"),
                      g.push("[\\r\\n\\f]");
                  }),
                  ut(function (t) {
                    t.innerHTML =
                      "<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>";
                    var e = p.createElement("input");
                    e.setAttribute("type", "hidden"),
                      t.appendChild(e).setAttribute("name", "D"),
                      t.querySelectorAll("[name=d]").length &&
                        g.push("name" + z + "*[*^$|!~]?="),
                      2 !== t.querySelectorAll(":enabled").length &&
                        g.push(":enabled", ":disabled"),
                      (f.appendChild(t).disabled = !0),
                      2 !== t.querySelectorAll(":disabled").length &&
                        g.push(":enabled", ":disabled"),
                      t.querySelectorAll("*,:x"),
                      g.push(",.*:");
                  })),
                (n.matchesSelector = Q.test(
                  (y =
                    f.matches ||
                    f.webkitMatchesSelector ||
                    f.mozMatchesSelector ||
                    f.oMatchesSelector ||
                    f.msMatchesSelector)
                )) &&
                  ut(function (t) {
                    (n.disconnectedMatch = y.call(t, "*")),
                      y.call(t, "[s!='']:x"),
                      v.push("!=", U);
                  }),
                (g = g.length && new RegExp(g.join("|"))),
                (v = v.length && new RegExp(v.join("|"))),
                (e = Q.test(f.compareDocumentPosition)),
                (x =
                  e || Q.test(f.contains)
                    ? function (t, e) {
                        var n = 9 === t.nodeType ? t.documentElement : t,
                          i = e && e.parentNode;
                        return (
                          t === i ||
                          !(
                            !i ||
                            1 !== i.nodeType ||
                            !(n.contains
                              ? n.contains(i)
                              : t.compareDocumentPosition &&
                                16 & t.compareDocumentPosition(i))
                          )
                        );
                      }
                    : function (t, e) {
                        if (e)
                          for (; (e = e.parentNode); ) if (e === t) return !0;
                        return !1;
                      }),
                (C = e
                  ? function (t, e) {
                      if (t === e) return (h = !0), 0;
                      var i =
                        !t.compareDocumentPosition - !e.compareDocumentPosition;
                      return (
                        i ||
                        (1 &
                          (i =
                            (t.ownerDocument || t) == (e.ownerDocument || e)
                              ? t.compareDocumentPosition(e)
                              : 1) ||
                        (!n.sortDetached && e.compareDocumentPosition(t) === i)
                          ? t == p || (t.ownerDocument == _ && x(_, t))
                            ? -1
                            : e == p || (e.ownerDocument == _ && x(_, e))
                            ? 1
                            : u
                            ? N(u, t) - N(u, e)
                            : 0
                          : 4 & i
                          ? -1
                          : 1)
                      );
                    }
                  : function (t, e) {
                      if (t === e) return (h = !0), 0;
                      var n,
                        i = 0,
                        r = t.parentNode,
                        s = e.parentNode,
                        o = [t],
                        a = [e];
                      if (!r || !s)
                        return t == p
                          ? -1
                          : e == p
                          ? 1
                          : r
                          ? -1
                          : s
                          ? 1
                          : u
                          ? N(u, t) - N(u, e)
                          : 0;
                      if (r === s) return dt(t, e);
                      for (n = t; (n = n.parentNode); ) o.unshift(n);
                      for (n = e; (n = n.parentNode); ) a.unshift(n);
                      for (; o[i] === a[i]; ) i++;
                      return i
                        ? dt(o[i], a[i])
                        : o[i] == _
                        ? -1
                        : a[i] == _
                        ? 1
                        : 0;
                    }),
                p)
              : p;
          }),
        (at.matches = function (t, e) {
          return at(t, null, null, e);
        }),
        (at.matchesSelector = function (t, e) {
          if (
            (d(t),
            n.matchesSelector &&
              m &&
              !A[e + " "] &&
              (!v || !v.test(e)) &&
              (!g || !g.test(e)))
          )
            try {
              var i = y.call(t, e);
              if (
                i ||
                n.disconnectedMatch ||
                (t.document && 11 !== t.document.nodeType)
              )
                return i;
            } catch (t) {
              A(e, !0);
            }
          return at(e, p, null, [t]).length > 0;
        }),
        (at.contains = function (t, e) {
          return (t.ownerDocument || t) != p && d(t), x(t, e);
        }),
        (at.attr = function (t, e) {
          (t.ownerDocument || t) != p && d(t);
          var r = i.attrHandle[e.toLowerCase()],
            s =
              r && L.call(i.attrHandle, e.toLowerCase()) ? r(t, e, !m) : void 0;
          return void 0 !== s
            ? s
            : n.attributes || !m
            ? t.getAttribute(e)
            : (s = t.getAttributeNode(e)) && s.specified
            ? s.value
            : null;
        }),
        (at.escape = function (t) {
          return (t + "").replace(it, rt);
        }),
        (at.error = function (t) {
          throw new Error("Syntax error, unrecognized expression: " + t);
        }),
        (at.uniqueSort = function (t) {
          var e,
            i = [],
            r = 0,
            s = 0;
          if (
            ((h = !n.detectDuplicates),
            (u = !n.sortStable && t.slice(0)),
            t.sort(C),
            h)
          ) {
            for (; (e = t[s++]); ) e === t[s] && (r = i.push(s));
            for (; r--; ) t.splice(i[r], 1);
          }
          return (u = null), t;
        }),
        (r = at.getText =
          function (t) {
            var e,
              n = "",
              i = 0,
              s = t.nodeType;
            if (s) {
              if (1 === s || 9 === s || 11 === s) {
                if ("string" == typeof t.textContent) return t.textContent;
                for (t = t.firstChild; t; t = t.nextSibling) n += r(t);
              } else if (3 === s || 4 === s) return t.nodeValue;
            } else for (; (e = t[i++]); ) n += r(e);
            return n;
          }),
        ((i = at.selectors =
          {
            cacheLength: 50,
            createPseudo: ct,
            match: X,
            attrHandle: {},
            find: {},
            relative: {
              ">": { dir: "parentNode", first: !0 },
              " ": { dir: "parentNode" },
              "+": { dir: "previousSibling", first: !0 },
              "~": { dir: "previousSibling" },
            },
            preFilter: {
              ATTR: function (t) {
                return (
                  (t[1] = t[1].replace(et, nt)),
                  (t[3] = (t[3] || t[4] || t[5] || "").replace(et, nt)),
                  "~=" === t[2] && (t[3] = " " + t[3] + " "),
                  t.slice(0, 4)
                );
              },
              CHILD: function (t) {
                return (
                  (t[1] = t[1].toLowerCase()),
                  "nth" === t[1].slice(0, 3)
                    ? (t[3] || at.error(t[0]),
                      (t[4] = +(t[4]
                        ? t[5] + (t[6] || 1)
                        : 2 * ("even" === t[3] || "odd" === t[3]))),
                      (t[5] = +(t[7] + t[8] || "odd" === t[3])))
                    : t[3] && at.error(t[0]),
                  t
                );
              },
              PSEUDO: function (t) {
                var e,
                  n = !t[6] && t[2];
                return X.CHILD.test(t[0])
                  ? null
                  : (t[3]
                      ? (t[2] = t[4] || t[5] || "")
                      : n &&
                        q.test(n) &&
                        (e = o(n, !0)) &&
                        (e = n.indexOf(")", n.length - e) - n.length) &&
                        ((t[0] = t[0].slice(0, e)), (t[2] = n.slice(0, e))),
                    t.slice(0, 3));
              },
            },
            filter: {
              TAG: function (t) {
                var e = t.replace(et, nt).toLowerCase();
                return "*" === t
                  ? function () {
                      return !0;
                    }
                  : function (t) {
                      return t.nodeName && t.nodeName.toLowerCase() === e;
                    };
              },
              CLASS: function (t) {
                var e = M[t + " "];
                return (
                  e ||
                  ((e = new RegExp("(^|" + z + ")" + t + "(" + z + "|$)")) &&
                    M(t, function (t) {
                      return e.test(
                        ("string" == typeof t.className && t.className) ||
                          (void 0 !== t.getAttribute &&
                            t.getAttribute("class")) ||
                          ""
                      );
                    }))
                );
              },
              ATTR: function (t, e, n) {
                return function (i) {
                  var r = at.attr(i, t);
                  return null == r
                    ? "!=" === e
                    : !e ||
                        ((r += ""),
                        "=" === e
                          ? r === n
                          : "!=" === e
                          ? r !== n
                          : "^=" === e
                          ? n && 0 === r.indexOf(n)
                          : "*=" === e
                          ? n && r.indexOf(n) > -1
                          : "$=" === e
                          ? n && r.slice(-n.length) === n
                          : "~=" === e
                          ? (" " + r.replace(F, " ") + " ").indexOf(n) > -1
                          : "|=" === e &&
                            (r === n || r.slice(0, n.length + 1) === n + "-"));
                };
              },
              CHILD: function (t, e, n, i, r) {
                var s = "nth" !== t.slice(0, 3),
                  o = "last" !== t.slice(-4),
                  a = "of-type" === e;
                return 1 === i && 0 === r
                  ? function (t) {
                      return !!t.parentNode;
                    }
                  : function (e, n, l) {
                      var c,
                        u,
                        h,
                        d,
                        p,
                        f,
                        m = s !== o ? "nextSibling" : "previousSibling",
                        g = e.parentNode,
                        v = a && e.nodeName.toLowerCase(),
                        y = !l && !a,
                        x = !1;
                      if (g) {
                        if (s) {
                          for (; m; ) {
                            for (d = e; (d = d[m]); )
                              if (
                                a
                                  ? d.nodeName.toLowerCase() === v
                                  : 1 === d.nodeType
                              )
                                return !1;
                            f = m = "only" === t && !f && "nextSibling";
                          }
                          return !0;
                        }
                        if (((f = [o ? g.firstChild : g.lastChild]), o && y)) {
                          for (
                            x =
                              (p =
                                (c =
                                  (u =
                                    (h = (d = g)[b] || (d[b] = {}))[
                                      d.uniqueID
                                    ] || (h[d.uniqueID] = {}))[t] || [])[0] ===
                                  w && c[1]) && c[2],
                              d = p && g.childNodes[p];
                            (d = (++p && d && d[m]) || (x = p = 0) || f.pop());

                          )
                            if (1 === d.nodeType && ++x && d === e) {
                              u[t] = [w, p, x];
                              break;
                            }
                        } else if (
                          (y &&
                            (x = p =
                              (c =
                                (u =
                                  (h = (d = e)[b] || (d[b] = {}))[d.uniqueID] ||
                                  (h[d.uniqueID] = {}))[t] || [])[0] === w &&
                              c[1]),
                          !1 === x)
                        )
                          for (
                            ;
                            (d =
                              (++p && d && d[m]) || (x = p = 0) || f.pop()) &&
                            ((a
                              ? d.nodeName.toLowerCase() !== v
                              : 1 !== d.nodeType) ||
                              !++x ||
                              (y &&
                                ((u =
                                  (h = d[b] || (d[b] = {}))[d.uniqueID] ||
                                  (h[d.uniqueID] = {}))[t] = [w, x]),
                              d !== e));

                          );
                        return (x -= r) === i || (x % i == 0 && x / i >= 0);
                      }
                    };
              },
              PSEUDO: function (t, e) {
                var n,
                  r =
                    i.pseudos[t] ||
                    i.setFilters[t.toLowerCase()] ||
                    at.error("unsupported pseudo: " + t);
                return r[b]
                  ? r(e)
                  : r.length > 1
                  ? ((n = [t, t, "", e]),
                    i.setFilters.hasOwnProperty(t.toLowerCase())
                      ? ct(function (t, n) {
                          for (var i, s = r(t, e), o = s.length; o--; )
                            t[(i = N(t, s[o]))] = !(n[i] = s[o]);
                        })
                      : function (t) {
                          return r(t, 0, n);
                        })
                  : r;
              },
            },
            pseudos: {
              not: ct(function (t) {
                var e = [],
                  n = [],
                  i = a(t.replace(V, "$1"));
                return i[b]
                  ? ct(function (t, e, n, r) {
                      for (var s, o = i(t, null, r, []), a = t.length; a--; )
                        (s = o[a]) && (t[a] = !(e[a] = s));
                    })
                  : function (t, r, s) {
                      return (
                        (e[0] = t), i(e, null, s, n), (e[0] = null), !n.pop()
                      );
                    };
              }),
              has: ct(function (t) {
                return function (e) {
                  return at(t, e).length > 0;
                };
              }),
              contains: ct(function (t) {
                return (
                  (t = t.replace(et, nt)),
                  function (e) {
                    return (e.textContent || r(e)).indexOf(t) > -1;
                  }
                );
              }),
              lang: ct(function (t) {
                return (
                  $.test(t || "") || at.error("unsupported lang: " + t),
                  (t = t.replace(et, nt).toLowerCase()),
                  function (e) {
                    var n;
                    do {
                      if (
                        (n = m
                          ? e.lang
                          : e.getAttribute("xml:lang") ||
                            e.getAttribute("lang"))
                      )
                        return (
                          (n = n.toLowerCase()) === t ||
                          0 === n.indexOf(t + "-")
                        );
                    } while ((e = e.parentNode) && 1 === e.nodeType);
                    return !1;
                  }
                );
              }),
              target: function (e) {
                var n = t.location && t.location.hash;
                return n && n.slice(1) === e.id;
              },
              root: function (t) {
                return t === f;
              },
              focus: function (t) {
                return (
                  t === p.activeElement &&
                  (!p.hasFocus || p.hasFocus()) &&
                  !!(t.type || t.href || ~t.tabIndex)
                );
              },
              enabled: mt(!1),
              disabled: mt(!0),
              checked: function (t) {
                var e = t.nodeName.toLowerCase();
                return (
                  ("input" === e && !!t.checked) ||
                  ("option" === e && !!t.selected)
                );
              },
              selected: function (t) {
                return (
                  t.parentNode && t.parentNode.selectedIndex, !0 === t.selected
                );
              },
              empty: function (t) {
                for (t = t.firstChild; t; t = t.nextSibling)
                  if (t.nodeType < 6) return !1;
                return !0;
              },
              parent: function (t) {
                return !i.pseudos.empty(t);
              },
              header: function (t) {
                return Z.test(t.nodeName);
              },
              input: function (t) {
                return Y.test(t.nodeName);
              },
              button: function (t) {
                var e = t.nodeName.toLowerCase();
                return ("input" === e && "button" === t.type) || "button" === e;
              },
              text: function (t) {
                var e;
                return (
                  "input" === t.nodeName.toLowerCase() &&
                  "text" === t.type &&
                  (null == (e = t.getAttribute("type")) ||
                    "text" === e.toLowerCase())
                );
              },
              first: gt(function () {
                return [0];
              }),
              last: gt(function (t, e) {
                return [e - 1];
              }),
              eq: gt(function (t, e, n) {
                return [n < 0 ? n + e : n];
              }),
              even: gt(function (t, e) {
                for (var n = 0; n < e; n += 2) t.push(n);
                return t;
              }),
              odd: gt(function (t, e) {
                for (var n = 1; n < e; n += 2) t.push(n);
                return t;
              }),
              lt: gt(function (t, e, n) {
                for (var i = n < 0 ? n + e : n > e ? e : n; --i >= 0; )
                  t.push(i);
                return t;
              }),
              gt: gt(function (t, e, n) {
                for (var i = n < 0 ? n + e : n; ++i < e; ) t.push(i);
                return t;
              }),
            },
          }).pseudos.nth = i.pseudos.eq),
        { radio: !0, checkbox: !0, file: !0, password: !0, image: !0 }))
          i.pseudos[e] = pt(e);
        for (e in { submit: !0, reset: !0 }) i.pseudos[e] = ft(e);
        function yt() {}
        function xt(t) {
          for (var e = 0, n = t.length, i = ""; e < n; e++) i += t[e].value;
          return i;
        }
        function bt(t, e, n) {
          var i = e.dir,
            r = e.next,
            s = r || i,
            o = n && "parentNode" === s,
            a = S++;
          return e.first
            ? function (e, n, r) {
                for (; (e = e[i]); )
                  if (1 === e.nodeType || o) return t(e, n, r);
                return !1;
              }
            : function (e, n, l) {
                var c,
                  u,
                  h,
                  d = [w, a];
                if (l) {
                  for (; (e = e[i]); )
                    if ((1 === e.nodeType || o) && t(e, n, l)) return !0;
                } else
                  for (; (e = e[i]); )
                    if (1 === e.nodeType || o)
                      if (
                        ((u =
                          (h = e[b] || (e[b] = {}))[e.uniqueID] ||
                          (h[e.uniqueID] = {})),
                        r && r === e.nodeName.toLowerCase())
                      )
                        e = e[i] || e;
                      else {
                        if ((c = u[s]) && c[0] === w && c[1] === a)
                          return (d[2] = c[2]);
                        if (((u[s] = d), (d[2] = t(e, n, l)))) return !0;
                      }
                return !1;
              };
        }
        function _t(t) {
          return t.length > 1
            ? function (e, n, i) {
                for (var r = t.length; r--; ) if (!t[r](e, n, i)) return !1;
                return !0;
              }
            : t[0];
        }
        function wt(t, e, n, i, r) {
          for (var s, o = [], a = 0, l = t.length, c = null != e; a < l; a++)
            (s = t[a]) && ((n && !n(s, i, r)) || (o.push(s), c && e.push(a)));
          return o;
        }
        function St(t, e, n, i, r, s) {
          return (
            i && !i[b] && (i = St(i)),
            r && !r[b] && (r = St(r, s)),
            ct(function (s, o, a, l) {
              var c,
                u,
                h,
                d = [],
                p = [],
                f = o.length,
                m =
                  s ||
                  (function (t, e, n) {
                    for (var i = 0, r = e.length; i < r; i++) at(t, e[i], n);
                    return n;
                  })(e || "*", a.nodeType ? [a] : a, []),
                g = !t || (!s && e) ? m : wt(m, d, t, a, l),
                v = n ? (r || (s ? t : f || i) ? [] : o) : g;
              if ((n && n(g, v, a, l), i))
                for (c = wt(v, p), i(c, [], a, l), u = c.length; u--; )
                  (h = c[u]) && (v[p[u]] = !(g[p[u]] = h));
              if (s) {
                if (r || t) {
                  if (r) {
                    for (c = [], u = v.length; u--; )
                      (h = v[u]) && c.push((g[u] = h));
                    r(null, (v = []), c, l);
                  }
                  for (u = v.length; u--; )
                    (h = v[u]) &&
                      (c = r ? N(s, h) : d[u]) > -1 &&
                      (s[c] = !(o[c] = h));
                }
              } else (v = wt(v === o ? v.splice(f, v.length) : v)), r ? r(null, o, v, l) : k.apply(o, v);
            })
          );
        }
        function Mt(t) {
          for (
            var e,
              n,
              r,
              s = t.length,
              o = i.relative[t[0].type],
              a = o || i.relative[" "],
              l = o ? 1 : 0,
              u = bt(
                function (t) {
                  return t === e;
                },
                a,
                !0
              ),
              h = bt(
                function (t) {
                  return N(e, t) > -1;
                },
                a,
                !0
              ),
              d = [
                function (t, n, i) {
                  var r =
                    (!o && (i || n !== c)) ||
                    ((e = n).nodeType ? u(t, n, i) : h(t, n, i));
                  return (e = null), r;
                },
              ];
            l < s;
            l++
          )
            if ((n = i.relative[t[l].type])) d = [bt(_t(d), n)];
            else {
              if ((n = i.filter[t[l].type].apply(null, t[l].matches))[b]) {
                for (r = ++l; r < s && !i.relative[t[r].type]; r++);
                return St(
                  l > 1 && _t(d),
                  l > 1 &&
                    xt(
                      t
                        .slice(0, l - 1)
                        .concat({ value: " " === t[l - 2].type ? "*" : "" })
                    ).replace(V, "$1"),
                  n,
                  l < r && Mt(t.slice(l, r)),
                  r < s && Mt((t = t.slice(r))),
                  r < s && xt(t)
                );
              }
              d.push(n);
            }
          return _t(d);
        }
        return (
          (yt.prototype = i.filters = i.pseudos),
          (i.setFilters = new yt()),
          (o = at.tokenize =
            function (t, e) {
              var n,
                r,
                s,
                o,
                a,
                l,
                c,
                u = T[t + " "];
              if (u) return e ? 0 : u.slice(0);
              for (a = t, l = [], c = i.preFilter; a; ) {
                for (o in ((n && !(r = W.exec(a))) ||
                  (r && (a = a.slice(r[0].length) || a), l.push((s = []))),
                (n = !1),
                (r = G.exec(a)) &&
                  ((n = r.shift()),
                  s.push({ value: n, type: r[0].replace(V, " ") }),
                  (a = a.slice(n.length))),
                i.filter))
                  !(r = X[o].exec(a)) ||
                    (c[o] && !(r = c[o](r))) ||
                    ((n = r.shift()),
                    s.push({ value: n, type: o, matches: r }),
                    (a = a.slice(n.length)));
                if (!n) break;
              }
              return e ? a.length : a ? at.error(t) : T(t, l).slice(0);
            }),
          (a = at.compile =
            function (t, e) {
              var n,
                r = [],
                s = [],
                a = E[t + " "];
              if (!a) {
                for (e || (e = o(t)), n = e.length; n--; )
                  (a = Mt(e[n]))[b] ? r.push(a) : s.push(a);
                (a = E(
                  t,
                  (function (t, e) {
                    var n = e.length > 0,
                      r = t.length > 0,
                      s = function (s, o, a, l, u) {
                        var h,
                          f,
                          g,
                          v = 0,
                          y = "0",
                          x = s && [],
                          b = [],
                          _ = c,
                          S = s || (r && i.find.TAG("*", u)),
                          M = (w += null == _ ? 1 : Math.random() || 0.1),
                          T = S.length;
                        for (
                          u && (c = o == p || o || u);
                          y !== T && null != (h = S[y]);
                          y++
                        ) {
                          if (r && h) {
                            for (
                              f = 0,
                                o || h.ownerDocument == p || (d(h), (a = !m));
                              (g = t[f++]);

                            )
                              if (g(h, o || p, a)) {
                                l.push(h);
                                break;
                              }
                            u && (w = M);
                          }
                          n && ((h = !g && h) && v--, s && x.push(h));
                        }
                        if (((v += y), n && y !== v)) {
                          for (f = 0; (g = e[f++]); ) g(x, b, o, a);
                          if (s) {
                            if (v > 0)
                              for (; y--; ) x[y] || b[y] || (b[y] = P.call(l));
                            b = wt(b);
                          }
                          k.apply(l, b),
                            u &&
                              !s &&
                              b.length > 0 &&
                              v + e.length > 1 &&
                              at.uniqueSort(l);
                        }
                        return u && ((w = M), (c = _)), x;
                      };
                    return n ? ct(s) : s;
                  })(s, r)
                )).selector = t;
              }
              return a;
            }),
          (l = at.select =
            function (t, e, n, r) {
              var s,
                l,
                c,
                u,
                h,
                d = "function" == typeof t && t,
                p = !r && o((t = d.selector || t));
              if (((n = n || []), 1 === p.length)) {
                if (
                  (l = p[0] = p[0].slice(0)).length > 2 &&
                  "ID" === (c = l[0]).type &&
                  9 === e.nodeType &&
                  m &&
                  i.relative[l[1].type]
                ) {
                  if (
                    !(e = (i.find.ID(c.matches[0].replace(et, nt), e) || [])[0])
                  )
                    return n;
                  d && (e = e.parentNode),
                    (t = t.slice(l.shift().value.length));
                }
                for (
                  s = X.needsContext.test(t) ? 0 : l.length;
                  s-- && ((c = l[s]), !i.relative[(u = c.type)]);

                )
                  if (
                    (h = i.find[u]) &&
                    (r = h(
                      c.matches[0].replace(et, nt),
                      (tt.test(l[0].type) && vt(e.parentNode)) || e
                    ))
                  ) {
                    if ((l.splice(s, 1), !(t = r.length && xt(l))))
                      return k.apply(n, r), n;
                    break;
                  }
              }
              return (
                (d || a(t, p))(
                  r,
                  e,
                  !m,
                  n,
                  !e || (tt.test(t) && vt(e.parentNode)) || e
                ),
                n
              );
            }),
          (n.sortStable = b.split("").sort(C).join("") === b),
          (n.detectDuplicates = !!h),
          d(),
          (n.sortDetached = ut(function (t) {
            return 1 & t.compareDocumentPosition(p.createElement("fieldset"));
          })),
          ut(function (t) {
            return (
              (t.innerHTML = "<a href='#'></a>"),
              "#" === t.firstChild.getAttribute("href")
            );
          }) ||
            ht("type|href|height|width", function (t, e, n) {
              if (!n)
                return t.getAttribute(e, "type" === e.toLowerCase() ? 1 : 2);
            }),
          (n.attributes &&
            ut(function (t) {
              return (
                (t.innerHTML = "<input/>"),
                t.firstChild.setAttribute("value", ""),
                "" === t.firstChild.getAttribute("value")
              );
            })) ||
            ht("value", function (t, e, n) {
              if (!n && "input" === t.nodeName.toLowerCase())
                return t.defaultValue;
            }),
          ut(function (t) {
            return null == t.getAttribute("disabled");
          }) ||
            ht(O, function (t, e, n) {
              var i;
              if (!n)
                return !0 === t[e]
                  ? e.toLowerCase()
                  : (i = t.getAttributeNode(e)) && i.specified
                  ? i.value
                  : null;
            }),
          at
        );
      })(n);
      (S.find = T),
        (S.expr = T.selectors),
        (S.expr[":"] = S.expr.pseudos),
        (S.uniqueSort = S.unique = T.uniqueSort),
        (S.text = T.getText),
        (S.isXMLDoc = T.isXML),
        (S.contains = T.contains),
        (S.escapeSelector = T.escape);
      var E = function (t, e, n) {
          for (var i = [], r = void 0 !== n; (t = t[e]) && 9 !== t.nodeType; )
            if (1 === t.nodeType) {
              if (r && S(t).is(n)) break;
              i.push(t);
            }
          return i;
        },
        A = function (t, e) {
          for (var n = []; t; t = t.nextSibling)
            1 === t.nodeType && t !== e && n.push(t);
          return n;
        },
        C = S.expr.match.needsContext;
      function L(t, e) {
        return t.nodeName && t.nodeName.toLowerCase() === e.toLowerCase();
      }
      var R = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;
      function P(t, e, n) {
        return v(e)
          ? S.grep(t, function (t, i) {
              return !!e.call(t, i, t) !== n;
            })
          : e.nodeType
          ? S.grep(t, function (t) {
              return (t === e) !== n;
            })
          : "string" != typeof e
          ? S.grep(t, function (t) {
              return u.call(e, t) > -1 !== n;
            })
          : S.filter(e, t, n);
      }
      (S.filter = function (t, e, n) {
        var i = e[0];
        return (
          n && (t = ":not(" + t + ")"),
          1 === e.length && 1 === i.nodeType
            ? S.find.matchesSelector(i, t)
              ? [i]
              : []
            : S.find.matches(
                t,
                S.grep(e, function (t) {
                  return 1 === t.nodeType;
                })
              )
        );
      }),
        S.fn.extend({
          find: function (t) {
            var e,
              n,
              i = this.length,
              r = this;
            if ("string" != typeof t)
              return this.pushStack(
                S(t).filter(function () {
                  for (e = 0; e < i; e++) if (S.contains(r[e], this)) return !0;
                })
              );
            for (n = this.pushStack([]), e = 0; e < i; e++) S.find(t, r[e], n);
            return i > 1 ? S.uniqueSort(n) : n;
          },
          filter: function (t) {
            return this.pushStack(P(this, t || [], !1));
          },
          not: function (t) {
            return this.pushStack(P(this, t || [], !0));
          },
          is: function (t) {
            return !!P(
              this,
              "string" == typeof t && C.test(t) ? S(t) : t || [],
              !1
            ).length;
          },
        });
      var D,
        k = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/;
      ((S.fn.init = function (t, e, n) {
        var i, r;
        if (!t) return this;
        if (((n = n || D), "string" == typeof t)) {
          if (
            !(i =
              "<" === t[0] && ">" === t[t.length - 1] && t.length >= 3
                ? [null, t, null]
                : k.exec(t)) ||
            (!i[1] && e)
          )
            return !e || e.jquery
              ? (e || n).find(t)
              : this.constructor(e).find(t);
          if (i[1]) {
            if (
              ((e = e instanceof S ? e[0] : e),
              S.merge(
                this,
                S.parseHTML(
                  i[1],
                  e && e.nodeType ? e.ownerDocument || e : x,
                  !0
                )
              ),
              R.test(i[1]) && S.isPlainObject(e))
            )
              for (i in e) v(this[i]) ? this[i](e[i]) : this.attr(i, e[i]);
            return this;
          }
          return (
            (r = x.getElementById(i[2])) && ((this[0] = r), (this.length = 1)),
            this
          );
        }
        return t.nodeType
          ? ((this[0] = t), (this.length = 1), this)
          : v(t)
          ? void 0 !== n.ready
            ? n.ready(t)
            : t(S)
          : S.makeArray(t, this);
      }).prototype = S.fn),
        (D = S(x));
      var I = /^(?:parents|prev(?:Until|All))/,
        N = { children: !0, contents: !0, next: !0, prev: !0 };
      function O(t, e) {
        for (; (t = t[e]) && 1 !== t.nodeType; );
        return t;
      }
      S.fn.extend({
        has: function (t) {
          var e = S(t, this),
            n = e.length;
          return this.filter(function () {
            for (var t = 0; t < n; t++) if (S.contains(this, e[t])) return !0;
          });
        },
        closest: function (t, e) {
          var n,
            i = 0,
            r = this.length,
            s = [],
            o = "string" != typeof t && S(t);
          if (!C.test(t))
            for (; i < r; i++)
              for (n = this[i]; n && n !== e; n = n.parentNode)
                if (
                  n.nodeType < 11 &&
                  (o
                    ? o.index(n) > -1
                    : 1 === n.nodeType && S.find.matchesSelector(n, t))
                ) {
                  s.push(n);
                  break;
                }
          return this.pushStack(s.length > 1 ? S.uniqueSort(s) : s);
        },
        index: function (t) {
          return t
            ? "string" == typeof t
              ? u.call(S(t), this[0])
              : u.call(this, t.jquery ? t[0] : t)
            : this[0] && this[0].parentNode
            ? this.first().prevAll().length
            : -1;
        },
        add: function (t, e) {
          return this.pushStack(S.uniqueSort(S.merge(this.get(), S(t, e))));
        },
        addBack: function (t) {
          return this.add(
            null == t ? this.prevObject : this.prevObject.filter(t)
          );
        },
      }),
        S.each(
          {
            parent: function (t) {
              var e = t.parentNode;
              return e && 11 !== e.nodeType ? e : null;
            },
            parents: function (t) {
              return E(t, "parentNode");
            },
            parentsUntil: function (t, e, n) {
              return E(t, "parentNode", n);
            },
            next: function (t) {
              return O(t, "nextSibling");
            },
            prev: function (t) {
              return O(t, "previousSibling");
            },
            nextAll: function (t) {
              return E(t, "nextSibling");
            },
            prevAll: function (t) {
              return E(t, "previousSibling");
            },
            nextUntil: function (t, e, n) {
              return E(t, "nextSibling", n);
            },
            prevUntil: function (t, e, n) {
              return E(t, "previousSibling", n);
            },
            siblings: function (t) {
              return A((t.parentNode || {}).firstChild, t);
            },
            children: function (t) {
              return A(t.firstChild);
            },
            contents: function (t) {
              return null != t.contentDocument && o(t.contentDocument)
                ? t.contentDocument
                : (L(t, "template") && (t = t.content || t),
                  S.merge([], t.childNodes));
            },
          },
          function (t, e) {
            S.fn[t] = function (n, i) {
              var r = S.map(this, e, n);
              return (
                "Until" !== t.slice(-5) && (i = n),
                i && "string" == typeof i && (r = S.filter(i, r)),
                this.length > 1 &&
                  (N[t] || S.uniqueSort(r), I.test(t) && r.reverse()),
                this.pushStack(r)
              );
            };
          }
        );
      var z = /[^\x20\t\r\n\f]+/g;
      function H(t) {
        return t;
      }
      function B(t) {
        throw t;
      }
      function U(t, e, n, i) {
        var r;
        try {
          t && v((r = t.promise))
            ? r.call(t).done(e).fail(n)
            : t && v((r = t.then))
            ? r.call(t, e, n)
            : e.apply(void 0, [t].slice(i));
        } catch (t) {
          n.apply(void 0, [t]);
        }
      }
      (S.Callbacks = function (t) {
        t =
          "string" == typeof t
            ? (function (t) {
                var e = {};
                return (
                  S.each(t.match(z) || [], function (t, n) {
                    e[n] = !0;
                  }),
                  e
                );
              })(t)
            : S.extend({}, t);
        var e,
          n,
          i,
          r,
          s = [],
          o = [],
          a = -1,
          l = function () {
            for (r = r || t.once, i = e = !0; o.length; a = -1)
              for (n = o.shift(); ++a < s.length; )
                !1 === s[a].apply(n[0], n[1]) &&
                  t.stopOnFalse &&
                  ((a = s.length), (n = !1));
            t.memory || (n = !1), (e = !1), r && (s = n ? [] : "");
          },
          c = {
            add: function () {
              return (
                s &&
                  (n && !e && ((a = s.length - 1), o.push(n)),
                  (function e(n) {
                    S.each(n, function (n, i) {
                      v(i)
                        ? (t.unique && c.has(i)) || s.push(i)
                        : i && i.length && "string" !== w(i) && e(i);
                    });
                  })(arguments),
                  n && !e && l()),
                this
              );
            },
            remove: function () {
              return (
                S.each(arguments, function (t, e) {
                  for (var n; (n = S.inArray(e, s, n)) > -1; )
                    s.splice(n, 1), n <= a && a--;
                }),
                this
              );
            },
            has: function (t) {
              return t ? S.inArray(t, s) > -1 : s.length > 0;
            },
            empty: function () {
              return s && (s = []), this;
            },
            disable: function () {
              return (r = o = []), (s = n = ""), this;
            },
            disabled: function () {
              return !s;
            },
            lock: function () {
              return (r = o = []), n || e || (s = n = ""), this;
            },
            locked: function () {
              return !!r;
            },
            fireWith: function (t, n) {
              return (
                r ||
                  ((n = [t, (n = n || []).slice ? n.slice() : n]),
                  o.push(n),
                  e || l()),
                this
              );
            },
            fire: function () {
              return c.fireWith(this, arguments), this;
            },
            fired: function () {
              return !!i;
            },
          };
        return c;
      }),
        S.extend({
          Deferred: function (t) {
            var e = [
                [
                  "notify",
                  "progress",
                  S.Callbacks("memory"),
                  S.Callbacks("memory"),
                  2,
                ],
                [
                  "resolve",
                  "done",
                  S.Callbacks("once memory"),
                  S.Callbacks("once memory"),
                  0,
                  "resolved",
                ],
                [
                  "reject",
                  "fail",
                  S.Callbacks("once memory"),
                  S.Callbacks("once memory"),
                  1,
                  "rejected",
                ],
              ],
              i = "pending",
              r = {
                state: function () {
                  return i;
                },
                always: function () {
                  return s.done(arguments).fail(arguments), this;
                },
                catch: function (t) {
                  return r.then(null, t);
                },
                pipe: function () {
                  var t = arguments;
                  return S.Deferred(function (n) {
                    S.each(e, function (e, i) {
                      var r = v(t[i[4]]) && t[i[4]];
                      s[i[1]](function () {
                        var t = r && r.apply(this, arguments);
                        t && v(t.promise)
                          ? t
                              .promise()
                              .progress(n.notify)
                              .done(n.resolve)
                              .fail(n.reject)
                          : n[i[0] + "With"](this, r ? [t] : arguments);
                      });
                    }),
                      (t = null);
                  }).promise();
                },
                then: function (t, i, r) {
                  var s = 0;
                  function o(t, e, i, r) {
                    return function () {
                      var a = this,
                        l = arguments,
                        c = function () {
                          var n, c;
                          if (!(t < s)) {
                            if ((n = i.apply(a, l)) === e.promise())
                              throw new TypeError("Thenable self-resolution");
                            (c =
                              n &&
                              ("object" == typeof n ||
                                "function" == typeof n) &&
                              n.then),
                              v(c)
                                ? r
                                  ? c.call(n, o(s, e, H, r), o(s, e, B, r))
                                  : (s++,
                                    c.call(
                                      n,
                                      o(s, e, H, r),
                                      o(s, e, B, r),
                                      o(s, e, H, e.notifyWith)
                                    ))
                                : (i !== H && ((a = void 0), (l = [n])),
                                  (r || e.resolveWith)(a, l));
                          }
                        },
                        u = r
                          ? c
                          : function () {
                              try {
                                c();
                              } catch (n) {
                                S.Deferred.exceptionHook &&
                                  S.Deferred.exceptionHook(n, u.stackTrace),
                                  t + 1 >= s &&
                                    (i !== B && ((a = void 0), (l = [n])),
                                    e.rejectWith(a, l));
                              }
                            };
                      t
                        ? u()
                        : (S.Deferred.getStackHook &&
                            (u.stackTrace = S.Deferred.getStackHook()),
                          n.setTimeout(u));
                    };
                  }
                  return S.Deferred(function (n) {
                    e[0][3].add(o(0, n, v(r) ? r : H, n.notifyWith)),
                      e[1][3].add(o(0, n, v(t) ? t : H)),
                      e[2][3].add(o(0, n, v(i) ? i : B));
                  }).promise();
                },
                promise: function (t) {
                  return null != t ? S.extend(t, r) : r;
                },
              },
              s = {};
            return (
              S.each(e, function (t, n) {
                var o = n[2],
                  a = n[5];
                (r[n[1]] = o.add),
                  a &&
                    o.add(
                      function () {
                        i = a;
                      },
                      e[3 - t][2].disable,
                      e[3 - t][3].disable,
                      e[0][2].lock,
                      e[0][3].lock
                    ),
                  o.add(n[3].fire),
                  (s[n[0]] = function () {
                    return (
                      s[n[0] + "With"](this === s ? void 0 : this, arguments),
                      this
                    );
                  }),
                  (s[n[0] + "With"] = o.fireWith);
              }),
              r.promise(s),
              t && t.call(s, s),
              s
            );
          },
          when: function (t) {
            var e = arguments.length,
              n = e,
              i = Array(n),
              r = a.call(arguments),
              s = S.Deferred(),
              o = function (t) {
                return function (n) {
                  (i[t] = this),
                    (r[t] = arguments.length > 1 ? a.call(arguments) : n),
                    --e || s.resolveWith(i, r);
                };
              };
            if (
              e <= 1 &&
              (U(t, s.done(o(n)).resolve, s.reject, !e),
              "pending" === s.state() || v(r[n] && r[n].then))
            )
              return s.then();
            for (; n--; ) U(r[n], o(n), s.reject);
            return s.promise();
          },
        });
      var F = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
      (S.Deferred.exceptionHook = function (t, e) {
        n.console &&
          n.console.warn &&
          t &&
          F.test(t.name) &&
          n.console.warn("jQuery.Deferred exception: " + t.message, t.stack, e);
      }),
        (S.readyException = function (t) {
          n.setTimeout(function () {
            throw t;
          });
        });
      var V = S.Deferred();
      function W() {
        x.removeEventListener("DOMContentLoaded", W),
          n.removeEventListener("load", W),
          S.ready();
      }
      (S.fn.ready = function (t) {
        return (
          V.then(t).catch(function (t) {
            S.readyException(t);
          }),
          this
        );
      }),
        S.extend({
          isReady: !1,
          readyWait: 1,
          ready: function (t) {
            (!0 === t ? --S.readyWait : S.isReady) ||
              ((S.isReady = !0),
              (!0 !== t && --S.readyWait > 0) || V.resolveWith(x, [S]));
          },
        }),
        (S.ready.then = V.then),
        "complete" === x.readyState ||
        ("loading" !== x.readyState && !x.documentElement.doScroll)
          ? n.setTimeout(S.ready)
          : (x.addEventListener("DOMContentLoaded", W),
            n.addEventListener("load", W));
      var G = function (t, e, n, i, r, s, o) {
          var a = 0,
            l = t.length,
            c = null == n;
          if ("object" === w(n))
            for (a in ((r = !0), n)) G(t, e, a, n[a], !0, s, o);
          else if (
            void 0 !== i &&
            ((r = !0),
            v(i) || (o = !0),
            c &&
              (o
                ? (e.call(t, i), (e = null))
                : ((c = e),
                  (e = function (t, e, n) {
                    return c.call(S(t), n);
                  }))),
            e)
          )
            for (; a < l; a++) e(t[a], n, o ? i : i.call(t[a], a, e(t[a], n)));
          return r ? t : c ? e.call(t) : l ? e(t[0], n) : s;
        },
        j = /^-ms-/,
        q = /-([a-z])/g;
      function $(t, e) {
        return e.toUpperCase();
      }
      function X(t) {
        return t.replace(j, "ms-").replace(q, $);
      }
      var J = function (t) {
        return 1 === t.nodeType || 9 === t.nodeType || !+t.nodeType;
      };
      function Y() {
        this.expando = S.expando + Y.uid++;
      }
      (Y.uid = 1),
        (Y.prototype = {
          cache: function (t) {
            var e = t[this.expando];
            return (
              e ||
                ((e = {}),
                J(t) &&
                  (t.nodeType
                    ? (t[this.expando] = e)
                    : Object.defineProperty(t, this.expando, {
                        value: e,
                        configurable: !0,
                      }))),
              e
            );
          },
          set: function (t, e, n) {
            var i,
              r = this.cache(t);
            if ("string" == typeof e) r[X(e)] = n;
            else for (i in e) r[X(i)] = e[i];
            return r;
          },
          get: function (t, e) {
            return void 0 === e
              ? this.cache(t)
              : t[this.expando] && t[this.expando][X(e)];
          },
          access: function (t, e, n) {
            return void 0 === e || (e && "string" == typeof e && void 0 === n)
              ? this.get(t, e)
              : (this.set(t, e, n), void 0 !== n ? n : e);
          },
          remove: function (t, e) {
            var n,
              i = t[this.expando];
            if (void 0 !== i) {
              if (void 0 !== e) {
                n = (e = Array.isArray(e)
                  ? e.map(X)
                  : (e = X(e)) in i
                  ? [e]
                  : e.match(z) || []).length;
                for (; n--; ) delete i[e[n]];
              }
              (void 0 === e || S.isEmptyObject(i)) &&
                (t.nodeType
                  ? (t[this.expando] = void 0)
                  : delete t[this.expando]);
            }
          },
          hasData: function (t) {
            var e = t[this.expando];
            return void 0 !== e && !S.isEmptyObject(e);
          },
        });
      var Z = new Y(),
        Q = new Y(),
        K = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
        tt = /[A-Z]/g;
      function et(t, e, n) {
        var i;
        if (void 0 === n && 1 === t.nodeType)
          if (
            ((i = "data-" + e.replace(tt, "-$&").toLowerCase()),
            "string" == typeof (n = t.getAttribute(i)))
          ) {
            try {
              n = (function (t) {
                return (
                  "true" === t ||
                  ("false" !== t &&
                    ("null" === t
                      ? null
                      : t === +t + ""
                      ? +t
                      : K.test(t)
                      ? JSON.parse(t)
                      : t))
                );
              })(n);
            } catch (t) {}
            Q.set(t, e, n);
          } else n = void 0;
        return n;
      }
      S.extend({
        hasData: function (t) {
          return Q.hasData(t) || Z.hasData(t);
        },
        data: function (t, e, n) {
          return Q.access(t, e, n);
        },
        removeData: function (t, e) {
          Q.remove(t, e);
        },
        _data: function (t, e, n) {
          return Z.access(t, e, n);
        },
        _removeData: function (t, e) {
          Z.remove(t, e);
        },
      }),
        S.fn.extend({
          data: function (t, e) {
            var n,
              i,
              r,
              s = this[0],
              o = s && s.attributes;
            if (void 0 === t) {
              if (
                this.length &&
                ((r = Q.get(s)), 1 === s.nodeType && !Z.get(s, "hasDataAttrs"))
              ) {
                for (n = o.length; n--; )
                  o[n] &&
                    0 === (i = o[n].name).indexOf("data-") &&
                    ((i = X(i.slice(5))), et(s, i, r[i]));
                Z.set(s, "hasDataAttrs", !0);
              }
              return r;
            }
            return "object" == typeof t
              ? this.each(function () {
                  Q.set(this, t);
                })
              : G(
                  this,
                  function (e) {
                    var n;
                    if (s && void 0 === e)
                      return void 0 !== (n = Q.get(s, t))
                        ? n
                        : void 0 !== (n = et(s, t))
                        ? n
                        : void 0;
                    this.each(function () {
                      Q.set(this, t, e);
                    });
                  },
                  null,
                  e,
                  arguments.length > 1,
                  null,
                  !0
                );
          },
          removeData: function (t) {
            return this.each(function () {
              Q.remove(this, t);
            });
          },
        }),
        S.extend({
          queue: function (t, e, n) {
            var i;
            if (t)
              return (
                (e = (e || "fx") + "queue"),
                (i = Z.get(t, e)),
                n &&
                  (!i || Array.isArray(n)
                    ? (i = Z.access(t, e, S.makeArray(n)))
                    : i.push(n)),
                i || []
              );
          },
          dequeue: function (t, e) {
            e = e || "fx";
            var n = S.queue(t, e),
              i = n.length,
              r = n.shift(),
              s = S._queueHooks(t, e);
            "inprogress" === r && ((r = n.shift()), i--),
              r &&
                ("fx" === e && n.unshift("inprogress"),
                delete s.stop,
                r.call(
                  t,
                  function () {
                    S.dequeue(t, e);
                  },
                  s
                )),
              !i && s && s.empty.fire();
          },
          _queueHooks: function (t, e) {
            var n = e + "queueHooks";
            return (
              Z.get(t, n) ||
              Z.access(t, n, {
                empty: S.Callbacks("once memory").add(function () {
                  Z.remove(t, [e + "queue", n]);
                }),
              })
            );
          },
        }),
        S.fn.extend({
          queue: function (t, e) {
            var n = 2;
            return (
              "string" != typeof t && ((e = t), (t = "fx"), n--),
              arguments.length < n
                ? S.queue(this[0], t)
                : void 0 === e
                ? this
                : this.each(function () {
                    var n = S.queue(this, t, e);
                    S._queueHooks(this, t),
                      "fx" === t && "inprogress" !== n[0] && S.dequeue(this, t);
                  })
            );
          },
          dequeue: function (t) {
            return this.each(function () {
              S.dequeue(this, t);
            });
          },
          clearQueue: function (t) {
            return this.queue(t || "fx", []);
          },
          promise: function (t, e) {
            var n,
              i = 1,
              r = S.Deferred(),
              s = this,
              o = this.length,
              a = function () {
                --i || r.resolveWith(s, [s]);
              };
            for (
              "string" != typeof t && ((e = t), (t = void 0)), t = t || "fx";
              o--;

            )
              (n = Z.get(s[o], t + "queueHooks")) &&
                n.empty &&
                (i++, n.empty.add(a));
            return a(), r.promise(e);
          },
        });
      var nt = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,
        it = new RegExp("^(?:([+-])=|)(" + nt + ")([a-z%]*)$", "i"),
        rt = ["Top", "Right", "Bottom", "Left"],
        st = x.documentElement,
        ot = function (t) {
          return S.contains(t.ownerDocument, t);
        },
        at = { composed: !0 };
      st.getRootNode &&
        (ot = function (t) {
          return (
            S.contains(t.ownerDocument, t) ||
            t.getRootNode(at) === t.ownerDocument
          );
        });
      var lt = function (t, e) {
        return (
          "none" === (t = e || t).style.display ||
          ("" === t.style.display && ot(t) && "none" === S.css(t, "display"))
        );
      };
      function ct(t, e, n, i) {
        var r,
          s,
          o = 20,
          a = i
            ? function () {
                return i.cur();
              }
            : function () {
                return S.css(t, e, "");
              },
          l = a(),
          c = (n && n[3]) || (S.cssNumber[e] ? "" : "px"),
          u =
            t.nodeType &&
            (S.cssNumber[e] || ("px" !== c && +l)) &&
            it.exec(S.css(t, e));
        if (u && u[3] !== c) {
          for (l /= 2, c = c || u[3], u = +l || 1; o--; )
            S.style(t, e, u + c),
              (1 - s) * (1 - (s = a() / l || 0.5)) <= 0 && (o = 0),
              (u /= s);
          (u *= 2), S.style(t, e, u + c), (n = n || []);
        }
        return (
          n &&
            ((u = +u || +l || 0),
            (r = n[1] ? u + (n[1] + 1) * n[2] : +n[2]),
            i && ((i.unit = c), (i.start = u), (i.end = r))),
          r
        );
      }
      var ut = {};
      function ht(t) {
        var e,
          n = t.ownerDocument,
          i = t.nodeName,
          r = ut[i];
        return (
          r ||
          ((e = n.body.appendChild(n.createElement(i))),
          (r = S.css(e, "display")),
          e.parentNode.removeChild(e),
          "none" === r && (r = "block"),
          (ut[i] = r),
          r)
        );
      }
      function dt(t, e) {
        for (var n, i, r = [], s = 0, o = t.length; s < o; s++)
          (i = t[s]).style &&
            ((n = i.style.display),
            e
              ? ("none" === n &&
                  ((r[s] = Z.get(i, "display") || null),
                  r[s] || (i.style.display = "")),
                "" === i.style.display && lt(i) && (r[s] = ht(i)))
              : "none" !== n && ((r[s] = "none"), Z.set(i, "display", n)));
        for (s = 0; s < o; s++) null != r[s] && (t[s].style.display = r[s]);
        return t;
      }
      S.fn.extend({
        show: function () {
          return dt(this, !0);
        },
        hide: function () {
          return dt(this);
        },
        toggle: function (t) {
          return "boolean" == typeof t
            ? t
              ? this.show()
              : this.hide()
            : this.each(function () {
                lt(this) ? S(this).show() : S(this).hide();
              });
        },
      });
      var pt,
        ft,
        mt = /^(?:checkbox|radio)$/i,
        gt = /<([a-z][^\/\0>\x20\t\r\n\f]*)/i,
        vt = /^$|^module$|\/(?:java|ecma)script/i;
      (pt = x.createDocumentFragment().appendChild(x.createElement("div"))),
        (ft = x.createElement("input")).setAttribute("type", "radio"),
        ft.setAttribute("checked", "checked"),
        ft.setAttribute("name", "t"),
        pt.appendChild(ft),
        (g.checkClone = pt.cloneNode(!0).cloneNode(!0).lastChild.checked),
        (pt.innerHTML = "<textarea>x</textarea>"),
        (g.noCloneChecked = !!pt.cloneNode(!0).lastChild.defaultValue),
        (pt.innerHTML = "<option></option>"),
        (g.option = !!pt.lastChild);
      var yt = {
        thead: [1, "<table>", "</table>"],
        col: [2, "<table><colgroup>", "</colgroup></table>"],
        tr: [2, "<table><tbody>", "</tbody></table>"],
        td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
        _default: [0, "", ""],
      };
      function xt(t, e) {
        var n;
        return (
          (n =
            void 0 !== t.getElementsByTagName
              ? t.getElementsByTagName(e || "*")
              : void 0 !== t.querySelectorAll
              ? t.querySelectorAll(e || "*")
              : []),
          void 0 === e || (e && L(t, e)) ? S.merge([t], n) : n
        );
      }
      function bt(t, e) {
        for (var n = 0, i = t.length; n < i; n++)
          Z.set(t[n], "globalEval", !e || Z.get(e[n], "globalEval"));
      }
      (yt.tbody = yt.tfoot = yt.colgroup = yt.caption = yt.thead),
        (yt.th = yt.td),
        g.option ||
          (yt.optgroup = yt.option =
            [1, "<select multiple='multiple'>", "</select>"]);
      var _t = /<|&#?\w+;/;
      function wt(t, e, n, i, r) {
        for (
          var s,
            o,
            a,
            l,
            c,
            u,
            h = e.createDocumentFragment(),
            d = [],
            p = 0,
            f = t.length;
          p < f;
          p++
        )
          if ((s = t[p]) || 0 === s)
            if ("object" === w(s)) S.merge(d, s.nodeType ? [s] : s);
            else if (_t.test(s)) {
              for (
                o = o || h.appendChild(e.createElement("div")),
                  a = (gt.exec(s) || ["", ""])[1].toLowerCase(),
                  l = yt[a] || yt._default,
                  o.innerHTML = l[1] + S.htmlPrefilter(s) + l[2],
                  u = l[0];
                u--;

              )
                o = o.lastChild;
              S.merge(d, o.childNodes), ((o = h.firstChild).textContent = "");
            } else d.push(e.createTextNode(s));
        for (h.textContent = "", p = 0; (s = d[p++]); )
          if (i && S.inArray(s, i) > -1) r && r.push(s);
          else if (
            ((c = ot(s)), (o = xt(h.appendChild(s), "script")), c && bt(o), n)
          )
            for (u = 0; (s = o[u++]); ) vt.test(s.type || "") && n.push(s);
        return h;
      }
      var St = /^([^.]*)(?:\.(.+)|)/;
      function Mt() {
        return !0;
      }
      function Tt() {
        return !1;
      }
      function Et(t, e) {
        return (
          (t ===
            (function () {
              try {
                return x.activeElement;
              } catch (t) {}
            })()) ==
          ("focus" === e)
        );
      }
      function At(t, e, n, i, r, s) {
        var o, a;
        if ("object" == typeof e) {
          for (a in ("string" != typeof n && ((i = i || n), (n = void 0)), e))
            At(t, a, n, i, e[a], s);
          return t;
        }
        if (
          (null == i && null == r
            ? ((r = n), (i = n = void 0))
            : null == r &&
              ("string" == typeof n
                ? ((r = i), (i = void 0))
                : ((r = i), (i = n), (n = void 0))),
          !1 === r)
        )
          r = Tt;
        else if (!r) return t;
        return (
          1 === s &&
            ((o = r),
            ((r = function (t) {
              return S().off(t), o.apply(this, arguments);
            }).guid = o.guid || (o.guid = S.guid++))),
          t.each(function () {
            S.event.add(this, e, r, i, n);
          })
        );
      }
      function Ct(t, e, n) {
        n
          ? (Z.set(t, e, !1),
            S.event.add(t, e, {
              namespace: !1,
              handler: function (t) {
                var i,
                  r,
                  s = Z.get(this, e);
                if (1 & t.isTrigger && this[e]) {
                  if (s.length)
                    (S.event.special[e] || {}).delegateType &&
                      t.stopPropagation();
                  else if (
                    ((s = a.call(arguments)),
                    Z.set(this, e, s),
                    (i = n(this, e)),
                    this[e](),
                    s !== (r = Z.get(this, e)) || i
                      ? Z.set(this, e, !1)
                      : (r = {}),
                    s !== r)
                  )
                    return (
                      t.stopImmediatePropagation(),
                      t.preventDefault(),
                      r && r.value
                    );
                } else
                  s.length &&
                    (Z.set(this, e, {
                      value: S.event.trigger(
                        S.extend(s[0], S.Event.prototype),
                        s.slice(1),
                        this
                      ),
                    }),
                    t.stopImmediatePropagation());
              },
            }))
          : void 0 === Z.get(t, e) && S.event.add(t, e, Mt);
      }
      (S.event = {
        global: {},
        add: function (t, e, n, i, r) {
          var s,
            o,
            a,
            l,
            c,
            u,
            h,
            d,
            p,
            f,
            m,
            g = Z.get(t);
          if (J(t))
            for (
              n.handler && ((n = (s = n).handler), (r = s.selector)),
                r && S.find.matchesSelector(st, r),
                n.guid || (n.guid = S.guid++),
                (l = g.events) || (l = g.events = Object.create(null)),
                (o = g.handle) ||
                  (o = g.handle =
                    function (e) {
                      return void 0 !== S && S.event.triggered !== e.type
                        ? S.event.dispatch.apply(t, arguments)
                        : void 0;
                    }),
                c = (e = (e || "").match(z) || [""]).length;
              c--;

            )
              (p = m = (a = St.exec(e[c]) || [])[1]),
                (f = (a[2] || "").split(".").sort()),
                p &&
                  ((h = S.event.special[p] || {}),
                  (p = (r ? h.delegateType : h.bindType) || p),
                  (h = S.event.special[p] || {}),
                  (u = S.extend(
                    {
                      type: p,
                      origType: m,
                      data: i,
                      handler: n,
                      guid: n.guid,
                      selector: r,
                      needsContext: r && S.expr.match.needsContext.test(r),
                      namespace: f.join("."),
                    },
                    s
                  )),
                  (d = l[p]) ||
                    (((d = l[p] = []).delegateCount = 0),
                    (h.setup && !1 !== h.setup.call(t, i, f, o)) ||
                      (t.addEventListener && t.addEventListener(p, o))),
                  h.add &&
                    (h.add.call(t, u),
                    u.handler.guid || (u.handler.guid = n.guid)),
                  r ? d.splice(d.delegateCount++, 0, u) : d.push(u),
                  (S.event.global[p] = !0));
        },
        remove: function (t, e, n, i, r) {
          var s,
            o,
            a,
            l,
            c,
            u,
            h,
            d,
            p,
            f,
            m,
            g = Z.hasData(t) && Z.get(t);
          if (g && (l = g.events)) {
            for (c = (e = (e || "").match(z) || [""]).length; c--; )
              if (
                ((p = m = (a = St.exec(e[c]) || [])[1]),
                (f = (a[2] || "").split(".").sort()),
                p)
              ) {
                for (
                  h = S.event.special[p] || {},
                    d = l[(p = (i ? h.delegateType : h.bindType) || p)] || [],
                    a =
                      a[2] &&
                      new RegExp(
                        "(^|\\.)" + f.join("\\.(?:.*\\.|)") + "(\\.|$)"
                      ),
                    o = s = d.length;
                  s--;

                )
                  (u = d[s]),
                    (!r && m !== u.origType) ||
                      (n && n.guid !== u.guid) ||
                      (a && !a.test(u.namespace)) ||
                      (i && i !== u.selector && ("**" !== i || !u.selector)) ||
                      (d.splice(s, 1),
                      u.selector && d.delegateCount--,
                      h.remove && h.remove.call(t, u));
                o &&
                  !d.length &&
                  ((h.teardown && !1 !== h.teardown.call(t, f, g.handle)) ||
                    S.removeEvent(t, p, g.handle),
                  delete l[p]);
              } else for (p in l) S.event.remove(t, p + e[c], n, i, !0);
            S.isEmptyObject(l) && Z.remove(t, "handle events");
          }
        },
        dispatch: function (t) {
          var e,
            n,
            i,
            r,
            s,
            o,
            a = new Array(arguments.length),
            l = S.event.fix(t),
            c = (Z.get(this, "events") || Object.create(null))[l.type] || [],
            u = S.event.special[l.type] || {};
          for (a[0] = l, e = 1; e < arguments.length; e++) a[e] = arguments[e];
          if (
            ((l.delegateTarget = this),
            !u.preDispatch || !1 !== u.preDispatch.call(this, l))
          ) {
            for (
              o = S.event.handlers.call(this, l, c), e = 0;
              (r = o[e++]) && !l.isPropagationStopped();

            )
              for (
                l.currentTarget = r.elem, n = 0;
                (s = r.handlers[n++]) && !l.isImmediatePropagationStopped();

              )
                (l.rnamespace &&
                  !1 !== s.namespace &&
                  !l.rnamespace.test(s.namespace)) ||
                  ((l.handleObj = s),
                  (l.data = s.data),
                  void 0 !==
                    (i = (
                      (S.event.special[s.origType] || {}).handle || s.handler
                    ).apply(r.elem, a)) &&
                    !1 === (l.result = i) &&
                    (l.preventDefault(), l.stopPropagation()));
            return u.postDispatch && u.postDispatch.call(this, l), l.result;
          }
        },
        handlers: function (t, e) {
          var n,
            i,
            r,
            s,
            o,
            a = [],
            l = e.delegateCount,
            c = t.target;
          if (l && c.nodeType && !("click" === t.type && t.button >= 1))
            for (; c !== this; c = c.parentNode || this)
              if (
                1 === c.nodeType &&
                ("click" !== t.type || !0 !== c.disabled)
              ) {
                for (s = [], o = {}, n = 0; n < l; n++)
                  void 0 === o[(r = (i = e[n]).selector + " ")] &&
                    (o[r] = i.needsContext
                      ? S(r, this).index(c) > -1
                      : S.find(r, this, null, [c]).length),
                    o[r] && s.push(i);
                s.length && a.push({ elem: c, handlers: s });
              }
          return (
            (c = this),
            l < e.length && a.push({ elem: c, handlers: e.slice(l) }),
            a
          );
        },
        addProp: function (t, e) {
          Object.defineProperty(S.Event.prototype, t, {
            enumerable: !0,
            configurable: !0,
            get: v(e)
              ? function () {
                  if (this.originalEvent) return e(this.originalEvent);
                }
              : function () {
                  if (this.originalEvent) return this.originalEvent[t];
                },
            set: function (e) {
              Object.defineProperty(this, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: e,
              });
            },
          });
        },
        fix: function (t) {
          return t[S.expando] ? t : new S.Event(t);
        },
        special: {
          load: { noBubble: !0 },
          click: {
            setup: function (t) {
              var e = this || t;
              return (
                mt.test(e.type) &&
                  e.click &&
                  L(e, "input") &&
                  Ct(e, "click", Mt),
                !1
              );
            },
            trigger: function (t) {
              var e = this || t;
              return (
                mt.test(e.type) && e.click && L(e, "input") && Ct(e, "click"),
                !0
              );
            },
            _default: function (t) {
              var e = t.target;
              return (
                (mt.test(e.type) &&
                  e.click &&
                  L(e, "input") &&
                  Z.get(e, "click")) ||
                L(e, "a")
              );
            },
          },
          beforeunload: {
            postDispatch: function (t) {
              void 0 !== t.result &&
                t.originalEvent &&
                (t.originalEvent.returnValue = t.result);
            },
          },
        },
      }),
        (S.removeEvent = function (t, e, n) {
          t.removeEventListener && t.removeEventListener(e, n);
        }),
        (S.Event = function (t, e) {
          if (!(this instanceof S.Event)) return new S.Event(t, e);
          t && t.type
            ? ((this.originalEvent = t),
              (this.type = t.type),
              (this.isDefaultPrevented =
                t.defaultPrevented ||
                (void 0 === t.defaultPrevented && !1 === t.returnValue)
                  ? Mt
                  : Tt),
              (this.target =
                t.target && 3 === t.target.nodeType
                  ? t.target.parentNode
                  : t.target),
              (this.currentTarget = t.currentTarget),
              (this.relatedTarget = t.relatedTarget))
            : (this.type = t),
            e && S.extend(this, e),
            (this.timeStamp = (t && t.timeStamp) || Date.now()),
            (this[S.expando] = !0);
        }),
        (S.Event.prototype = {
          constructor: S.Event,
          isDefaultPrevented: Tt,
          isPropagationStopped: Tt,
          isImmediatePropagationStopped: Tt,
          isSimulated: !1,
          preventDefault: function () {
            var t = this.originalEvent;
            (this.isDefaultPrevented = Mt),
              t && !this.isSimulated && t.preventDefault();
          },
          stopPropagation: function () {
            var t = this.originalEvent;
            (this.isPropagationStopped = Mt),
              t && !this.isSimulated && t.stopPropagation();
          },
          stopImmediatePropagation: function () {
            var t = this.originalEvent;
            (this.isImmediatePropagationStopped = Mt),
              t && !this.isSimulated && t.stopImmediatePropagation(),
              this.stopPropagation();
          },
        }),
        S.each(
          {
            altKey: !0,
            bubbles: !0,
            cancelable: !0,
            changedTouches: !0,
            ctrlKey: !0,
            detail: !0,
            eventPhase: !0,
            metaKey: !0,
            pageX: !0,
            pageY: !0,
            shiftKey: !0,
            view: !0,
            char: !0,
            code: !0,
            charCode: !0,
            key: !0,
            keyCode: !0,
            button: !0,
            buttons: !0,
            clientX: !0,
            clientY: !0,
            offsetX: !0,
            offsetY: !0,
            pointerId: !0,
            pointerType: !0,
            screenX: !0,
            screenY: !0,
            targetTouches: !0,
            toElement: !0,
            touches: !0,
            which: !0,
          },
          S.event.addProp
        ),
        S.each({ focus: "focusin", blur: "focusout" }, function (t, e) {
          S.event.special[t] = {
            setup: function () {
              return Ct(this, t, Et), !1;
            },
            trigger: function () {
              return Ct(this, t), !0;
            },
            _default: function () {
              return !0;
            },
            delegateType: e,
          };
        }),
        S.each(
          {
            mouseenter: "mouseover",
            mouseleave: "mouseout",
            pointerenter: "pointerover",
            pointerleave: "pointerout",
          },
          function (t, e) {
            S.event.special[t] = {
              delegateType: e,
              bindType: e,
              handle: function (t) {
                var n,
                  i = this,
                  r = t.relatedTarget,
                  s = t.handleObj;
                return (
                  (r && (r === i || S.contains(i, r))) ||
                    ((t.type = s.origType),
                    (n = s.handler.apply(this, arguments)),
                    (t.type = e)),
                  n
                );
              },
            };
          }
        ),
        S.fn.extend({
          on: function (t, e, n, i) {
            return At(this, t, e, n, i);
          },
          one: function (t, e, n, i) {
            return At(this, t, e, n, i, 1);
          },
          off: function (t, e, n) {
            var i, r;
            if (t && t.preventDefault && t.handleObj)
              return (
                (i = t.handleObj),
                S(t.delegateTarget).off(
                  i.namespace ? i.origType + "." + i.namespace : i.origType,
                  i.selector,
                  i.handler
                ),
                this
              );
            if ("object" == typeof t) {
              for (r in t) this.off(r, e, t[r]);
              return this;
            }
            return (
              (!1 !== e && "function" != typeof e) || ((n = e), (e = void 0)),
              !1 === n && (n = Tt),
              this.each(function () {
                S.event.remove(this, t, n, e);
              })
            );
          },
        });
      var Lt = /<script|<style|<link/i,
        Rt = /checked\s*(?:[^=]|=\s*.checked.)/i,
        Pt = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;
      function Dt(t, e) {
        return (
          (L(t, "table") &&
            L(11 !== e.nodeType ? e : e.firstChild, "tr") &&
            S(t).children("tbody")[0]) ||
          t
        );
      }
      function kt(t) {
        return (t.type = (null !== t.getAttribute("type")) + "/" + t.type), t;
      }
      function It(t) {
        return (
          "true/" === (t.type || "").slice(0, 5)
            ? (t.type = t.type.slice(5))
            : t.removeAttribute("type"),
          t
        );
      }
      function Nt(t, e) {
        var n, i, r, s, o, a;
        if (1 === e.nodeType) {
          if (Z.hasData(t) && (a = Z.get(t).events))
            for (r in (Z.remove(e, "handle events"), a))
              for (n = 0, i = a[r].length; n < i; n++)
                S.event.add(e, r, a[r][n]);
          Q.hasData(t) &&
            ((s = Q.access(t)), (o = S.extend({}, s)), Q.set(e, o));
        }
      }
      function Ot(t, e) {
        var n = e.nodeName.toLowerCase();
        "input" === n && mt.test(t.type)
          ? (e.checked = t.checked)
          : ("input" !== n && "textarea" !== n) ||
            (e.defaultValue = t.defaultValue);
      }
      function zt(t, e, n, i) {
        e = l(e);
        var r,
          s,
          o,
          a,
          c,
          u,
          h = 0,
          d = t.length,
          p = d - 1,
          f = e[0],
          m = v(f);
        if (m || (d > 1 && "string" == typeof f && !g.checkClone && Rt.test(f)))
          return t.each(function (r) {
            var s = t.eq(r);
            m && (e[0] = f.call(this, r, s.html())), zt(s, e, n, i);
          });
        if (
          d &&
          ((s = (r = wt(e, t[0].ownerDocument, !1, t, i)).firstChild),
          1 === r.childNodes.length && (r = s),
          s || i)
        ) {
          for (a = (o = S.map(xt(r, "script"), kt)).length; h < d; h++)
            (c = r),
              h !== p &&
                ((c = S.clone(c, !0, !0)), a && S.merge(o, xt(c, "script"))),
              n.call(t[h], c, h);
          if (a)
            for (
              u = o[o.length - 1].ownerDocument, S.map(o, It), h = 0;
              h < a;
              h++
            )
              (c = o[h]),
                vt.test(c.type || "") &&
                  !Z.access(c, "globalEval") &&
                  S.contains(u, c) &&
                  (c.src && "module" !== (c.type || "").toLowerCase()
                    ? S._evalUrl &&
                      !c.noModule &&
                      S._evalUrl(
                        c.src,
                        { nonce: c.nonce || c.getAttribute("nonce") },
                        u
                      )
                    : _(c.textContent.replace(Pt, ""), c, u));
        }
        return t;
      }
      function Ht(t, e, n) {
        for (var i, r = e ? S.filter(e, t) : t, s = 0; null != (i = r[s]); s++)
          n || 1 !== i.nodeType || S.cleanData(xt(i)),
            i.parentNode &&
              (n && ot(i) && bt(xt(i, "script")), i.parentNode.removeChild(i));
        return t;
      }
      S.extend({
        htmlPrefilter: function (t) {
          return t;
        },
        clone: function (t, e, n) {
          var i,
            r,
            s,
            o,
            a = t.cloneNode(!0),
            l = ot(t);
          if (
            !(
              g.noCloneChecked ||
              (1 !== t.nodeType && 11 !== t.nodeType) ||
              S.isXMLDoc(t)
            )
          )
            for (o = xt(a), i = 0, r = (s = xt(t)).length; i < r; i++)
              Ot(s[i], o[i]);
          if (e)
            if (n)
              for (
                s = s || xt(t), o = o || xt(a), i = 0, r = s.length;
                i < r;
                i++
              )
                Nt(s[i], o[i]);
            else Nt(t, a);
          return (
            (o = xt(a, "script")).length > 0 && bt(o, !l && xt(t, "script")), a
          );
        },
        cleanData: function (t) {
          for (
            var e, n, i, r = S.event.special, s = 0;
            void 0 !== (n = t[s]);
            s++
          )
            if (J(n)) {
              if ((e = n[Z.expando])) {
                if (e.events)
                  for (i in e.events)
                    r[i] ? S.event.remove(n, i) : S.removeEvent(n, i, e.handle);
                n[Z.expando] = void 0;
              }
              n[Q.expando] && (n[Q.expando] = void 0);
            }
        },
      }),
        S.fn.extend({
          detach: function (t) {
            return Ht(this, t, !0);
          },
          remove: function (t) {
            return Ht(this, t);
          },
          text: function (t) {
            return G(
              this,
              function (t) {
                return void 0 === t
                  ? S.text(this)
                  : this.empty().each(function () {
                      (1 !== this.nodeType &&
                        11 !== this.nodeType &&
                        9 !== this.nodeType) ||
                        (this.textContent = t);
                    });
              },
              null,
              t,
              arguments.length
            );
          },
          append: function () {
            return zt(this, arguments, function (t) {
              (1 !== this.nodeType &&
                11 !== this.nodeType &&
                9 !== this.nodeType) ||
                Dt(this, t).appendChild(t);
            });
          },
          prepend: function () {
            return zt(this, arguments, function (t) {
              if (
                1 === this.nodeType ||
                11 === this.nodeType ||
                9 === this.nodeType
              ) {
                var e = Dt(this, t);
                e.insertBefore(t, e.firstChild);
              }
            });
          },
          before: function () {
            return zt(this, arguments, function (t) {
              this.parentNode && this.parentNode.insertBefore(t, this);
            });
          },
          after: function () {
            return zt(this, arguments, function (t) {
              this.parentNode &&
                this.parentNode.insertBefore(t, this.nextSibling);
            });
          },
          empty: function () {
            for (var t, e = 0; null != (t = this[e]); e++)
              1 === t.nodeType &&
                (S.cleanData(xt(t, !1)), (t.textContent = ""));
            return this;
          },
          clone: function (t, e) {
            return (
              (t = null != t && t),
              (e = null == e ? t : e),
              this.map(function () {
                return S.clone(this, t, e);
              })
            );
          },
          html: function (t) {
            return G(
              this,
              function (t) {
                var e = this[0] || {},
                  n = 0,
                  i = this.length;
                if (void 0 === t && 1 === e.nodeType) return e.innerHTML;
                if (
                  "string" == typeof t &&
                  !Lt.test(t) &&
                  !yt[(gt.exec(t) || ["", ""])[1].toLowerCase()]
                ) {
                  t = S.htmlPrefilter(t);
                  try {
                    for (; n < i; n++)
                      1 === (e = this[n] || {}).nodeType &&
                        (S.cleanData(xt(e, !1)), (e.innerHTML = t));
                    e = 0;
                  } catch (t) {}
                }
                e && this.empty().append(t);
              },
              null,
              t,
              arguments.length
            );
          },
          replaceWith: function () {
            var t = [];
            return zt(
              this,
              arguments,
              function (e) {
                var n = this.parentNode;
                S.inArray(this, t) < 0 &&
                  (S.cleanData(xt(this)), n && n.replaceChild(e, this));
              },
              t
            );
          },
        }),
        S.each(
          {
            appendTo: "append",
            prependTo: "prepend",
            insertBefore: "before",
            insertAfter: "after",
            replaceAll: "replaceWith",
          },
          function (t, e) {
            S.fn[t] = function (t) {
              for (
                var n, i = [], r = S(t), s = r.length - 1, o = 0;
                o <= s;
                o++
              )
                (n = o === s ? this : this.clone(!0)),
                  S(r[o])[e](n),
                  c.apply(i, n.get());
              return this.pushStack(i);
            };
          }
        );
      var Bt = new RegExp("^(" + nt + ")(?!px)[a-z%]+$", "i"),
        Ut = function (t) {
          var e = t.ownerDocument.defaultView;
          return (e && e.opener) || (e = n), e.getComputedStyle(t);
        },
        Ft = function (t, e, n) {
          var i,
            r,
            s = {};
          for (r in e) (s[r] = t.style[r]), (t.style[r] = e[r]);
          for (r in ((i = n.call(t)), e)) t.style[r] = s[r];
          return i;
        },
        Vt = new RegExp(rt.join("|"), "i");
      function Wt(t, e, n) {
        var i,
          r,
          s,
          o,
          a = t.style;
        return (
          (n = n || Ut(t)) &&
            ("" !== (o = n.getPropertyValue(e) || n[e]) ||
              ot(t) ||
              (o = S.style(t, e)),
            !g.pixelBoxStyles() &&
              Bt.test(o) &&
              Vt.test(e) &&
              ((i = a.width),
              (r = a.minWidth),
              (s = a.maxWidth),
              (a.minWidth = a.maxWidth = a.width = o),
              (o = n.width),
              (a.width = i),
              (a.minWidth = r),
              (a.maxWidth = s))),
          void 0 !== o ? o + "" : o
        );
      }
      function Gt(t, e) {
        return {
          get: function () {
            if (!t()) return (this.get = e).apply(this, arguments);
            delete this.get;
          },
        };
      }
      !(function () {
        function t() {
          if (u) {
            (c.style.cssText =
              "position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0"),
              (u.style.cssText =
                "position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%"),
              st.appendChild(c).appendChild(u);
            var t = n.getComputedStyle(u);
            (i = "1%" !== t.top),
              (l = 12 === e(t.marginLeft)),
              (u.style.right = "60%"),
              (o = 36 === e(t.right)),
              (r = 36 === e(t.width)),
              (u.style.position = "absolute"),
              (s = 12 === e(u.offsetWidth / 3)),
              st.removeChild(c),
              (u = null);
          }
        }
        function e(t) {
          return Math.round(parseFloat(t));
        }
        var i,
          r,
          s,
          o,
          a,
          l,
          c = x.createElement("div"),
          u = x.createElement("div");
        u.style &&
          ((u.style.backgroundClip = "content-box"),
          (u.cloneNode(!0).style.backgroundClip = ""),
          (g.clearCloneStyle = "content-box" === u.style.backgroundClip),
          S.extend(g, {
            boxSizingReliable: function () {
              return t(), r;
            },
            pixelBoxStyles: function () {
              return t(), o;
            },
            pixelPosition: function () {
              return t(), i;
            },
            reliableMarginLeft: function () {
              return t(), l;
            },
            scrollboxSize: function () {
              return t(), s;
            },
            reliableTrDimensions: function () {
              var t, e, i, r;
              return (
                null == a &&
                  ((t = x.createElement("table")),
                  (e = x.createElement("tr")),
                  (i = x.createElement("div")),
                  (t.style.cssText =
                    "position:absolute;left:-11111px;border-collapse:separate"),
                  (e.style.cssText = "border:1px solid"),
                  (e.style.height = "1px"),
                  (i.style.height = "9px"),
                  (i.style.display = "block"),
                  st.appendChild(t).appendChild(e).appendChild(i),
                  (r = n.getComputedStyle(e)),
                  (a =
                    parseInt(r.height, 10) +
                      parseInt(r.borderTopWidth, 10) +
                      parseInt(r.borderBottomWidth, 10) ===
                    e.offsetHeight),
                  st.removeChild(t)),
                a
              );
            },
          }));
      })();
      var jt = ["Webkit", "Moz", "ms"],
        qt = x.createElement("div").style,
        $t = {};
      function Xt(t) {
        var e = S.cssProps[t] || $t[t];
        return (
          e ||
          (t in qt
            ? t
            : ($t[t] =
                (function (t) {
                  for (
                    var e = t[0].toUpperCase() + t.slice(1), n = jt.length;
                    n--;

                  )
                    if ((t = jt[n] + e) in qt) return t;
                })(t) || t))
        );
      }
      var Jt = /^(none|table(?!-c[ea]).+)/,
        Yt = /^--/,
        Zt = { position: "absolute", visibility: "hidden", display: "block" },
        Qt = { letterSpacing: "0", fontWeight: "400" };
      function Kt(t, e, n) {
        var i = it.exec(e);
        return i ? Math.max(0, i[2] - (n || 0)) + (i[3] || "px") : e;
      }
      function te(t, e, n, i, r, s) {
        var o = "width" === e ? 1 : 0,
          a = 0,
          l = 0;
        if (n === (i ? "border" : "content")) return 0;
        for (; o < 4; o += 2)
          "margin" === n && (l += S.css(t, n + rt[o], !0, r)),
            i
              ? ("content" === n && (l -= S.css(t, "padding" + rt[o], !0, r)),
                "margin" !== n &&
                  (l -= S.css(t, "border" + rt[o] + "Width", !0, r)))
              : ((l += S.css(t, "padding" + rt[o], !0, r)),
                "padding" !== n
                  ? (l += S.css(t, "border" + rt[o] + "Width", !0, r))
                  : (a += S.css(t, "border" + rt[o] + "Width", !0, r)));
        return (
          !i &&
            s >= 0 &&
            (l +=
              Math.max(
                0,
                Math.ceil(
                  t["offset" + e[0].toUpperCase() + e.slice(1)] -
                    s -
                    l -
                    a -
                    0.5
                )
              ) || 0),
          l
        );
      }
      function ee(t, e, n) {
        var i = Ut(t),
          r =
            (!g.boxSizingReliable() || n) &&
            "border-box" === S.css(t, "boxSizing", !1, i),
          s = r,
          o = Wt(t, e, i),
          a = "offset" + e[0].toUpperCase() + e.slice(1);
        if (Bt.test(o)) {
          if (!n) return o;
          o = "auto";
        }
        return (
          ((!g.boxSizingReliable() && r) ||
            (!g.reliableTrDimensions() && L(t, "tr")) ||
            "auto" === o ||
            (!parseFloat(o) && "inline" === S.css(t, "display", !1, i))) &&
            t.getClientRects().length &&
            ((r = "border-box" === S.css(t, "boxSizing", !1, i)),
            (s = a in t) && (o = t[a])),
          (o = parseFloat(o) || 0) +
            te(t, e, n || (r ? "border" : "content"), s, i, o) +
            "px"
        );
      }
      function ne(t, e, n, i, r) {
        return new ne.prototype.init(t, e, n, i, r);
      }
      S.extend({
        cssHooks: {
          opacity: {
            get: function (t, e) {
              if (e) {
                var n = Wt(t, "opacity");
                return "" === n ? "1" : n;
              }
            },
          },
        },
        cssNumber: {
          animationIterationCount: !0,
          columnCount: !0,
          fillOpacity: !0,
          flexGrow: !0,
          flexShrink: !0,
          fontWeight: !0,
          gridArea: !0,
          gridColumn: !0,
          gridColumnEnd: !0,
          gridColumnStart: !0,
          gridRow: !0,
          gridRowEnd: !0,
          gridRowStart: !0,
          lineHeight: !0,
          opacity: !0,
          order: !0,
          orphans: !0,
          widows: !0,
          zIndex: !0,
          zoom: !0,
        },
        cssProps: {},
        style: function (t, e, n, i) {
          if (t && 3 !== t.nodeType && 8 !== t.nodeType && t.style) {
            var r,
              s,
              o,
              a = X(e),
              l = Yt.test(e),
              c = t.style;
            if (
              (l || (e = Xt(a)),
              (o = S.cssHooks[e] || S.cssHooks[a]),
              void 0 === n)
            )
              return o && "get" in o && void 0 !== (r = o.get(t, !1, i))
                ? r
                : c[e];
            "string" === (s = typeof n) &&
              (r = it.exec(n)) &&
              r[1] &&
              ((n = ct(t, e, r)), (s = "number")),
              null != n &&
                n == n &&
                ("number" !== s ||
                  l ||
                  (n += (r && r[3]) || (S.cssNumber[a] ? "" : "px")),
                g.clearCloneStyle ||
                  "" !== n ||
                  0 !== e.indexOf("background") ||
                  (c[e] = "inherit"),
                (o && "set" in o && void 0 === (n = o.set(t, n, i))) ||
                  (l ? c.setProperty(e, n) : (c[e] = n)));
          }
        },
        css: function (t, e, n, i) {
          var r,
            s,
            o,
            a = X(e);
          return (
            Yt.test(e) || (e = Xt(a)),
            (o = S.cssHooks[e] || S.cssHooks[a]) &&
              "get" in o &&
              (r = o.get(t, !0, n)),
            void 0 === r && (r = Wt(t, e, i)),
            "normal" === r && e in Qt && (r = Qt[e]),
            "" === n || n
              ? ((s = parseFloat(r)), !0 === n || isFinite(s) ? s || 0 : r)
              : r
          );
        },
      }),
        S.each(["height", "width"], function (t, e) {
          S.cssHooks[e] = {
            get: function (t, n, i) {
              if (n)
                return !Jt.test(S.css(t, "display")) ||
                  (t.getClientRects().length && t.getBoundingClientRect().width)
                  ? ee(t, e, i)
                  : Ft(t, Zt, function () {
                      return ee(t, e, i);
                    });
            },
            set: function (t, n, i) {
              var r,
                s = Ut(t),
                o = !g.scrollboxSize() && "absolute" === s.position,
                a = (o || i) && "border-box" === S.css(t, "boxSizing", !1, s),
                l = i ? te(t, e, i, a, s) : 0;
              return (
                a &&
                  o &&
                  (l -= Math.ceil(
                    t["offset" + e[0].toUpperCase() + e.slice(1)] -
                      parseFloat(s[e]) -
                      te(t, e, "border", !1, s) -
                      0.5
                  )),
                l &&
                  (r = it.exec(n)) &&
                  "px" !== (r[3] || "px") &&
                  ((t.style[e] = n), (n = S.css(t, e))),
                Kt(0, n, l)
              );
            },
          };
        }),
        (S.cssHooks.marginLeft = Gt(g.reliableMarginLeft, function (t, e) {
          if (e)
            return (
              (parseFloat(Wt(t, "marginLeft")) ||
                t.getBoundingClientRect().left -
                  Ft(t, { marginLeft: 0 }, function () {
                    return t.getBoundingClientRect().left;
                  })) + "px"
            );
        })),
        S.each({ margin: "", padding: "", border: "Width" }, function (t, e) {
          (S.cssHooks[t + e] = {
            expand: function (n) {
              for (
                var i = 0,
                  r = {},
                  s = "string" == typeof n ? n.split(" ") : [n];
                i < 4;
                i++
              )
                r[t + rt[i] + e] = s[i] || s[i - 2] || s[0];
              return r;
            },
          }),
            "margin" !== t && (S.cssHooks[t + e].set = Kt);
        }),
        S.fn.extend({
          css: function (t, e) {
            return G(
              this,
              function (t, e, n) {
                var i,
                  r,
                  s = {},
                  o = 0;
                if (Array.isArray(e)) {
                  for (i = Ut(t), r = e.length; o < r; o++)
                    s[e[o]] = S.css(t, e[o], !1, i);
                  return s;
                }
                return void 0 !== n ? S.style(t, e, n) : S.css(t, e);
              },
              t,
              e,
              arguments.length > 1
            );
          },
        }),
        (S.Tween = ne),
        (ne.prototype = {
          constructor: ne,
          init: function (t, e, n, i, r, s) {
            (this.elem = t),
              (this.prop = n),
              (this.easing = r || S.easing._default),
              (this.options = e),
              (this.start = this.now = this.cur()),
              (this.end = i),
              (this.unit = s || (S.cssNumber[n] ? "" : "px"));
          },
          cur: function () {
            var t = ne.propHooks[this.prop];
            return t && t.get ? t.get(this) : ne.propHooks._default.get(this);
          },
          run: function (t) {
            var e,
              n = ne.propHooks[this.prop];
            return (
              this.options.duration
                ? (this.pos = e =
                    S.easing[this.easing](
                      t,
                      this.options.duration * t,
                      0,
                      1,
                      this.options.duration
                    ))
                : (this.pos = e = t),
              (this.now = (this.end - this.start) * e + this.start),
              this.options.step &&
                this.options.step.call(this.elem, this.now, this),
              n && n.set ? n.set(this) : ne.propHooks._default.set(this),
              this
            );
          },
        }),
        (ne.prototype.init.prototype = ne.prototype),
        (ne.propHooks = {
          _default: {
            get: function (t) {
              var e;
              return 1 !== t.elem.nodeType ||
                (null != t.elem[t.prop] && null == t.elem.style[t.prop])
                ? t.elem[t.prop]
                : (e = S.css(t.elem, t.prop, "")) && "auto" !== e
                ? e
                : 0;
            },
            set: function (t) {
              S.fx.step[t.prop]
                ? S.fx.step[t.prop](t)
                : 1 !== t.elem.nodeType ||
                  (!S.cssHooks[t.prop] && null == t.elem.style[Xt(t.prop)])
                ? (t.elem[t.prop] = t.now)
                : S.style(t.elem, t.prop, t.now + t.unit);
            },
          },
        }),
        (ne.propHooks.scrollTop = ne.propHooks.scrollLeft =
          {
            set: function (t) {
              t.elem.nodeType && t.elem.parentNode && (t.elem[t.prop] = t.now);
            },
          }),
        (S.easing = {
          linear: function (t) {
            return t;
          },
          swing: function (t) {
            return 0.5 - Math.cos(t * Math.PI) / 2;
          },
          _default: "swing",
        }),
        (S.fx = ne.prototype.init),
        (S.fx.step = {});
      var ie,
        re,
        se = /^(?:toggle|show|hide)$/,
        oe = /queueHooks$/;
      function ae() {
        re &&
          (!1 === x.hidden && n.requestAnimationFrame
            ? n.requestAnimationFrame(ae)
            : n.setTimeout(ae, S.fx.interval),
          S.fx.tick());
      }
      function le() {
        return (
          n.setTimeout(function () {
            ie = void 0;
          }),
          (ie = Date.now())
        );
      }
      function ce(t, e) {
        var n,
          i = 0,
          r = { height: t };
        for (e = e ? 1 : 0; i < 4; i += 2 - e)
          r["margin" + (n = rt[i])] = r["padding" + n] = t;
        return e && (r.opacity = r.width = t), r;
      }
      function ue(t, e, n) {
        for (
          var i,
            r = (he.tweeners[e] || []).concat(he.tweeners["*"]),
            s = 0,
            o = r.length;
          s < o;
          s++
        )
          if ((i = r[s].call(n, e, t))) return i;
      }
      function he(t, e, n) {
        var i,
          r,
          s = 0,
          o = he.prefilters.length,
          a = S.Deferred().always(function () {
            delete l.elem;
          }),
          l = function () {
            if (r) return !1;
            for (
              var e = ie || le(),
                n = Math.max(0, c.startTime + c.duration - e),
                i = 1 - (n / c.duration || 0),
                s = 0,
                o = c.tweens.length;
              s < o;
              s++
            )
              c.tweens[s].run(i);
            return (
              a.notifyWith(t, [c, i, n]),
              i < 1 && o
                ? n
                : (o || a.notifyWith(t, [c, 1, 0]), a.resolveWith(t, [c]), !1)
            );
          },
          c = a.promise({
            elem: t,
            props: S.extend({}, e),
            opts: S.extend(
              !0,
              { specialEasing: {}, easing: S.easing._default },
              n
            ),
            originalProperties: e,
            originalOptions: n,
            startTime: ie || le(),
            duration: n.duration,
            tweens: [],
            createTween: function (e, n) {
              var i = S.Tween(
                t,
                c.opts,
                e,
                n,
                c.opts.specialEasing[e] || c.opts.easing
              );
              return c.tweens.push(i), i;
            },
            stop: function (e) {
              var n = 0,
                i = e ? c.tweens.length : 0;
              if (r) return this;
              for (r = !0; n < i; n++) c.tweens[n].run(1);
              return (
                e
                  ? (a.notifyWith(t, [c, 1, 0]), a.resolveWith(t, [c, e]))
                  : a.rejectWith(t, [c, e]),
                this
              );
            },
          }),
          u = c.props;
        for (
          !(function (t, e) {
            var n, i, r, s, o;
            for (n in t)
              if (
                ((r = e[(i = X(n))]),
                (s = t[n]),
                Array.isArray(s) && ((r = s[1]), (s = t[n] = s[0])),
                n !== i && ((t[i] = s), delete t[n]),
                (o = S.cssHooks[i]) && ("expand" in o))
              )
                for (n in ((s = o.expand(s)), delete t[i], s))
                  (n in t) || ((t[n] = s[n]), (e[n] = r));
              else e[i] = r;
          })(u, c.opts.specialEasing);
          s < o;
          s++
        )
          if ((i = he.prefilters[s].call(c, t, u, c.opts)))
            return (
              v(i.stop) &&
                (S._queueHooks(c.elem, c.opts.queue).stop = i.stop.bind(i)),
              i
            );
        return (
          S.map(u, ue, c),
          v(c.opts.start) && c.opts.start.call(t, c),
          c
            .progress(c.opts.progress)
            .done(c.opts.done, c.opts.complete)
            .fail(c.opts.fail)
            .always(c.opts.always),
          S.fx.timer(S.extend(l, { elem: t, anim: c, queue: c.opts.queue })),
          c
        );
      }
      (S.Animation = S.extend(he, {
        tweeners: {
          "*": [
            function (t, e) {
              var n = this.createTween(t, e);
              return ct(n.elem, t, it.exec(e), n), n;
            },
          ],
        },
        tweener: function (t, e) {
          v(t) ? ((e = t), (t = ["*"])) : (t = t.match(z));
          for (var n, i = 0, r = t.length; i < r; i++)
            (n = t[i]),
              (he.tweeners[n] = he.tweeners[n] || []),
              he.tweeners[n].unshift(e);
        },
        prefilters: [
          function (t, e, n) {
            var i,
              r,
              s,
              o,
              a,
              l,
              c,
              u,
              h = "width" in e || "height" in e,
              d = this,
              p = {},
              f = t.style,
              m = t.nodeType && lt(t),
              g = Z.get(t, "fxshow");
            for (i in (n.queue ||
              (null == (o = S._queueHooks(t, "fx")).unqueued &&
                ((o.unqueued = 0),
                (a = o.empty.fire),
                (o.empty.fire = function () {
                  o.unqueued || a();
                })),
              o.unqueued++,
              d.always(function () {
                d.always(function () {
                  o.unqueued--, S.queue(t, "fx").length || o.empty.fire();
                });
              })),
            e))
              if (((r = e[i]), se.test(r))) {
                if (
                  (delete e[i],
                  (s = s || "toggle" === r),
                  r === (m ? "hide" : "show"))
                ) {
                  if ("show" !== r || !g || void 0 === g[i]) continue;
                  m = !0;
                }
                p[i] = (g && g[i]) || S.style(t, i);
              }
            if ((l = !S.isEmptyObject(e)) || !S.isEmptyObject(p))
              for (i in (h &&
                1 === t.nodeType &&
                ((n.overflow = [f.overflow, f.overflowX, f.overflowY]),
                null == (c = g && g.display) && (c = Z.get(t, "display")),
                "none" === (u = S.css(t, "display")) &&
                  (c
                    ? (u = c)
                    : (dt([t], !0),
                      (c = t.style.display || c),
                      (u = S.css(t, "display")),
                      dt([t]))),
                ("inline" === u || ("inline-block" === u && null != c)) &&
                  "none" === S.css(t, "float") &&
                  (l ||
                    (d.done(function () {
                      f.display = c;
                    }),
                    null == c &&
                      ((u = f.display), (c = "none" === u ? "" : u))),
                  (f.display = "inline-block"))),
              n.overflow &&
                ((f.overflow = "hidden"),
                d.always(function () {
                  (f.overflow = n.overflow[0]),
                    (f.overflowX = n.overflow[1]),
                    (f.overflowY = n.overflow[2]);
                })),
              (l = !1),
              p))
                l ||
                  (g
                    ? "hidden" in g && (m = g.hidden)
                    : (g = Z.access(t, "fxshow", { display: c })),
                  s && (g.hidden = !m),
                  m && dt([t], !0),
                  d.done(function () {
                    for (i in (m || dt([t]), Z.remove(t, "fxshow"), p))
                      S.style(t, i, p[i]);
                  })),
                  (l = ue(m ? g[i] : 0, i, d)),
                  i in g ||
                    ((g[i] = l.start), m && ((l.end = l.start), (l.start = 0)));
          },
        ],
        prefilter: function (t, e) {
          e ? he.prefilters.unshift(t) : he.prefilters.push(t);
        },
      })),
        (S.speed = function (t, e, n) {
          var i =
            t && "object" == typeof t
              ? S.extend({}, t)
              : {
                  complete: n || (!n && e) || (v(t) && t),
                  duration: t,
                  easing: (n && e) || (e && !v(e) && e),
                };
          return (
            S.fx.off
              ? (i.duration = 0)
              : "number" != typeof i.duration &&
                (i.duration in S.fx.speeds
                  ? (i.duration = S.fx.speeds[i.duration])
                  : (i.duration = S.fx.speeds._default)),
            (null != i.queue && !0 !== i.queue) || (i.queue = "fx"),
            (i.old = i.complete),
            (i.complete = function () {
              v(i.old) && i.old.call(this), i.queue && S.dequeue(this, i.queue);
            }),
            i
          );
        }),
        S.fn.extend({
          fadeTo: function (t, e, n, i) {
            return this.filter(lt)
              .css("opacity", 0)
              .show()
              .end()
              .animate({ opacity: e }, t, n, i);
          },
          animate: function (t, e, n, i) {
            var r = S.isEmptyObject(t),
              s = S.speed(e, n, i),
              o = function () {
                var e = he(this, S.extend({}, t), s);
                (r || Z.get(this, "finish")) && e.stop(!0);
              };
            return (
              (o.finish = o),
              r || !1 === s.queue ? this.each(o) : this.queue(s.queue, o)
            );
          },
          stop: function (t, e, n) {
            var i = function (t) {
              var e = t.stop;
              delete t.stop, e(n);
            };
            return (
              "string" != typeof t && ((n = e), (e = t), (t = void 0)),
              e && this.queue(t || "fx", []),
              this.each(function () {
                var e = !0,
                  r = null != t && t + "queueHooks",
                  s = S.timers,
                  o = Z.get(this);
                if (r) o[r] && o[r].stop && i(o[r]);
                else for (r in o) o[r] && o[r].stop && oe.test(r) && i(o[r]);
                for (r = s.length; r--; )
                  s[r].elem !== this ||
                    (null != t && s[r].queue !== t) ||
                    (s[r].anim.stop(n), (e = !1), s.splice(r, 1));
                (!e && n) || S.dequeue(this, t);
              })
            );
          },
          finish: function (t) {
            return (
              !1 !== t && (t = t || "fx"),
              this.each(function () {
                var e,
                  n = Z.get(this),
                  i = n[t + "queue"],
                  r = n[t + "queueHooks"],
                  s = S.timers,
                  o = i ? i.length : 0;
                for (
                  n.finish = !0,
                    S.queue(this, t, []),
                    r && r.stop && r.stop.call(this, !0),
                    e = s.length;
                  e--;

                )
                  s[e].elem === this &&
                    s[e].queue === t &&
                    (s[e].anim.stop(!0), s.splice(e, 1));
                for (e = 0; e < o; e++)
                  i[e] && i[e].finish && i[e].finish.call(this);
                delete n.finish;
              })
            );
          },
        }),
        S.each(["toggle", "show", "hide"], function (t, e) {
          var n = S.fn[e];
          S.fn[e] = function (t, i, r) {
            return null == t || "boolean" == typeof t
              ? n.apply(this, arguments)
              : this.animate(ce(e, !0), t, i, r);
          };
        }),
        S.each(
          {
            slideDown: ce("show"),
            slideUp: ce("hide"),
            slideToggle: ce("toggle"),
            fadeIn: { opacity: "show" },
            fadeOut: { opacity: "hide" },
            fadeToggle: { opacity: "toggle" },
          },
          function (t, e) {
            S.fn[t] = function (t, n, i) {
              return this.animate(e, t, n, i);
            };
          }
        ),
        (S.timers = []),
        (S.fx.tick = function () {
          var t,
            e = 0,
            n = S.timers;
          for (ie = Date.now(); e < n.length; e++)
            (t = n[e])() || n[e] !== t || n.splice(e--, 1);
          n.length || S.fx.stop(), (ie = void 0);
        }),
        (S.fx.timer = function (t) {
          S.timers.push(t), S.fx.start();
        }),
        (S.fx.interval = 13),
        (S.fx.start = function () {
          re || ((re = !0), ae());
        }),
        (S.fx.stop = function () {
          re = null;
        }),
        (S.fx.speeds = { slow: 600, fast: 200, _default: 400 }),
        (S.fn.delay = function (t, e) {
          return (
            (t = (S.fx && S.fx.speeds[t]) || t),
            (e = e || "fx"),
            this.queue(e, function (e, i) {
              var r = n.setTimeout(e, t);
              i.stop = function () {
                n.clearTimeout(r);
              };
            })
          );
        }),
        (function () {
          var t = x.createElement("input"),
            e = x
              .createElement("select")
              .appendChild(x.createElement("option"));
          (t.type = "checkbox"),
            (g.checkOn = "" !== t.value),
            (g.optSelected = e.selected),
            ((t = x.createElement("input")).value = "t"),
            (t.type = "radio"),
            (g.radioValue = "t" === t.value);
        })();
      var de,
        pe = S.expr.attrHandle;
      S.fn.extend({
        attr: function (t, e) {
          return G(this, S.attr, t, e, arguments.length > 1);
        },
        removeAttr: function (t) {
          return this.each(function () {
            S.removeAttr(this, t);
          });
        },
      }),
        S.extend({
          attr: function (t, e, n) {
            var i,
              r,
              s = t.nodeType;
            if (3 !== s && 8 !== s && 2 !== s)
              return void 0 === t.getAttribute
                ? S.prop(t, e, n)
                : ((1 === s && S.isXMLDoc(t)) ||
                    (r =
                      S.attrHooks[e.toLowerCase()] ||
                      (S.expr.match.bool.test(e) ? de : void 0)),
                  void 0 !== n
                    ? null === n
                      ? void S.removeAttr(t, e)
                      : r && "set" in r && void 0 !== (i = r.set(t, n, e))
                      ? i
                      : (t.setAttribute(e, n + ""), n)
                    : r && "get" in r && null !== (i = r.get(t, e))
                    ? i
                    : null == (i = S.find.attr(t, e))
                    ? void 0
                    : i);
          },
          attrHooks: {
            type: {
              set: function (t, e) {
                if (!g.radioValue && "radio" === e && L(t, "input")) {
                  var n = t.value;
                  return t.setAttribute("type", e), n && (t.value = n), e;
                }
              },
            },
          },
          removeAttr: function (t, e) {
            var n,
              i = 0,
              r = e && e.match(z);
            if (r && 1 === t.nodeType)
              for (; (n = r[i++]); ) t.removeAttribute(n);
          },
        }),
        (de = {
          set: function (t, e, n) {
            return !1 === e ? S.removeAttr(t, n) : t.setAttribute(n, n), n;
          },
        }),
        S.each(S.expr.match.bool.source.match(/\w+/g), function (t, e) {
          var n = pe[e] || S.find.attr;
          pe[e] = function (t, e, i) {
            var r,
              s,
              o = e.toLowerCase();
            return (
              i ||
                ((s = pe[o]),
                (pe[o] = r),
                (r = null != n(t, e, i) ? o : null),
                (pe[o] = s)),
              r
            );
          };
        });
      var fe = /^(?:input|select|textarea|button)$/i,
        me = /^(?:a|area)$/i;
      function ge(t) {
        return (t.match(z) || []).join(" ");
      }
      function ve(t) {
        return (t.getAttribute && t.getAttribute("class")) || "";
      }
      function ye(t) {
        return Array.isArray(t)
          ? t
          : ("string" == typeof t && t.match(z)) || [];
      }
      S.fn.extend({
        prop: function (t, e) {
          return G(this, S.prop, t, e, arguments.length > 1);
        },
        removeProp: function (t) {
          return this.each(function () {
            delete this[S.propFix[t] || t];
          });
        },
      }),
        S.extend({
          prop: function (t, e, n) {
            var i,
              r,
              s = t.nodeType;
            if (3 !== s && 8 !== s && 2 !== s)
              return (
                (1 === s && S.isXMLDoc(t)) ||
                  ((e = S.propFix[e] || e), (r = S.propHooks[e])),
                void 0 !== n
                  ? r && "set" in r && void 0 !== (i = r.set(t, n, e))
                    ? i
                    : (t[e] = n)
                  : r && "get" in r && null !== (i = r.get(t, e))
                  ? i
                  : t[e]
              );
          },
          propHooks: {
            tabIndex: {
              get: function (t) {
                var e = S.find.attr(t, "tabindex");
                return e
                  ? parseInt(e, 10)
                  : fe.test(t.nodeName) || (me.test(t.nodeName) && t.href)
                  ? 0
                  : -1;
              },
            },
          },
          propFix: { for: "htmlFor", class: "className" },
        }),
        g.optSelected ||
          (S.propHooks.selected = {
            get: function (t) {
              var e = t.parentNode;
              return e && e.parentNode && e.parentNode.selectedIndex, null;
            },
            set: function (t) {
              var e = t.parentNode;
              e &&
                (e.selectedIndex, e.parentNode && e.parentNode.selectedIndex);
            },
          }),
        S.each(
          [
            "tabIndex",
            "readOnly",
            "maxLength",
            "cellSpacing",
            "cellPadding",
            "rowSpan",
            "colSpan",
            "useMap",
            "frameBorder",
            "contentEditable",
          ],
          function () {
            S.propFix[this.toLowerCase()] = this;
          }
        ),
        S.fn.extend({
          addClass: function (t) {
            var e,
              n,
              i,
              r,
              s,
              o,
              a,
              l = 0;
            if (v(t))
              return this.each(function (e) {
                S(this).addClass(t.call(this, e, ve(this)));
              });
            if ((e = ye(t)).length)
              for (; (n = this[l++]); )
                if (
                  ((r = ve(n)), (i = 1 === n.nodeType && " " + ge(r) + " "))
                ) {
                  for (o = 0; (s = e[o++]); )
                    i.indexOf(" " + s + " ") < 0 && (i += s + " ");
                  r !== (a = ge(i)) && n.setAttribute("class", a);
                }
            return this;
          },
          removeClass: function (t) {
            var e,
              n,
              i,
              r,
              s,
              o,
              a,
              l = 0;
            if (v(t))
              return this.each(function (e) {
                S(this).removeClass(t.call(this, e, ve(this)));
              });
            if (!arguments.length) return this.attr("class", "");
            if ((e = ye(t)).length)
              for (; (n = this[l++]); )
                if (
                  ((r = ve(n)), (i = 1 === n.nodeType && " " + ge(r) + " "))
                ) {
                  for (o = 0; (s = e[o++]); )
                    for (; i.indexOf(" " + s + " ") > -1; )
                      i = i.replace(" " + s + " ", " ");
                  r !== (a = ge(i)) && n.setAttribute("class", a);
                }
            return this;
          },
          toggleClass: function (t, e) {
            var n = typeof t,
              i = "string" === n || Array.isArray(t);
            return "boolean" == typeof e && i
              ? e
                ? this.addClass(t)
                : this.removeClass(t)
              : v(t)
              ? this.each(function (n) {
                  S(this).toggleClass(t.call(this, n, ve(this), e), e);
                })
              : this.each(function () {
                  var e, r, s, o;
                  if (i)
                    for (r = 0, s = S(this), o = ye(t); (e = o[r++]); )
                      s.hasClass(e) ? s.removeClass(e) : s.addClass(e);
                  else
                    (void 0 !== t && "boolean" !== n) ||
                      ((e = ve(this)) && Z.set(this, "__className__", e),
                      this.setAttribute &&
                        this.setAttribute(
                          "class",
                          e || !1 === t
                            ? ""
                            : Z.get(this, "__className__") || ""
                        ));
                });
          },
          hasClass: function (t) {
            var e,
              n,
              i = 0;
            for (e = " " + t + " "; (n = this[i++]); )
              if (1 === n.nodeType && (" " + ge(ve(n)) + " ").indexOf(e) > -1)
                return !0;
            return !1;
          },
        });
      var xe = /\r/g;
      S.fn.extend({
        val: function (t) {
          var e,
            n,
            i,
            r = this[0];
          return arguments.length
            ? ((i = v(t)),
              this.each(function (n) {
                var r;
                1 === this.nodeType &&
                  (null == (r = i ? t.call(this, n, S(this).val()) : t)
                    ? (r = "")
                    : "number" == typeof r
                    ? (r += "")
                    : Array.isArray(r) &&
                      (r = S.map(r, function (t) {
                        return null == t ? "" : t + "";
                      })),
                  ((e =
                    S.valHooks[this.type] ||
                    S.valHooks[this.nodeName.toLowerCase()]) &&
                    "set" in e &&
                    void 0 !== e.set(this, r, "value")) ||
                    (this.value = r));
              }))
            : r
            ? (e =
                S.valHooks[r.type] || S.valHooks[r.nodeName.toLowerCase()]) &&
              "get" in e &&
              void 0 !== (n = e.get(r, "value"))
              ? n
              : "string" == typeof (n = r.value)
              ? n.replace(xe, "")
              : null == n
              ? ""
              : n
            : void 0;
        },
      }),
        S.extend({
          valHooks: {
            option: {
              get: function (t) {
                var e = S.find.attr(t, "value");
                return null != e ? e : ge(S.text(t));
              },
            },
            select: {
              get: function (t) {
                var e,
                  n,
                  i,
                  r = t.options,
                  s = t.selectedIndex,
                  o = "select-one" === t.type,
                  a = o ? null : [],
                  l = o ? s + 1 : r.length;
                for (i = s < 0 ? l : o ? s : 0; i < l; i++)
                  if (
                    ((n = r[i]).selected || i === s) &&
                    !n.disabled &&
                    (!n.parentNode.disabled || !L(n.parentNode, "optgroup"))
                  ) {
                    if (((e = S(n).val()), o)) return e;
                    a.push(e);
                  }
                return a;
              },
              set: function (t, e) {
                for (
                  var n, i, r = t.options, s = S.makeArray(e), o = r.length;
                  o--;

                )
                  ((i = r[o]).selected =
                    S.inArray(S.valHooks.option.get(i), s) > -1) && (n = !0);
                return n || (t.selectedIndex = -1), s;
              },
            },
          },
        }),
        S.each(["radio", "checkbox"], function () {
          (S.valHooks[this] = {
            set: function (t, e) {
              if (Array.isArray(e))
                return (t.checked = S.inArray(S(t).val(), e) > -1);
            },
          }),
            g.checkOn ||
              (S.valHooks[this].get = function (t) {
                return null === t.getAttribute("value") ? "on" : t.value;
              });
        }),
        (g.focusin = "onfocusin" in n);
      var be = /^(?:focusinfocus|focusoutblur)$/,
        _e = function (t) {
          t.stopPropagation();
        };
      S.extend(S.event, {
        trigger: function (t, e, i, r) {
          var s,
            o,
            a,
            l,
            c,
            u,
            h,
            d,
            f = [i || x],
            m = p.call(t, "type") ? t.type : t,
            g = p.call(t, "namespace") ? t.namespace.split(".") : [];
          if (
            ((o = d = a = i = i || x),
            3 !== i.nodeType &&
              8 !== i.nodeType &&
              !be.test(m + S.event.triggered) &&
              (m.indexOf(".") > -1 &&
                ((g = m.split(".")), (m = g.shift()), g.sort()),
              (c = m.indexOf(":") < 0 && "on" + m),
              ((t = t[S.expando]
                ? t
                : new S.Event(m, "object" == typeof t && t)).isTrigger = r
                ? 2
                : 3),
              (t.namespace = g.join(".")),
              (t.rnamespace = t.namespace
                ? new RegExp("(^|\\.)" + g.join("\\.(?:.*\\.|)") + "(\\.|$)")
                : null),
              (t.result = void 0),
              t.target || (t.target = i),
              (e = null == e ? [t] : S.makeArray(e, [t])),
              (h = S.event.special[m] || {}),
              r || !h.trigger || !1 !== h.trigger.apply(i, e)))
          ) {
            if (!r && !h.noBubble && !y(i)) {
              for (
                l = h.delegateType || m, be.test(l + m) || (o = o.parentNode);
                o;
                o = o.parentNode
              )
                f.push(o), (a = o);
              a === (i.ownerDocument || x) &&
                f.push(a.defaultView || a.parentWindow || n);
            }
            for (s = 0; (o = f[s++]) && !t.isPropagationStopped(); )
              (d = o),
                (t.type = s > 1 ? l : h.bindType || m),
                (u =
                  (Z.get(o, "events") || Object.create(null))[t.type] &&
                  Z.get(o, "handle")) && u.apply(o, e),
                (u = c && o[c]) &&
                  u.apply &&
                  J(o) &&
                  ((t.result = u.apply(o, e)),
                  !1 === t.result && t.preventDefault());
            return (
              (t.type = m),
              r ||
                t.isDefaultPrevented() ||
                (h._default && !1 !== h._default.apply(f.pop(), e)) ||
                !J(i) ||
                (c &&
                  v(i[m]) &&
                  !y(i) &&
                  ((a = i[c]) && (i[c] = null),
                  (S.event.triggered = m),
                  t.isPropagationStopped() && d.addEventListener(m, _e),
                  i[m](),
                  t.isPropagationStopped() && d.removeEventListener(m, _e),
                  (S.event.triggered = void 0),
                  a && (i[c] = a))),
              t.result
            );
          }
        },
        simulate: function (t, e, n) {
          var i = S.extend(new S.Event(), n, { type: t, isSimulated: !0 });
          S.event.trigger(i, null, e);
        },
      }),
        S.fn.extend({
          trigger: function (t, e) {
            return this.each(function () {
              S.event.trigger(t, e, this);
            });
          },
          triggerHandler: function (t, e) {
            var n = this[0];
            if (n) return S.event.trigger(t, e, n, !0);
          },
        }),
        g.focusin ||
          S.each({ focus: "focusin", blur: "focusout" }, function (t, e) {
            var n = function (t) {
              S.event.simulate(e, t.target, S.event.fix(t));
            };
            S.event.special[e] = {
              setup: function () {
                var i = this.ownerDocument || this.document || this,
                  r = Z.access(i, e);
                r || i.addEventListener(t, n, !0), Z.access(i, e, (r || 0) + 1);
              },
              teardown: function () {
                var i = this.ownerDocument || this.document || this,
                  r = Z.access(i, e) - 1;
                r
                  ? Z.access(i, e, r)
                  : (i.removeEventListener(t, n, !0), Z.remove(i, e));
              },
            };
          });
      var we = n.location,
        Se = { guid: Date.now() },
        Me = /\?/;
      S.parseXML = function (t) {
        var e, i;
        if (!t || "string" != typeof t) return null;
        try {
          e = new n.DOMParser().parseFromString(t, "text/xml");
        } catch (t) {}
        return (
          (i = e && e.getElementsByTagName("parsererror")[0]),
          (e && !i) ||
            S.error(
              "Invalid XML: " +
                (i
                  ? S.map(i.childNodes, function (t) {
                      return t.textContent;
                    }).join("\n")
                  : t)
            ),
          e
        );
      };
      var Te = /\[\]$/,
        Ee = /\r?\n/g,
        Ae = /^(?:submit|button|image|reset|file)$/i,
        Ce = /^(?:input|select|textarea|keygen)/i;
      function Le(t, e, n, i) {
        var r;
        if (Array.isArray(e))
          S.each(e, function (e, r) {
            n || Te.test(t)
              ? i(t, r)
              : Le(
                  t + "[" + ("object" == typeof r && null != r ? e : "") + "]",
                  r,
                  n,
                  i
                );
          });
        else if (n || "object" !== w(e)) i(t, e);
        else for (r in e) Le(t + "[" + r + "]", e[r], n, i);
      }
      (S.param = function (t, e) {
        var n,
          i = [],
          r = function (t, e) {
            var n = v(e) ? e() : e;
            i[i.length] =
              encodeURIComponent(t) +
              "=" +
              encodeURIComponent(null == n ? "" : n);
          };
        if (null == t) return "";
        if (Array.isArray(t) || (t.jquery && !S.isPlainObject(t)))
          S.each(t, function () {
            r(this.name, this.value);
          });
        else for (n in t) Le(n, t[n], e, r);
        return i.join("&");
      }),
        S.fn.extend({
          serialize: function () {
            return S.param(this.serializeArray());
          },
          serializeArray: function () {
            return this.map(function () {
              var t = S.prop(this, "elements");
              return t ? S.makeArray(t) : this;
            })
              .filter(function () {
                var t = this.type;
                return (
                  this.name &&
                  !S(this).is(":disabled") &&
                  Ce.test(this.nodeName) &&
                  !Ae.test(t) &&
                  (this.checked || !mt.test(t))
                );
              })
              .map(function (t, e) {
                var n = S(this).val();
                return null == n
                  ? null
                  : Array.isArray(n)
                  ? S.map(n, function (t) {
                      return { name: e.name, value: t.replace(Ee, "\r\n") };
                    })
                  : { name: e.name, value: n.replace(Ee, "\r\n") };
              })
              .get();
          },
        });
      var Re = /%20/g,
        Pe = /#.*$/,
        De = /([?&])_=[^&]*/,
        ke = /^(.*?):[ \t]*([^\r\n]*)$/gm,
        Ie = /^(?:GET|HEAD)$/,
        Ne = /^\/\//,
        Oe = {},
        ze = {},
        He = "*/".concat("*"),
        Be = x.createElement("a");
      function Ue(t) {
        return function (e, n) {
          "string" != typeof e && ((n = e), (e = "*"));
          var i,
            r = 0,
            s = e.toLowerCase().match(z) || [];
          if (v(n))
            for (; (i = s[r++]); )
              "+" === i[0]
                ? ((i = i.slice(1) || "*"), (t[i] = t[i] || []).unshift(n))
                : (t[i] = t[i] || []).push(n);
        };
      }
      function Fe(t, e, n, i) {
        var r = {},
          s = t === ze;
        function o(a) {
          var l;
          return (
            (r[a] = !0),
            S.each(t[a] || [], function (t, a) {
              var c = a(e, n, i);
              return "string" != typeof c || s || r[c]
                ? s
                  ? !(l = c)
                  : void 0
                : (e.dataTypes.unshift(c), o(c), !1);
            }),
            l
          );
        }
        return o(e.dataTypes[0]) || (!r["*"] && o("*"));
      }
      function Ve(t, e) {
        var n,
          i,
          r = S.ajaxSettings.flatOptions || {};
        for (n in e) void 0 !== e[n] && ((r[n] ? t : i || (i = {}))[n] = e[n]);
        return i && S.extend(!0, t, i), t;
      }
      (Be.href = we.href),
        S.extend({
          active: 0,
          lastModified: {},
          etag: {},
          ajaxSettings: {
            url: we.href,
            type: "GET",
            isLocal:
              /^(?:about|app|app-storage|.+-extension|file|res|widget):$/.test(
                we.protocol
              ),
            global: !0,
            processData: !0,
            async: !0,
            contentType: "application/x-www-form-urlencoded; charset=UTF-8",
            accepts: {
              "*": He,
              text: "text/plain",
              html: "text/html",
              xml: "application/xml, text/xml",
              json: "application/json, text/javascript",
            },
            contents: { xml: /\bxml\b/, html: /\bhtml/, json: /\bjson\b/ },
            responseFields: {
              xml: "responseXML",
              text: "responseText",
              json: "responseJSON",
            },
            converters: {
              "* text": String,
              "text html": !0,
              "text json": JSON.parse,
              "text xml": S.parseXML,
            },
            flatOptions: { url: !0, context: !0 },
          },
          ajaxSetup: function (t, e) {
            return e ? Ve(Ve(t, S.ajaxSettings), e) : Ve(S.ajaxSettings, t);
          },
          ajaxPrefilter: Ue(Oe),
          ajaxTransport: Ue(ze),
          ajax: function (t, e) {
            "object" == typeof t && ((e = t), (t = void 0)), (e = e || {});
            var i,
              r,
              s,
              o,
              a,
              l,
              c,
              u,
              h,
              d,
              p = S.ajaxSetup({}, e),
              f = p.context || p,
              m = p.context && (f.nodeType || f.jquery) ? S(f) : S.event,
              g = S.Deferred(),
              v = S.Callbacks("once memory"),
              y = p.statusCode || {},
              b = {},
              _ = {},
              w = "canceled",
              M = {
                readyState: 0,
                getResponseHeader: function (t) {
                  var e;
                  if (c) {
                    if (!o)
                      for (o = {}; (e = ke.exec(s)); )
                        o[e[1].toLowerCase() + " "] = (
                          o[e[1].toLowerCase() + " "] || []
                        ).concat(e[2]);
                    e = o[t.toLowerCase() + " "];
                  }
                  return null == e ? null : e.join(", ");
                },
                getAllResponseHeaders: function () {
                  return c ? s : null;
                },
                setRequestHeader: function (t, e) {
                  return (
                    null == c &&
                      ((t = _[t.toLowerCase()] = _[t.toLowerCase()] || t),
                      (b[t] = e)),
                    this
                  );
                },
                overrideMimeType: function (t) {
                  return null == c && (p.mimeType = t), this;
                },
                statusCode: function (t) {
                  var e;
                  if (t)
                    if (c) M.always(t[M.status]);
                    else for (e in t) y[e] = [y[e], t[e]];
                  return this;
                },
                abort: function (t) {
                  var e = t || w;
                  return i && i.abort(e), T(0, e), this;
                },
              };
            if (
              (g.promise(M),
              (p.url = ((t || p.url || we.href) + "").replace(
                Ne,
                we.protocol + "//"
              )),
              (p.type = e.method || e.type || p.method || p.type),
              (p.dataTypes = (p.dataType || "*").toLowerCase().match(z) || [
                "",
              ]),
              null == p.crossDomain)
            ) {
              l = x.createElement("a");
              try {
                (l.href = p.url),
                  (l.href = l.href),
                  (p.crossDomain =
                    Be.protocol + "//" + Be.host != l.protocol + "//" + l.host);
              } catch (t) {
                p.crossDomain = !0;
              }
            }
            if (
              (p.data &&
                p.processData &&
                "string" != typeof p.data &&
                (p.data = S.param(p.data, p.traditional)),
              Fe(Oe, p, e, M),
              c)
            )
              return M;
            for (h in ((u = S.event && p.global) &&
              0 == S.active++ &&
              S.event.trigger("ajaxStart"),
            (p.type = p.type.toUpperCase()),
            (p.hasContent = !Ie.test(p.type)),
            (r = p.url.replace(Pe, "")),
            p.hasContent
              ? p.data &&
                p.processData &&
                0 ===
                  (p.contentType || "").indexOf(
                    "application/x-www-form-urlencoded"
                  ) &&
                (p.data = p.data.replace(Re, "+"))
              : ((d = p.url.slice(r.length)),
                p.data &&
                  (p.processData || "string" == typeof p.data) &&
                  ((r += (Me.test(r) ? "&" : "?") + p.data), delete p.data),
                !1 === p.cache &&
                  ((r = r.replace(De, "$1")),
                  (d = (Me.test(r) ? "&" : "?") + "_=" + Se.guid++ + d)),
                (p.url = r + d)),
            p.ifModified &&
              (S.lastModified[r] &&
                M.setRequestHeader("If-Modified-Since", S.lastModified[r]),
              S.etag[r] && M.setRequestHeader("If-None-Match", S.etag[r])),
            ((p.data && p.hasContent && !1 !== p.contentType) ||
              e.contentType) &&
              M.setRequestHeader("Content-Type", p.contentType),
            M.setRequestHeader(
              "Accept",
              p.dataTypes[0] && p.accepts[p.dataTypes[0]]
                ? p.accepts[p.dataTypes[0]] +
                    ("*" !== p.dataTypes[0] ? ", " + He + "; q=0.01" : "")
                : p.accepts["*"]
            ),
            p.headers))
              M.setRequestHeader(h, p.headers[h]);
            if (p.beforeSend && (!1 === p.beforeSend.call(f, M, p) || c))
              return M.abort();
            if (
              ((w = "abort"),
              v.add(p.complete),
              M.done(p.success),
              M.fail(p.error),
              (i = Fe(ze, p, e, M)))
            ) {
              if (((M.readyState = 1), u && m.trigger("ajaxSend", [M, p]), c))
                return M;
              p.async &&
                p.timeout > 0 &&
                (a = n.setTimeout(function () {
                  M.abort("timeout");
                }, p.timeout));
              try {
                (c = !1), i.send(b, T);
              } catch (t) {
                if (c) throw t;
                T(-1, t);
              }
            } else T(-1, "No Transport");
            function T(t, e, o, l) {
              var h,
                d,
                x,
                b,
                _,
                w = e;
              c ||
                ((c = !0),
                a && n.clearTimeout(a),
                (i = void 0),
                (s = l || ""),
                (M.readyState = t > 0 ? 4 : 0),
                (h = (t >= 200 && t < 300) || 304 === t),
                o &&
                  (b = (function (t, e, n) {
                    for (
                      var i, r, s, o, a = t.contents, l = t.dataTypes;
                      "*" === l[0];

                    )
                      l.shift(),
                        void 0 === i &&
                          (i =
                            t.mimeType || e.getResponseHeader("Content-Type"));
                    if (i)
                      for (r in a)
                        if (a[r] && a[r].test(i)) {
                          l.unshift(r);
                          break;
                        }
                    if (l[0] in n) s = l[0];
                    else {
                      for (r in n) {
                        if (!l[0] || t.converters[r + " " + l[0]]) {
                          s = r;
                          break;
                        }
                        o || (o = r);
                      }
                      s = s || o;
                    }
                    if (s) return s !== l[0] && l.unshift(s), n[s];
                  })(p, M, o)),
                !h &&
                  S.inArray("script", p.dataTypes) > -1 &&
                  S.inArray("json", p.dataTypes) < 0 &&
                  (p.converters["text script"] = function () {}),
                (b = (function (t, e, n, i) {
                  var r,
                    s,
                    o,
                    a,
                    l,
                    c = {},
                    u = t.dataTypes.slice();
                  if (u[1])
                    for (o in t.converters)
                      c[o.toLowerCase()] = t.converters[o];
                  for (s = u.shift(); s; )
                    if (
                      (t.responseFields[s] && (n[t.responseFields[s]] = e),
                      !l &&
                        i &&
                        t.dataFilter &&
                        (e = t.dataFilter(e, t.dataType)),
                      (l = s),
                      (s = u.shift()))
                    )
                      if ("*" === s) s = l;
                      else if ("*" !== l && l !== s) {
                        if (!(o = c[l + " " + s] || c["* " + s]))
                          for (r in c)
                            if (
                              (a = r.split(" "))[1] === s &&
                              (o = c[l + " " + a[0]] || c["* " + a[0]])
                            ) {
                              !0 === o
                                ? (o = c[r])
                                : !0 !== c[r] && ((s = a[0]), u.unshift(a[1]));
                              break;
                            }
                        if (!0 !== o)
                          if (o && t.throws) e = o(e);
                          else
                            try {
                              e = o(e);
                            } catch (t) {
                              return {
                                state: "parsererror",
                                error: o
                                  ? t
                                  : "No conversion from " + l + " to " + s,
                              };
                            }
                      }
                  return { state: "success", data: e };
                })(p, b, M, h)),
                h
                  ? (p.ifModified &&
                      ((_ = M.getResponseHeader("Last-Modified")) &&
                        (S.lastModified[r] = _),
                      (_ = M.getResponseHeader("etag")) && (S.etag[r] = _)),
                    204 === t || "HEAD" === p.type
                      ? (w = "nocontent")
                      : 304 === t
                      ? (w = "notmodified")
                      : ((w = b.state), (d = b.data), (h = !(x = b.error))))
                  : ((x = w), (!t && w) || ((w = "error"), t < 0 && (t = 0))),
                (M.status = t),
                (M.statusText = (e || w) + ""),
                h ? g.resolveWith(f, [d, w, M]) : g.rejectWith(f, [M, w, x]),
                M.statusCode(y),
                (y = void 0),
                u &&
                  m.trigger(h ? "ajaxSuccess" : "ajaxError", [M, p, h ? d : x]),
                v.fireWith(f, [M, w]),
                u &&
                  (m.trigger("ajaxComplete", [M, p]),
                  --S.active || S.event.trigger("ajaxStop")));
            }
            return M;
          },
          getJSON: function (t, e, n) {
            return S.get(t, e, n, "json");
          },
          getScript: function (t, e) {
            return S.get(t, void 0, e, "script");
          },
        }),
        S.each(["get", "post"], function (t, e) {
          S[e] = function (t, n, i, r) {
            return (
              v(n) && ((r = r || i), (i = n), (n = void 0)),
              S.ajax(
                S.extend(
                  { url: t, type: e, dataType: r, data: n, success: i },
                  S.isPlainObject(t) && t
                )
              )
            );
          };
        }),
        S.ajaxPrefilter(function (t) {
          var e;
          for (e in t.headers)
            "content-type" === e.toLowerCase() &&
              (t.contentType = t.headers[e] || "");
        }),
        (S._evalUrl = function (t, e, n) {
          return S.ajax({
            url: t,
            type: "GET",
            dataType: "script",
            cache: !0,
            async: !1,
            global: !1,
            converters: { "text script": function () {} },
            dataFilter: function (t) {
              S.globalEval(t, e, n);
            },
          });
        }),
        S.fn.extend({
          wrapAll: function (t) {
            var e;
            return (
              this[0] &&
                (v(t) && (t = t.call(this[0])),
                (e = S(t, this[0].ownerDocument).eq(0).clone(!0)),
                this[0].parentNode && e.insertBefore(this[0]),
                e
                  .map(function () {
                    for (var t = this; t.firstElementChild; )
                      t = t.firstElementChild;
                    return t;
                  })
                  .append(this)),
              this
            );
          },
          wrapInner: function (t) {
            return v(t)
              ? this.each(function (e) {
                  S(this).wrapInner(t.call(this, e));
                })
              : this.each(function () {
                  var e = S(this),
                    n = e.contents();
                  n.length ? n.wrapAll(t) : e.append(t);
                });
          },
          wrap: function (t) {
            var e = v(t);
            return this.each(function (n) {
              S(this).wrapAll(e ? t.call(this, n) : t);
            });
          },
          unwrap: function (t) {
            return (
              this.parent(t)
                .not("body")
                .each(function () {
                  S(this).replaceWith(this.childNodes);
                }),
              this
            );
          },
        }),
        (S.expr.pseudos.hidden = function (t) {
          return !S.expr.pseudos.visible(t);
        }),
        (S.expr.pseudos.visible = function (t) {
          return !!(
            t.offsetWidth ||
            t.offsetHeight ||
            t.getClientRects().length
          );
        }),
        (S.ajaxSettings.xhr = function () {
          try {
            return new n.XMLHttpRequest();
          } catch (t) {}
        });
      var We = { 0: 200, 1223: 204 },
        Ge = S.ajaxSettings.xhr();
      (g.cors = !!Ge && "withCredentials" in Ge),
        (g.ajax = Ge = !!Ge),
        S.ajaxTransport(function (t) {
          var e, i;
          if (g.cors || (Ge && !t.crossDomain))
            return {
              send: function (r, s) {
                var o,
                  a = t.xhr();
                if (
                  (a.open(t.type, t.url, t.async, t.username, t.password),
                  t.xhrFields)
                )
                  for (o in t.xhrFields) a[o] = t.xhrFields[o];
                for (o in (t.mimeType &&
                  a.overrideMimeType &&
                  a.overrideMimeType(t.mimeType),
                t.crossDomain ||
                  r["X-Requested-With"] ||
                  (r["X-Requested-With"] = "XMLHttpRequest"),
                r))
                  a.setRequestHeader(o, r[o]);
                (e = function (t) {
                  return function () {
                    e &&
                      ((e =
                        i =
                        a.onload =
                        a.onerror =
                        a.onabort =
                        a.ontimeout =
                        a.onreadystatechange =
                          null),
                      "abort" === t
                        ? a.abort()
                        : "error" === t
                        ? "number" != typeof a.status
                          ? s(0, "error")
                          : s(a.status, a.statusText)
                        : s(
                            We[a.status] || a.status,
                            a.statusText,
                            "text" !== (a.responseType || "text") ||
                              "string" != typeof a.responseText
                              ? { binary: a.response }
                              : { text: a.responseText },
                            a.getAllResponseHeaders()
                          ));
                  };
                }),
                  (a.onload = e()),
                  (i = a.onerror = a.ontimeout = e("error")),
                  void 0 !== a.onabort
                    ? (a.onabort = i)
                    : (a.onreadystatechange = function () {
                        4 === a.readyState &&
                          n.setTimeout(function () {
                            e && i();
                          });
                      }),
                  (e = e("abort"));
                try {
                  a.send((t.hasContent && t.data) || null);
                } catch (t) {
                  if (e) throw t;
                }
              },
              abort: function () {
                e && e();
              },
            };
        }),
        S.ajaxPrefilter(function (t) {
          t.crossDomain && (t.contents.script = !1);
        }),
        S.ajaxSetup({
          accepts: {
            script:
              "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript",
          },
          contents: { script: /\b(?:java|ecma)script\b/ },
          converters: {
            "text script": function (t) {
              return S.globalEval(t), t;
            },
          },
        }),
        S.ajaxPrefilter("script", function (t) {
          void 0 === t.cache && (t.cache = !1),
            t.crossDomain && (t.type = "GET");
        }),
        S.ajaxTransport("script", function (t) {
          var e, n;
          if (t.crossDomain || t.scriptAttrs)
            return {
              send: function (i, r) {
                (e = S("<script>")
                  .attr(t.scriptAttrs || {})
                  .prop({ charset: t.scriptCharset, src: t.url })
                  .on(
                    "load error",
                    (n = function (t) {
                      e.remove(),
                        (n = null),
                        t && r("error" === t.type ? 404 : 200, t.type);
                    })
                  )),
                  x.head.appendChild(e[0]);
              },
              abort: function () {
                n && n();
              },
            };
        });
      var je,
        qe = [],
        $e = /(=)\?(?=&|$)|\?\?/;
      S.ajaxSetup({
        jsonp: "callback",
        jsonpCallback: function () {
          var t = qe.pop() || S.expando + "_" + Se.guid++;
          return (this[t] = !0), t;
        },
      }),
        S.ajaxPrefilter("json jsonp", function (t, e, i) {
          var r,
            s,
            o,
            a =
              !1 !== t.jsonp &&
              ($e.test(t.url)
                ? "url"
                : "string" == typeof t.data &&
                  0 ===
                    (t.contentType || "").indexOf(
                      "application/x-www-form-urlencoded"
                    ) &&
                  $e.test(t.data) &&
                  "data");
          if (a || "jsonp" === t.dataTypes[0])
            return (
              (r = t.jsonpCallback =
                v(t.jsonpCallback) ? t.jsonpCallback() : t.jsonpCallback),
              a
                ? (t[a] = t[a].replace($e, "$1" + r))
                : !1 !== t.jsonp &&
                  (t.url += (Me.test(t.url) ? "&" : "?") + t.jsonp + "=" + r),
              (t.converters["script json"] = function () {
                return o || S.error(r + " was not called"), o[0];
              }),
              (t.dataTypes[0] = "json"),
              (s = n[r]),
              (n[r] = function () {
                o = arguments;
              }),
              i.always(function () {
                void 0 === s ? S(n).removeProp(r) : (n[r] = s),
                  t[r] && ((t.jsonpCallback = e.jsonpCallback), qe.push(r)),
                  o && v(s) && s(o[0]),
                  (o = s = void 0);
              }),
              "script"
            );
        }),
        (g.createHTMLDocument =
          (((je = x.implementation.createHTMLDocument("").body).innerHTML =
            "<form></form><form></form>"),
          2 === je.childNodes.length)),
        (S.parseHTML = function (t, e, n) {
          return "string" != typeof t
            ? []
            : ("boolean" == typeof e && ((n = e), (e = !1)),
              e ||
                (g.createHTMLDocument
                  ? (((i = (e =
                      x.implementation.createHTMLDocument("")).createElement(
                      "base"
                    )).href = x.location.href),
                    e.head.appendChild(i))
                  : (e = x)),
              (s = !n && []),
              (r = R.exec(t))
                ? [e.createElement(r[1])]
                : ((r = wt([t], e, s)),
                  s && s.length && S(s).remove(),
                  S.merge([], r.childNodes)));
          var i, r, s;
        }),
        (S.fn.load = function (t, e, n) {
          var i,
            r,
            s,
            o = this,
            a = t.indexOf(" ");
          return (
            a > -1 && ((i = ge(t.slice(a))), (t = t.slice(0, a))),
            v(e)
              ? ((n = e), (e = void 0))
              : e && "object" == typeof e && (r = "POST"),
            o.length > 0 &&
              S.ajax({ url: t, type: r || "GET", dataType: "html", data: e })
                .done(function (t) {
                  (s = arguments),
                    o.html(i ? S("<div>").append(S.parseHTML(t)).find(i) : t);
                })
                .always(
                  n &&
                    function (t, e) {
                      o.each(function () {
                        n.apply(this, s || [t.responseText, e, t]);
                      });
                    }
                ),
            this
          );
        }),
        (S.expr.pseudos.animated = function (t) {
          return S.grep(S.timers, function (e) {
            return t === e.elem;
          }).length;
        }),
        (S.offset = {
          setOffset: function (t, e, n) {
            var i,
              r,
              s,
              o,
              a,
              l,
              c = S.css(t, "position"),
              u = S(t),
              h = {};
            "static" === c && (t.style.position = "relative"),
              (a = u.offset()),
              (s = S.css(t, "top")),
              (l = S.css(t, "left")),
              ("absolute" === c || "fixed" === c) &&
              (s + l).indexOf("auto") > -1
                ? ((o = (i = u.position()).top), (r = i.left))
                : ((o = parseFloat(s) || 0), (r = parseFloat(l) || 0)),
              v(e) && (e = e.call(t, n, S.extend({}, a))),
              null != e.top && (h.top = e.top - a.top + o),
              null != e.left && (h.left = e.left - a.left + r),
              "using" in e ? e.using.call(t, h) : u.css(h);
          },
        }),
        S.fn.extend({
          offset: function (t) {
            if (arguments.length)
              return void 0 === t
                ? this
                : this.each(function (e) {
                    S.offset.setOffset(this, t, e);
                  });
            var e,
              n,
              i = this[0];
            return i
              ? i.getClientRects().length
                ? ((e = i.getBoundingClientRect()),
                  (n = i.ownerDocument.defaultView),
                  { top: e.top + n.pageYOffset, left: e.left + n.pageXOffset })
                : { top: 0, left: 0 }
              : void 0;
          },
          position: function () {
            if (this[0]) {
              var t,
                e,
                n,
                i = this[0],
                r = { top: 0, left: 0 };
              if ("fixed" === S.css(i, "position"))
                e = i.getBoundingClientRect();
              else {
                for (
                  e = this.offset(),
                    n = i.ownerDocument,
                    t = i.offsetParent || n.documentElement;
                  t &&
                  (t === n.body || t === n.documentElement) &&
                  "static" === S.css(t, "position");

                )
                  t = t.parentNode;
                t &&
                  t !== i &&
                  1 === t.nodeType &&
                  (((r = S(t).offset()).top += S.css(t, "borderTopWidth", !0)),
                  (r.left += S.css(t, "borderLeftWidth", !0)));
              }
              return {
                top: e.top - r.top - S.css(i, "marginTop", !0),
                left: e.left - r.left - S.css(i, "marginLeft", !0),
              };
            }
          },
          offsetParent: function () {
            return this.map(function () {
              for (
                var t = this.offsetParent;
                t && "static" === S.css(t, "position");

              )
                t = t.offsetParent;
              return t || st;
            });
          },
        }),
        S.each(
          { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" },
          function (t, e) {
            var n = "pageYOffset" === e;
            S.fn[t] = function (i) {
              return G(
                this,
                function (t, i, r) {
                  var s;
                  if (
                    (y(t) ? (s = t) : 9 === t.nodeType && (s = t.defaultView),
                    void 0 === r)
                  )
                    return s ? s[e] : t[i];
                  s
                    ? s.scrollTo(n ? s.pageXOffset : r, n ? r : s.pageYOffset)
                    : (t[i] = r);
                },
                t,
                i,
                arguments.length
              );
            };
          }
        ),
        S.each(["top", "left"], function (t, e) {
          S.cssHooks[e] = Gt(g.pixelPosition, function (t, n) {
            if (n)
              return (n = Wt(t, e)), Bt.test(n) ? S(t).position()[e] + "px" : n;
          });
        }),
        S.each({ Height: "height", Width: "width" }, function (t, e) {
          S.each(
            { padding: "inner" + t, content: e, "": "outer" + t },
            function (n, i) {
              S.fn[i] = function (r, s) {
                var o = arguments.length && (n || "boolean" != typeof r),
                  a = n || (!0 === r || !0 === s ? "margin" : "border");
                return G(
                  this,
                  function (e, n, r) {
                    var s;
                    return y(e)
                      ? 0 === i.indexOf("outer")
                        ? e["inner" + t]
                        : e.document.documentElement["client" + t]
                      : 9 === e.nodeType
                      ? ((s = e.documentElement),
                        Math.max(
                          e.body["scroll" + t],
                          s["scroll" + t],
                          e.body["offset" + t],
                          s["offset" + t],
                          s["client" + t]
                        ))
                      : void 0 === r
                      ? S.css(e, n, a)
                      : S.style(e, n, r, a);
                  },
                  e,
                  o ? r : void 0,
                  o
                );
              };
            }
          );
        }),
        S.each(
          [
            "ajaxStart",
            "ajaxStop",
            "ajaxComplete",
            "ajaxError",
            "ajaxSuccess",
            "ajaxSend",
          ],
          function (t, e) {
            S.fn[e] = function (t) {
              return this.on(e, t);
            };
          }
        ),
        S.fn.extend({
          bind: function (t, e, n) {
            return this.on(t, null, e, n);
          },
          unbind: function (t, e) {
            return this.off(t, null, e);
          },
          delegate: function (t, e, n, i) {
            return this.on(e, t, n, i);
          },
          undelegate: function (t, e, n) {
            return 1 === arguments.length
              ? this.off(t, "**")
              : this.off(e, t || "**", n);
          },
          hover: function (t, e) {
            return this.mouseenter(t).mouseleave(e || t);
          },
        }),
        S.each(
          "blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(
            " "
          ),
          function (t, e) {
            S.fn[e] = function (t, n) {
              return arguments.length > 0
                ? this.on(e, null, t, n)
                : this.trigger(e);
            };
          }
        );
      var Xe = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;
      (S.proxy = function (t, e) {
        var n, i, r;
        if (("string" == typeof e && ((n = t[e]), (e = t), (t = n)), v(t)))
          return (
            (i = a.call(arguments, 2)),
            ((r = function () {
              return t.apply(e || this, i.concat(a.call(arguments)));
            }).guid = t.guid =
              t.guid || S.guid++),
            r
          );
      }),
        (S.holdReady = function (t) {
          t ? S.readyWait++ : S.ready(!0);
        }),
        (S.isArray = Array.isArray),
        (S.parseJSON = JSON.parse),
        (S.nodeName = L),
        (S.isFunction = v),
        (S.isWindow = y),
        (S.camelCase = X),
        (S.type = w),
        (S.now = Date.now),
        (S.isNumeric = function (t) {
          var e = S.type(t);
          return (
            ("number" === e || "string" === e) && !isNaN(t - parseFloat(t))
          );
        }),
        (S.trim = function (t) {
          return null == t ? "" : (t + "").replace(Xe, "");
        }),
        void 0 ===
          (i = function () {
            return S;
          }.apply(e, [])) || (t.exports = i);
      var Je = n.jQuery,
        Ye = n.$;
      return (
        (S.noConflict = function (t) {
          return (
            n.$ === S && (n.$ = Ye), t && n.jQuery === S && (n.jQuery = Je), S
          );
        }),
        void 0 === r && (n.jQuery = n.$ = S),
        S
      );
    });
  },
  HSsa: function (t, e, n) {
    "use strict";
    t.exports = function (t, e) {
      return function () {
        for (var n = new Array(arguments.length), i = 0; i < n.length; i++)
          n[i] = arguments[i];
        return t.apply(e, n);
      };
    };
  },
  I1BE: function (t, e) {
    t.exports = function (t) {
      var e = [];
      return (
        (e.toString = function () {
          return this.map(function (e) {
            var n = (function (t, e) {
              var n = t[1] || "",
                i = t[3];
              if (!i) return n;
              if (e && "function" == typeof btoa) {
                var r =
                    ((o = i),
                    "/*# sourceMappingURL=data:application/json;charset=utf-8;base64," +
                      btoa(unescape(encodeURIComponent(JSON.stringify(o)))) +
                      " */"),
                  s = i.sources.map(function (t) {
                    return "/*# sourceURL=" + i.sourceRoot + t + " */";
                  });
                return [n].concat(s).concat([r]).join("\n");
              }
              var o;
              return [n].join("\n");
            })(e, t);
            return e[2] ? "@media " + e[2] + "{" + n + "}" : n;
          }).join("");
        }),
        (e.i = function (t, n) {
          "string" == typeof t && (t = [[null, t, ""]]);
          for (var i = {}, r = 0; r < this.length; r++) {
            var s = this[r][0];
            "number" == typeof s && (i[s] = !0);
          }
          for (r = 0; r < t.length; r++) {
            var o = t[r];
            ("number" == typeof o[0] && i[o[0]]) ||
              (n && !o[2]
                ? (o[2] = n)
                : n && (o[2] = "(" + o[2] + ") and (" + n + ")"),
              e.push(o));
          }
        }),
        e
      );
    };
  },
  JEQr: function (t, e, n) {
    "use strict";
    (function (e) {
      var i = n("xTJ+"),
        r = n("yK9s"),
        s = n("OH9c"),
        o = { "Content-Type": "application/x-www-form-urlencoded" };
      function a(t, e) {
        !i.isUndefined(t) &&
          i.isUndefined(t["Content-Type"]) &&
          (t["Content-Type"] = e);
      }
      var l,
        c = {
          transitional: {
            silentJSONParsing: !0,
            forcedJSONParsing: !0,
            clarifyTimeoutError: !1,
          },
          adapter:
            ("undefined" != typeof XMLHttpRequest
              ? (l = n("tQ2B"))
              : void 0 !== e &&
                "[object process]" === Object.prototype.toString.call(e) &&
                (l = n("tQ2B")),
            l),
          transformRequest: [
            function (t, e) {
              return (
                r(e, "Accept"),
                r(e, "Content-Type"),
                i.isFormData(t) ||
                i.isArrayBuffer(t) ||
                i.isBuffer(t) ||
                i.isStream(t) ||
                i.isFile(t) ||
                i.isBlob(t)
                  ? t
                  : i.isArrayBufferView(t)
                  ? t.buffer
                  : i.isURLSearchParams(t)
                  ? (a(e, "application/x-www-form-urlencoded;charset=utf-8"),
                    t.toString())
                  : i.isObject(t) ||
                    (e && "application/json" === e["Content-Type"])
                  ? (a(e, "application/json"),
                    (function (t, e, n) {
                      if (i.isString(t))
                        try {
                          return (e || JSON.parse)(t), i.trim(t);
                        } catch (t) {
                          if ("SyntaxError" !== t.name) throw t;
                        }
                      return (n || JSON.stringify)(t);
                    })(t))
                  : t
              );
            },
          ],
          transformResponse: [
            function (t) {
              var e = this.transitional,
                n = e && e.silentJSONParsing,
                r = e && e.forcedJSONParsing,
                o = !n && "json" === this.responseType;
              if (o || (r && i.isString(t) && t.length))
                try {
                  return JSON.parse(t);
                } catch (t) {
                  if (o) {
                    if ("SyntaxError" === t.name)
                      throw s(t, this, "E_JSON_PARSE");
                    throw t;
                  }
                }
              return t;
            },
          ],
          timeout: 0,
          xsrfCookieName: "XSRF-TOKEN",
          xsrfHeaderName: "X-XSRF-TOKEN",
          maxContentLength: -1,
          maxBodyLength: -1,
          validateStatus: function (t) {
            return t >= 200 && t < 300;
          },
        };
      (c.headers = { common: { Accept: "application/json, text/plain, */*" } }),
        i.forEach(["delete", "get", "head"], function (t) {
          c.headers[t] = {};
        }),
        i.forEach(["post", "put", "patch"], function (t) {
          c.headers[t] = i.merge(o);
        }),
        (t.exports = c);
    }.call(this, n("8oxB")));
  },
  LYNF: function (t, e, n) {
    "use strict";
    var i = n("OH9c");
    t.exports = function (t, e, n, r, s) {
      var o = new Error(t);
      return i(o, e, n, r, s);
    };
  },
  Lmem: function (t, e, n) {
    "use strict";
    t.exports = function (t) {
      return !(!t || !t.__CANCEL__);
    };
  },
  MLWZ: function (t, e, n) {
    "use strict";
    var i = n("xTJ+");
    function r(t) {
      return encodeURIComponent(t)
        .replace(/%3A/gi, ":")
        .replace(/%24/g, "$")
        .replace(/%2C/gi, ",")
        .replace(/%20/g, "+")
        .replace(/%5B/gi, "[")
        .replace(/%5D/gi, "]");
    }
    t.exports = function (t, e, n) {
      if (!e) return t;
      var s;
      if (n) s = n(e);
      else if (i.isURLSearchParams(e)) s = e.toString();
      else {
        var o = [];
        i.forEach(e, function (t, e) {
          null != t &&
            (i.isArray(t) ? (e += "[]") : (t = [t]),
            i.forEach(t, function (t) {
              i.isDate(t)
                ? (t = t.toISOString())
                : i.isObject(t) && (t = JSON.stringify(t)),
                o.push(r(e) + "=" + r(t));
            }));
        }),
          (s = o.join("&"));
      }
      if (s) {
        var a = t.indexOf("#");
        -1 !== a && (t = t.slice(0, a)),
          (t += (-1 === t.indexOf("?") ? "?" : "&") + s);
      }
      return t;
    };
  },
  NlKh: function (t, e) {},
  OH9c: function (t, e, n) {
    "use strict";
    t.exports = function (t, e, n, i, r) {
      return (
        (t.config = e),
        n && (t.code = n),
        (t.request = i),
        (t.response = r),
        (t.isAxiosError = !0),
        (t.toJSON = function () {
          return {
            message: this.message,
            name: this.name,
            description: this.description,
            number: this.number,
            fileName: this.fileName,
            lineNumber: this.lineNumber,
            columnNumber: this.columnNumber,
            stack: this.stack,
            config: this.config,
            code: this.code,
          };
        }),
        t
      );
    };
  },
  OTTw: function (t, e, n) {
    "use strict";
    var i = n("xTJ+");
    t.exports = i.isStandardBrowserEnv()
      ? (function () {
          var t,
            e = /(msie|trident)/i.test(navigator.userAgent),
            n = document.createElement("a");
          function r(t) {
            var i = t;
            return (
              e && (n.setAttribute("href", i), (i = n.href)),
              n.setAttribute("href", i),
              {
                href: n.href,
                protocol: n.protocol ? n.protocol.replace(/:$/, "") : "",
                host: n.host,
                search: n.search ? n.search.replace(/^\?/, "") : "",
                hash: n.hash ? n.hash.replace(/^#/, "") : "",
                hostname: n.hostname,
                port: n.port,
                pathname:
                  "/" === n.pathname.charAt(0) ? n.pathname : "/" + n.pathname,
              }
            );
          }
          return (
            (t = r(window.location.href)),
            function (e) {
              var n = i.isString(e) ? r(e) : e;
              return n.protocol === t.protocol && n.host === t.host;
            }
          );
        })()
      : function () {
          return !0;
        };
  },
  "Rn+g": function (t, e, n) {
    "use strict";
    var i = n("LYNF");
    t.exports = function (t, e, n) {
      var r = n.config.validateStatus;
      n.status && r && !r(n.status)
        ? e(
            i(
              "Request failed with status code " + n.status,
              n.config,
              null,
              n.request,
              n
            )
          )
        : t(n);
    };
  },
  SgzI: function (t) {
    t.exports = JSON.parse(
      '{"name":"axios","version":"0.21.4","description":"Promise based HTTP client for the browser and node.js","main":"index.js","scripts":{"test":"grunt test","start":"node ./sandbox/server.js","build":"NODE_ENV=production grunt build","preversion":"npm test","version":"npm run build && grunt version && git add -A dist && git add CHANGELOG.md bower.json package.json","postversion":"git push && git push --tags","examples":"node ./examples/server.js","coveralls":"cat coverage/lcov.info | ./node_modules/coveralls/bin/coveralls.js","fix":"eslint --fix lib/**/*.js"},"repository":{"type":"git","url":"https://github.com/axios/axios.git"},"keywords":["xhr","http","ajax","promise","node"],"author":"Matt Zabriskie","license":"MIT","bugs":{"url":"https://github.com/axios/axios/issues"},"homepage":"https://axios-http.com","devDependencies":{"coveralls":"^3.0.0","es6-promise":"^4.2.4","grunt":"^1.3.0","grunt-banner":"^0.6.0","grunt-cli":"^1.2.0","grunt-contrib-clean":"^1.1.0","grunt-contrib-watch":"^1.0.0","grunt-eslint":"^23.0.0","grunt-karma":"^4.0.0","grunt-mocha-test":"^0.13.3","grunt-ts":"^6.0.0-beta.19","grunt-webpack":"^4.0.2","istanbul-instrumenter-loader":"^1.0.0","jasmine-core":"^2.4.1","karma":"^6.3.2","karma-chrome-launcher":"^3.1.0","karma-firefox-launcher":"^2.1.0","karma-jasmine":"^1.1.1","karma-jasmine-ajax":"^0.1.13","karma-safari-launcher":"^1.0.0","karma-sauce-launcher":"^4.3.6","karma-sinon":"^1.0.5","karma-sourcemap-loader":"^0.3.8","karma-webpack":"^4.0.2","load-grunt-tasks":"^3.5.2","minimist":"^1.2.0","mocha":"^8.2.1","sinon":"^4.5.0","terser-webpack-plugin":"^4.2.3","typescript":"^4.0.5","url-search-params":"^0.10.0","webpack":"^4.44.2","webpack-dev-server":"^3.11.0"},"browser":{"./lib/adapters/http.js":"./lib/adapters/xhr.js"},"jsdelivr":"dist/axios.min.js","unpkg":"dist/axios.min.js","typings":"./index.d.ts","dependencies":{"follow-redirects":"^1.14.0"},"bundlesize":[{"path":"./dist/axios.min.js","threshold":"5kB"}],"_resolved":"https://registry.npmjs.org/axios/-/axios-0.21.4.tgz","_integrity":"sha512-ut5vewkiu8jjGBdqpM44XxjuCjq9LAKeHVmoVfHVzy8eHgxxq8SbAVQNovDA8mVi05kP0Ea/n/UzcSHcTJQfNg==","_from":"axios@0.21.4"}'
    );
  },
  SntB: function (t, e, n) {
    "use strict";
    var i = n("xTJ+");
    t.exports = function (t, e) {
      e = e || {};
      var n = {},
        r = ["url", "method", "data"],
        s = ["headers", "auth", "proxy", "params"],
        o = [
          "baseURL",
          "transformRequest",
          "transformResponse",
          "paramsSerializer",
          "timeout",
          "timeoutMessage",
          "withCredentials",
          "adapter",
          "responseType",
          "xsrfCookieName",
          "xsrfHeaderName",
          "onUploadProgress",
          "onDownloadProgress",
          "decompress",
          "maxContentLength",
          "maxBodyLength",
          "maxRedirects",
          "transport",
          "httpAgent",
          "httpsAgent",
          "cancelToken",
          "socketPath",
          "responseEncoding",
        ],
        a = ["validateStatus"];
      function l(t, e) {
        return i.isPlainObject(t) && i.isPlainObject(e)
          ? i.merge(t, e)
          : i.isPlainObject(e)
          ? i.merge({}, e)
          : i.isArray(e)
          ? e.slice()
          : e;
      }
      function c(r) {
        i.isUndefined(e[r])
          ? i.isUndefined(t[r]) || (n[r] = l(void 0, t[r]))
          : (n[r] = l(t[r], e[r]));
      }
      i.forEach(r, function (t) {
        i.isUndefined(e[t]) || (n[t] = l(void 0, e[t]));
      }),
        i.forEach(s, c),
        i.forEach(o, function (r) {
          i.isUndefined(e[r])
            ? i.isUndefined(t[r]) || (n[r] = l(void 0, t[r]))
            : (n[r] = l(void 0, e[r]));
        }),
        i.forEach(a, function (i) {
          i in e ? (n[i] = l(t[i], e[i])) : i in t && (n[i] = l(void 0, t[i]));
        });
      var u = r.concat(s).concat(o).concat(a),
        h = Object.keys(t)
          .concat(Object.keys(e))
          .filter(function (t) {
            return -1 === u.indexOf(t);
          });
      return i.forEach(h, c), n;
    };
  },
  UnBK: function (t, e, n) {
    "use strict";
    var i = n("xTJ+"),
      r = n("xAGQ"),
      s = n("Lmem"),
      o = n("JEQr");
    function a(t) {
      t.cancelToken && t.cancelToken.throwIfRequested();
    }
    t.exports = function (t) {
      return (
        a(t),
        (t.headers = t.headers || {}),
        (t.data = r.call(t, t.data, t.headers, t.transformRequest)),
        (t.headers = i.merge(
          t.headers.common || {},
          t.headers[t.method] || {},
          t.headers
        )),
        i.forEach(
          ["delete", "get", "head", "post", "put", "patch", "common"],
          function (e) {
            delete t.headers[e];
          }
        ),
        (t.adapter || o.adapter)(t).then(
          function (e) {
            return (
              a(t),
              (e.data = r.call(t, e.data, e.headers, t.transformResponse)),
              e
            );
          },
          function (e) {
            return (
              s(e) ||
                (a(t),
                e &&
                  e.response &&
                  (e.response.data = r.call(
                    t,
                    e.response.data,
                    e.response.headers,
                    t.transformResponse
                  ))),
              Promise.reject(e)
            );
          }
        )
      );
    };
  },
  XwJu: function (t, e, n) {
    "use strict";
    t.exports = function (t) {
      return "object" == typeof t && !0 === t.isAxiosError;
    };
  },
  XxWc: function (t, e, n) {
    "use strict";
    (function (t) {
      function n(t, e) {
        for (var n = 0; n < e.length; n++) {
          var i = e[n];
          (i.enumerable = i.enumerable || !1),
            (i.configurable = !0),
            "value" in i && (i.writable = !0),
            Object.defineProperty(t, i.key, i);
        }
      }
      function i(t) {
        return (i =
          "function" == typeof Symbol && "symbol" == typeof Symbol.iterator
            ? function (t) {
                return typeof t;
              }
            : function (t) {
                return t &&
                  "function" == typeof Symbol &&
                  t.constructor === Symbol &&
                  t !== Symbol.prototype
                  ? "symbol"
                  : typeof t;
              })(t);
      }
      "IntersectionObserver" in window ||
        function (t) {
          !(function () {
            function e(t, e) {
              for (var n = -1, i = t.length; ++n < i; )
                if (n in t && t[n] === e) return n;
              return -1;
            }
            function n(e, n) {
              if (!e) throw new Error("Not enough arguments");
              var i;
              if ("createEvent" in document) {
                i = document.createEvent("Event");
                var r = !(!n || n.bubbles === t) && n.bubbles,
                  s = !(!n || n.cancelable === t) && n.cancelable;
                return i.initEvent(e, r, s), i;
              }
              return (
                ((i = document.createEventObject()).type = e),
                (i.bubbles = !(!n || n.bubbles === t) && n.bubbles),
                (i.cancelable = !(!n || n.cancelable === t) && n.cancelable),
                i
              );
            }
            var i = {
              click: 1,
              dblclick: 1,
              keyup: 1,
              keypress: 1,
              keydown: 1,
              mousedown: 1,
              mouseup: 1,
              mousemove: 1,
              mouseover: 1,
              mouseenter: 1,
              mouseleave: 1,
              mouseout: 1,
              storage: 1,
              storagecommit: 1,
              textinput: 1,
            };
            if (
              "undefined" != typeof document &&
              "undefined" != typeof window
            ) {
              var r = (window.Event && window.Event.prototype) || null;
              (n.NONE = 0),
                (n.CAPTURING_PHASE = 1),
                (n.AT_TARGET = 2),
                (n.BUBBLING_PHASE = 3),
                (window.Event = Window.prototype.Event = n),
                r &&
                  Object.defineProperty(window.Event, "prototype", {
                    configurable: !1,
                    enumerable: !1,
                    writable: !0,
                    value: r,
                  }),
                "createEvent" in document ||
                  ((window.addEventListener =
                    Window.prototype.addEventListener =
                    Document.prototype.addEventListener =
                    Element.prototype.addEventListener =
                      function () {
                        var t = this,
                          n = arguments[0],
                          r = arguments[1];
                        if (t === window && n in i)
                          throw new Error(
                            "In IE8 the event: " +
                              n +
                              " is not available on the window object. Please see https://github.com/Financial-Times/polyfill-service/issues/317 for more information."
                          );
                        t._events || (t._events = {}),
                          t._events[n] ||
                            ((t._events[n] = function (n) {
                              var i,
                                r = t._events[n.type].list,
                                s = r.slice(),
                                o = -1,
                                a = s.length;
                              for (
                                n.preventDefault = function () {
                                  !1 !== n.cancelable && (n.returnValue = !1);
                                },
                                  n.stopPropagation = function () {
                                    n.cancelBubble = !0;
                                  },
                                  n.stopImmediatePropagation = function () {
                                    (n.cancelBubble = !0),
                                      (n.cancelImmediate = !0);
                                  },
                                  n.currentTarget = t,
                                  n.relatedTarget = n.fromElement || null,
                                  n.target = n.target || n.srcElement || t,
                                  n.timeStamp = new Date().getTime(),
                                  n.clientX &&
                                    ((n.pageX =
                                      n.clientX +
                                      document.documentElement.scrollLeft),
                                    (n.pageY =
                                      n.clientY +
                                      document.documentElement.scrollTop));
                                ++o < a && !n.cancelImmediate;

                              )
                                o in s &&
                                  -1 !== e(r, (i = s[o])) &&
                                  "function" == typeof i &&
                                  i.call(t, n);
                            }),
                            (t._events[n].list = []),
                            t.attachEvent &&
                              t.attachEvent("on" + n, t._events[n])),
                          t._events[n].list.push(r);
                      }),
                  (window.removeEventListener =
                    Window.prototype.removeEventListener =
                    Document.prototype.removeEventListener =
                    Element.prototype.removeEventListener =
                      function () {
                        var t,
                          n = this,
                          i = arguments[0],
                          r = arguments[1];
                        n._events &&
                          n._events[i] &&
                          n._events[i].list &&
                          -1 !== (t = e(n._events[i].list, r)) &&
                          (n._events[i].list.splice(t, 1),
                          n._events[i].list.length ||
                            (n.detachEvent &&
                              n.detachEvent("on" + i, n._events[i]),
                            delete n._events[i]));
                      }),
                  (window.dispatchEvent =
                    Window.prototype.dispatchEvent =
                    Document.prototype.dispatchEvent =
                    Element.prototype.dispatchEvent =
                      function (t) {
                        if (!arguments.length)
                          throw new Error("Not enough arguments");
                        if (!t || "string" != typeof t.type)
                          throw new Error("DOM Events Exception 0");
                        var e = this,
                          n = t.type;
                        try {
                          if (!t.bubbles) {
                            t.cancelBubble = !0;
                            var i = function t(i) {
                              (i.cancelBubble = !0),
                                (e || window).detachEvent("on" + n, t);
                            };
                            this.attachEvent("on" + n, i);
                          }
                          this.fireEvent("on" + n, t);
                        } catch (i) {
                          t.target = e;
                          do {
                            (t.currentTarget = e),
                              "_events" in e &&
                                "function" == typeof e._events[n] &&
                                e._events[n].call(e, t),
                              "function" == typeof e["on" + n] &&
                                e["on" + n].call(e, t),
                              (e =
                                9 === e.nodeType
                                  ? e.parentWindow
                                  : e.parentNode);
                          } while (e && !t.cancelBubble);
                        }
                        return !0;
                      }),
                  document.attachEvent("onreadystatechange", function () {
                    "complete" === document.readyState &&
                      document.dispatchEvent(
                        new n("DOMContentLoaded", { bubbles: !0 })
                      );
                  }));
            }
          })(),
            (function (t, e) {
              function n(t) {
                (this.time = t.time),
                  (this.target = t.target),
                  (this.rootBounds = t.rootBounds),
                  (this.boundingClientRect = t.boundingClientRect),
                  (this.intersectionRect = t.intersectionRect || {
                    top: 0,
                    bottom: 0,
                    left: 0,
                    right: 0,
                    width: 0,
                    height: 0,
                  });
                try {
                  this.isIntersecting = !!t.intersectionRect;
                } catch (t) {}
                var e = this.boundingClientRect,
                  n = e.width * e.height,
                  i = this.intersectionRect,
                  r = i.width * i.height;
                this.intersectionRatio = n
                  ? Number((r / n).toFixed(4))
                  : this.isIntersecting
                  ? 1
                  : 0;
              }
              function i(t, e) {
                var n = e || {};
                if ("function" != typeof t)
                  throw new Error("callback must be a function");
                if (n.root && 1 != n.root.nodeType)
                  throw new Error("root must be an Element");
                (this._checkForIntersections = (function (t, e) {
                  var n = null;
                  return function () {
                    n ||
                      (n = setTimeout(function () {
                        t(), (n = null);
                      }, e));
                  };
                })(
                  this._checkForIntersections.bind(this),
                  this.THROTTLE_TIMEOUT
                )),
                  (this._callback = t),
                  (this._observationTargets = []),
                  (this._queuedEntries = []),
                  (this._rootMarginValues = this._parseRootMargin(
                    n.rootMargin
                  )),
                  (this.thresholds = this._initThresholds(n.threshold)),
                  (this.root = n.root || null),
                  (this.rootMargin = this._rootMarginValues
                    .map(function (t) {
                      return t.value + t.unit;
                    })
                    .join(" "));
              }
              function r() {
                return t.performance && performance.now && performance.now();
              }
              function s(t, e, n, i) {
                "function" == typeof t.addEventListener
                  ? t.addEventListener(e, n, i || !1)
                  : "function" == typeof t.attachEvent &&
                    t.attachEvent("on" + e, n);
              }
              function o(t, e, n, i) {
                "function" == typeof t.removeEventListener
                  ? t.removeEventListener(e, n, i || !1)
                  : "function" == typeof t.detatchEvent &&
                    t.detatchEvent("on" + e, n);
              }
              function a(t, e) {
                var n = Math.max(t.top, e.top),
                  i = Math.min(t.bottom, e.bottom),
                  r = Math.max(t.left, e.left),
                  s = Math.min(t.right, e.right),
                  o = s - r,
                  a = i - n;
                return (
                  o >= 0 &&
                  a >= 0 && {
                    top: n,
                    bottom: i,
                    left: r,
                    right: s,
                    width: o,
                    height: a,
                  }
                );
              }
              function l(t) {
                var e;
                try {
                  e = t.getBoundingClientRect();
                } catch (t) {}
                return e
                  ? ((e.width && e.height) ||
                      (e = {
                        top: e.top,
                        right: e.right,
                        bottom: e.bottom,
                        left: e.left,
                        width: e.right - e.left,
                        height: e.bottom - e.top,
                      }),
                    e)
                  : {
                      top: 0,
                      bottom: 0,
                      left: 0,
                      right: 0,
                      width: 0,
                      height: 0,
                    };
              }
              function c(t, e) {
                for (var n = e; n; ) {
                  if (n == t) return !0;
                  n = u(n);
                }
                return !1;
              }
              function u(t) {
                var e = t.parentNode;
                return e && 11 == e.nodeType && e.host
                  ? e.host
                  : e && e.assignedSlot
                  ? e.assignedSlot.parentNode
                  : e;
              }
              var h = [];
              (i.prototype.THROTTLE_TIMEOUT = 100),
                (i.prototype.POLL_INTERVAL = null),
                (i.prototype.USE_MUTATION_OBSERVER = !0),
                (i.prototype.observe = function (t) {
                  if (
                    !this._observationTargets.some(function (e) {
                      return e.element == t;
                    })
                  ) {
                    if (!t || 1 != t.nodeType)
                      throw new Error("target must be an Element");
                    this._registerInstance(),
                      this._observationTargets.push({
                        element: t,
                        entry: null,
                      }),
                      this._monitorIntersections(),
                      this._checkForIntersections();
                  }
                }),
                (i.prototype.unobserve = function (t) {
                  (this._observationTargets = this._observationTargets.filter(
                    function (e) {
                      return e.element != t;
                    }
                  )),
                    this._observationTargets.length ||
                      (this._unmonitorIntersections(),
                      this._unregisterInstance());
                }),
                (i.prototype.disconnect = function () {
                  (this._observationTargets = []),
                    this._unmonitorIntersections(),
                    this._unregisterInstance();
                }),
                (i.prototype.takeRecords = function () {
                  var t = this._queuedEntries.slice();
                  return (this._queuedEntries = []), t;
                }),
                (i.prototype._initThresholds = function (t) {
                  var e = t || [0];
                  return (
                    Array.isArray(e) || (e = [e]),
                    e.sort().filter(function (t, e, n) {
                      if ("number" != typeof t || isNaN(t) || t < 0 || t > 1)
                        throw new Error(
                          "threshold must be a number between 0 and 1 inclusively"
                        );
                      return t !== n[e - 1];
                    })
                  );
                }),
                (i.prototype._parseRootMargin = function (t) {
                  var e = (t || "0px").split(/\s+/).map(function (t) {
                    var e = /^(-?\d*\.?\d+)(px|%)$/.exec(t);
                    if (!e)
                      throw new Error(
                        "rootMargin must be specified in pixels or percent"
                      );
                    return { value: parseFloat(e[1]), unit: e[2] };
                  });
                  return (
                    (e[1] = e[1] || e[0]),
                    (e[2] = e[2] || e[0]),
                    (e[3] = e[3] || e[1]),
                    e
                  );
                }),
                (i.prototype._monitorIntersections = function () {
                  this._monitoringIntersections ||
                    ((this._monitoringIntersections = !0),
                    this.POLL_INTERVAL
                      ? (this._monitoringInterval = setInterval(
                          this._checkForIntersections,
                          this.POLL_INTERVAL
                        ))
                      : (s(t, "resize", this._checkForIntersections, !0),
                        s(e, "scroll", this._checkForIntersections, !0),
                        this.USE_MUTATION_OBSERVER &&
                          "MutationObserver" in t &&
                          ((this._domObserver = new MutationObserver(
                            this._checkForIntersections
                          )),
                          this._domObserver.observe(e, {
                            attributes: !0,
                            childList: !0,
                            characterData: !0,
                            subtree: !0,
                          }))));
                }),
                (i.prototype._unmonitorIntersections = function () {
                  this._monitoringIntersections &&
                    ((this._monitoringIntersections = !1),
                    clearInterval(this._monitoringInterval),
                    (this._monitoringInterval = null),
                    o(t, "resize", this._checkForIntersections, !0),
                    o(e, "scroll", this._checkForIntersections, !0),
                    this._domObserver &&
                      (this._domObserver.disconnect(),
                      (this._domObserver = null)));
                }),
                (i.prototype._checkForIntersections = function () {
                  var t = this._rootIsInDom(),
                    e = t
                      ? this._getRootRect()
                      : {
                          top: 0,
                          bottom: 0,
                          left: 0,
                          right: 0,
                          width: 0,
                          height: 0,
                        };
                  this._observationTargets.forEach(function (i) {
                    var s = i.element,
                      o = l(s),
                      a = this._rootContainsTarget(s),
                      c = i.entry,
                      u =
                        t && a && this._computeTargetAndRootIntersection(s, e),
                      h = (i.entry = new n({
                        time: r(),
                        target: s,
                        boundingClientRect: o,
                        rootBounds: e,
                        intersectionRect: u,
                      }));
                    c
                      ? t && a
                        ? this._hasCrossedThreshold(c, h) &&
                          this._queuedEntries.push(h)
                        : c && c.isIntersecting && this._queuedEntries.push(h)
                      : this._queuedEntries.push(h);
                  }, this),
                    this._queuedEntries.length &&
                      this._callback(this.takeRecords(), this);
                }),
                (i.prototype._computeTargetAndRootIntersection = function (
                  n,
                  i
                ) {
                  if ("none" != t.getComputedStyle(n).display) {
                    for (var r = l(n), s = u(n), o = !1; !o; ) {
                      var c = null,
                        h = 1 == s.nodeType ? t.getComputedStyle(s) : {};
                      if ("none" == h.display) return;
                      if (
                        (s == this.root || s == e
                          ? ((o = !0), (c = i))
                          : s != e.body &&
                            s != e.documentElement &&
                            "visible" != h.overflow &&
                            (c = l(s)),
                        c && !(r = a(c, r)))
                      )
                        break;
                      s = u(s);
                    }
                    return r;
                  }
                }),
                (i.prototype._getRootRect = function () {
                  var t;
                  if (this.root) t = l(this.root);
                  else {
                    var n = e.documentElement,
                      i = e.body;
                    t = {
                      top: 0,
                      left: 0,
                      right: n.clientWidth || i.clientWidth,
                      width: n.clientWidth || i.clientWidth,
                      bottom: n.clientHeight || i.clientHeight,
                      height: n.clientHeight || i.clientHeight,
                    };
                  }
                  return this._expandRectByRootMargin(t);
                }),
                (i.prototype._expandRectByRootMargin = function (t) {
                  var e = this._rootMarginValues.map(function (e, n) {
                      return "px" == e.unit
                        ? e.value
                        : (e.value * (n % 2 ? t.width : t.height)) / 100;
                    }),
                    n = {
                      top: t.top - e[0],
                      right: t.right + e[1],
                      bottom: t.bottom + e[2],
                      left: t.left - e[3],
                    };
                  return (
                    (n.width = n.right - n.left),
                    (n.height = n.bottom - n.top),
                    n
                  );
                }),
                (i.prototype._hasCrossedThreshold = function (t, e) {
                  var n = t && t.isIntersecting ? t.intersectionRatio || 0 : -1,
                    i = e.isIntersecting ? e.intersectionRatio || 0 : -1;
                  if (n !== i)
                    for (var r = 0; r < this.thresholds.length; r++) {
                      var s = this.thresholds[r];
                      if (s == n || s == i || s < n != s < i) return !0;
                    }
                }),
                (i.prototype._rootIsInDom = function () {
                  return !this.root || c(e, this.root);
                }),
                (i.prototype._rootContainsTarget = function (t) {
                  return c(this.root || e, t);
                }),
                (i.prototype._registerInstance = function () {
                  h.indexOf(this) < 0 && h.push(this);
                }),
                (i.prototype._unregisterInstance = function () {
                  var t = h.indexOf(this);
                  -1 != t && h.splice(t, 1);
                }),
                (t.IntersectionObserver = i),
                (t.IntersectionObserverEntry = n);
            })(window, document);
        }.call(
          ("object" ===
            ("undefined" == typeof window ? "undefined" : i(window)) &&
            window) ||
            ("object" ===
              ("undefined" == typeof self ? "undefined" : i(self)) &&
              self) ||
            ("object" === (void 0 === t ? "undefined" : i(t)) && t) ||
            {}
        );
      var r = (function () {
        function t(e) {
          !(function (t, e) {
            if (!(t instanceof e))
              throw new TypeError("Cannot call a class as a function");
          })(this, t),
            this.bindMethods(),
            (this.el = e || document.body),
            (this.cache = null),
            (this.options = null),
            (this.observer = null),
            this.init();
        }
        var e, i, r;
        return (
          (e = t),
          (i = [
            {
              key: "bindMethods",
              value: function () {
                var t = this;
                ["handler"].forEach(function (e) {
                  return (t[e] = t[e].bind(t));
                });
              },
            },
            {
              key: "initItems",
              value: function () {
                this.items = Array.from(
                  this.el.querySelectorAll(
                    "[data-appear-item], [data-appear-block], [data-appear-group], [data-appear-fade-in], [data-appear-sequential]"
                  )
                );
              },
            },
            {
              key: "init",
              value: function () {
                this.initItems(),
                  this.getCache(),
                  this.createObserver(),
                  this.run();
              },
            },
            {
              key: "run",
              value: function () {
                var t = this;
                this.cache.forEach(function (e) {
                  t.observer.observe(e.el);
                });
              },
            },
            {
              key: "createObserver",
              value: function () {
                (this.options = {
                  root: null,
                  rootMargin: "0px 0px -5% 0px",
                  threshold: [0, 0],
                }),
                  (this.observer = new IntersectionObserver(
                    this.handler,
                    this.options
                  ));
              },
            },
            {
              key: "getCache",
              value: function () {
                var t = this;
                (this.cache = []),
                  this.items.forEach(function (e, n) {
                    if (
                      (t.cache.push({ el: e, isIntersected: !1, elems: null }),
                      void 0 !== e.dataset.appearSequential)
                    ) {
                      var i =
                        parseFloat(e.dataset.animationDelay) >= 0
                          ? parseFloat(e.dataset.animationDelay)
                          : 0.15;
                      Array.from(e.children).forEach(function (t, e) {
                        t.style.transitionDelay = e * i + "s";
                      });
                    }
                    if (void 0 !== e.dataset.appearGroup) {
                      var r =
                        parseFloat(e.dataset.animationDelay) >= 0
                          ? parseFloat(e.dataset.animationDelay)
                          : 0.15;
                      Array.from(
                        e.querySelectorAll("[data-appear-group-item]")
                      ).forEach(function (t, e) {
                        t.style.transitionDelay = e * r + "s";
                      });
                    }
                  });
              },
            },
            {
              key: "handler",
              value: function (t) {
                var e = this;
                t.forEach(function (t) {
                  if (t.isIntersecting) {
                    var n = e.items.indexOf(t.target),
                      i = e.cache[n];
                    (i.isIntersected = !0),
                      i.el.classList.add("is-appeared"),
                      e.stillObserving()
                        ? e.observer.unobserve(t.target)
                        : e.observer.disconnect();
                  }
                });
              },
            },
            {
              key: "stillObserving",
              value: function () {
                return this.cache.some(function (t) {
                  return !t.isIntersected;
                });
              },
            },
            {
              key: "destroy",
              value: function () {
                this.observer.disconnect(),
                  (this.observer = null),
                  (this.elems = null),
                  (this.cache = null);
              },
            },
          ]) && n(e.prototype, i),
          r && n(e, r),
          t
        );
      })();
      e.a = r;
    }.call(this, n("yLpj")));
  },
  "Zej/": function (t, e, n) {
    var i, r, s;
    !(function (o) {
      "use strict";
      (r = [n("EVdn")]),
        void 0 ===
          (s =
            "function" ==
            typeof (i = function (t) {
              var e = window.Slick || {};
              (((n = 0),
              (e = function (e, i) {
                var r,
                  s = this;
                (s.defaults = {
                  accessibility: !0,
                  adaptiveHeight: !1,
                  appendArrows: t(e),
                  appendDots: t(e),
                  arrows: !0,
                  asNavFor: null,
                  prevArrow:
                    '<button class="slick-prev" aria-label="Previous" type="button">Previous</button>',
                  nextArrow:
                    '<button class="slick-next" aria-label="Next" type="button">Next</button>',
                  autoplay: !1,
                  autoplaySpeed: 3e3,
                  centerMode: !1,
                  centerPadding: "50px",
                  cssEase: "ease",
                  customPaging: function (e, n) {
                    return t('<button type="button" />').text(n + 1);
                  },
                  dots: !1,
                  dotsClass: "slick-dots",
                  draggable: !0,
                  easing: "linear",
                  edgeFriction: 0.35,
                  fade: !1,
                  focusOnSelect: !1,
                  focusOnChange: !1,
                  infinite: !0,
                  initialSlide: 0,
                  lazyLoad: "ondemand",
                  mobileFirst: !1,
                  pauseOnHover: !0,
                  pauseOnFocus: !0,
                  pauseOnDotsHover: !1,
                  respondTo: "window",
                  responsive: null,
                  rows: 1,
                  rtl: !1,
                  slide: "",
                  slidesPerRow: 1,
                  slidesToShow: 1,
                  slidesToScroll: 1,
                  speed: 500,
                  swipe: !0,
                  swipeToSlide: !1,
                  touchMove: !0,
                  touchThreshold: 5,
                  useCSS: !0,
                  useTransform: !0,
                  variableWidth: !1,
                  vertical: !1,
                  verticalSwiping: !1,
                  waitForAnimate: !0,
                  zIndex: 1e3,
                }),
                  (s.initials = {
                    animating: !1,
                    dragging: !1,
                    autoPlayTimer: null,
                    currentDirection: 0,
                    currentLeft: null,
                    currentSlide: 0,
                    direction: 1,
                    $dots: null,
                    listWidth: null,
                    listHeight: null,
                    loadIndex: 0,
                    $nextArrow: null,
                    $prevArrow: null,
                    scrolling: !1,
                    slideCount: null,
                    slideWidth: null,
                    $slideTrack: null,
                    $slides: null,
                    sliding: !1,
                    slideOffset: 0,
                    swipeLeft: null,
                    swiping: !1,
                    $list: null,
                    touchObject: {},
                    transformsEnabled: !1,
                    unslicked: !1,
                  }),
                  t.extend(s, s.initials),
                  (s.activeBreakpoint = null),
                  (s.animType = null),
                  (s.animProp = null),
                  (s.breakpoints = []),
                  (s.breakpointSettings = []),
                  (s.cssTransitions = !1),
                  (s.focussed = !1),
                  (s.interrupted = !1),
                  (s.hidden = "hidden"),
                  (s.paused = !0),
                  (s.positionProp = null),
                  (s.respondTo = null),
                  (s.rowCount = 1),
                  (s.shouldClick = !0),
                  (s.$slider = t(e)),
                  (s.$slidesCache = null),
                  (s.transformType = null),
                  (s.transitionType = null),
                  (s.visibilityChange = "visibilitychange"),
                  (s.windowWidth = 0),
                  (s.windowTimer = null),
                  (r = t(e).data("slick") || {}),
                  (s.options = t.extend({}, s.defaults, i, r)),
                  (s.currentSlide = s.options.initialSlide),
                  (s.originalSettings = s.options),
                  void 0 !== document.mozHidden
                    ? ((s.hidden = "mozHidden"),
                      (s.visibilityChange = "mozvisibilitychange"))
                    : void 0 !== document.webkitHidden &&
                      ((s.hidden = "webkitHidden"),
                      (s.visibilityChange = "webkitvisibilitychange")),
                  (s.autoPlay = t.proxy(s.autoPlay, s)),
                  (s.autoPlayClear = t.proxy(s.autoPlayClear, s)),
                  (s.autoPlayIterator = t.proxy(s.autoPlayIterator, s)),
                  (s.changeSlide = t.proxy(s.changeSlide, s)),
                  (s.clickHandler = t.proxy(s.clickHandler, s)),
                  (s.selectHandler = t.proxy(s.selectHandler, s)),
                  (s.setPosition = t.proxy(s.setPosition, s)),
                  (s.swipeHandler = t.proxy(s.swipeHandler, s)),
                  (s.dragHandler = t.proxy(s.dragHandler, s)),
                  (s.keyHandler = t.proxy(s.keyHandler, s)),
                  (s.instanceUid = n++),
                  (s.htmlExpr = /^(?:\s*(<[\w\W]+>)[^>]*)$/),
                  s.registerBreakpoints(),
                  s.init(!0);
              })).prototype.activateADA = function () {
                this.$slideTrack
                  .find(".slick-active")
                  .attr({ "aria-hidden": "false" })
                  .find("a, input, button, select")
                  .attr({ tabindex: "0" });
              }),
                (e.prototype.addSlide = e.prototype.slickAdd =
                  function (e, n, i) {
                    var r = this;
                    if ("boolean" == typeof n) (i = n), (n = null);
                    else if (n < 0 || n >= r.slideCount) return !1;
                    r.unload(),
                      "number" == typeof n
                        ? 0 === n && 0 === r.$slides.length
                          ? t(e).appendTo(r.$slideTrack)
                          : i
                          ? t(e).insertBefore(r.$slides.eq(n))
                          : t(e).insertAfter(r.$slides.eq(n))
                        : !0 === i
                        ? t(e).prependTo(r.$slideTrack)
                        : t(e).appendTo(r.$slideTrack),
                      (r.$slides = r.$slideTrack.children(this.options.slide)),
                      r.$slideTrack.children(this.options.slide).detach(),
                      r.$slideTrack.append(r.$slides),
                      r.$slides.each(function (e, n) {
                        t(n).attr("data-slick-index", e);
                      }),
                      (r.$slidesCache = r.$slides),
                      r.reinit();
                  }),
                (e.prototype.animateHeight = function () {
                  var t = this;
                  if (
                    1 === t.options.slidesToShow &&
                    !0 === t.options.adaptiveHeight &&
                    !1 === t.options.vertical
                  ) {
                    var e = t.$slides.eq(t.currentSlide).outerHeight(!0);
                    t.$list.animate({ height: e }, t.options.speed);
                  }
                }),
                (e.prototype.animateSlide = function (e, n) {
                  var i = {},
                    r = this;
                  r.animateHeight(),
                    !0 === r.options.rtl &&
                      !1 === r.options.vertical &&
                      (e = -e),
                    !1 === r.transformsEnabled
                      ? !1 === r.options.vertical
                        ? r.$slideTrack.animate(
                            { left: e },
                            r.options.speed,
                            r.options.easing,
                            n
                          )
                        : r.$slideTrack.animate(
                            { top: e },
                            r.options.speed,
                            r.options.easing,
                            n
                          )
                      : !1 === r.cssTransitions
                      ? (!0 === r.options.rtl &&
                          (r.currentLeft = -r.currentLeft),
                        t({ animStart: r.currentLeft }).animate(
                          { animStart: e },
                          {
                            duration: r.options.speed,
                            easing: r.options.easing,
                            step: function (t) {
                              (t = Math.ceil(t)),
                                !1 === r.options.vertical
                                  ? ((i[r.animType] =
                                      "translate(" + t + "px, 0px)"),
                                    r.$slideTrack.css(i))
                                  : ((i[r.animType] =
                                      "translate(0px," + t + "px)"),
                                    r.$slideTrack.css(i));
                            },
                            complete: function () {
                              n && n.call();
                            },
                          }
                        ))
                      : (r.applyTransition(),
                        (e = Math.ceil(e)),
                        !1 === r.options.vertical
                          ? (i[r.animType] =
                              "translate3d(" + e + "px, 0px, 0px)")
                          : (i[r.animType] =
                              "translate3d(0px," + e + "px, 0px)"),
                        r.$slideTrack.css(i),
                        n &&
                          setTimeout(function () {
                            r.disableTransition(), n.call();
                          }, r.options.speed));
                }),
                (e.prototype.getNavTarget = function () {
                  var e = this.options.asNavFor;
                  return e && null !== e && (e = t(e).not(this.$slider)), e;
                }),
                (e.prototype.asNavFor = function (e) {
                  var n = this.getNavTarget();
                  null !== n &&
                    "object" == typeof n &&
                    n.each(function () {
                      var n = t(this).slick("getSlick");
                      n.unslicked || n.slideHandler(e, !0);
                    });
                }),
                (e.prototype.applyTransition = function (t) {
                  var e = this,
                    n = {};
                  !1 === e.options.fade
                    ? (n[e.transitionType] =
                        e.transformType +
                        " " +
                        e.options.speed +
                        "ms " +
                        e.options.cssEase)
                    : (n[e.transitionType] =
                        "opacity " +
                        e.options.speed +
                        "ms " +
                        e.options.cssEase),
                    !1 === e.options.fade
                      ? e.$slideTrack.css(n)
                      : e.$slides.eq(t).css(n);
                }),
                (e.prototype.autoPlay = function () {
                  var t = this;
                  t.autoPlayClear(),
                    t.slideCount > t.options.slidesToShow &&
                      (t.autoPlayTimer = setInterval(
                        t.autoPlayIterator,
                        t.options.autoplaySpeed
                      ));
                }),
                (e.prototype.autoPlayClear = function () {
                  this.autoPlayTimer && clearInterval(this.autoPlayTimer);
                }),
                (e.prototype.autoPlayIterator = function () {
                  var t = this,
                    e = t.currentSlide + t.options.slidesToScroll;
                  t.paused ||
                    t.interrupted ||
                    t.focussed ||
                    (!1 === t.options.infinite &&
                      (1 === t.direction &&
                      t.currentSlide + 1 === t.slideCount - 1
                        ? (t.direction = 0)
                        : 0 === t.direction &&
                          ((e = t.currentSlide - t.options.slidesToScroll),
                          t.currentSlide - 1 == 0 && (t.direction = 1))),
                    t.slideHandler(e));
                }),
                (e.prototype.buildArrows = function () {
                  var e = this;
                  !0 === e.options.arrows &&
                    ((e.$prevArrow = t(e.options.prevArrow).addClass(
                      "slick-arrow"
                    )),
                    (e.$nextArrow = t(e.options.nextArrow).addClass(
                      "slick-arrow"
                    )),
                    e.slideCount > e.options.slidesToShow
                      ? (e.$prevArrow
                          .removeClass("slick-hidden")
                          .removeAttr("aria-hidden tabindex"),
                        e.$nextArrow
                          .removeClass("slick-hidden")
                          .removeAttr("aria-hidden tabindex"),
                        e.htmlExpr.test(e.options.prevArrow) &&
                          e.$prevArrow.prependTo(e.options.appendArrows),
                        e.htmlExpr.test(e.options.nextArrow) &&
                          e.$nextArrow.appendTo(e.options.appendArrows),
                        !0 !== e.options.infinite &&
                          e.$prevArrow
                            .addClass("slick-disabled")
                            .attr("aria-disabled", "true"))
                      : e.$prevArrow
                          .add(e.$nextArrow)
                          .addClass("slick-hidden")
                          .attr({ "aria-disabled": "true", tabindex: "-1" }));
                }),
                (e.prototype.buildDots = function () {
                  var e,
                    n,
                    i = this;
                  if (
                    !0 === i.options.dots &&
                    i.slideCount > i.options.slidesToShow
                  ) {
                    for (
                      i.$slider.addClass("slick-dotted"),
                        n = t("<ul />").addClass(i.options.dotsClass),
                        e = 0;
                      e <= i.getDotCount();
                      e += 1
                    )
                      n.append(
                        t("<li />").append(
                          i.options.customPaging.call(this, i, e)
                        )
                      );
                    (i.$dots = n.appendTo(i.options.appendDots)),
                      i.$dots.find("li").first().addClass("slick-active");
                  }
                }),
                (e.prototype.buildOut = function () {
                  var e = this;
                  (e.$slides = e.$slider
                    .children(e.options.slide + ":not(.slick-cloned)")
                    .addClass("slick-slide")),
                    (e.slideCount = e.$slides.length),
                    e.$slides.each(function (e, n) {
                      t(n)
                        .attr("data-slick-index", e)
                        .data("originalStyling", t(n).attr("style") || "");
                    }),
                    e.$slider.addClass("slick-slider"),
                    (e.$slideTrack =
                      0 === e.slideCount
                        ? t('<div class="slick-track"/>').appendTo(e.$slider)
                        : e.$slides
                            .wrapAll('<div class="slick-track"/>')
                            .parent()),
                    (e.$list = e.$slideTrack
                      .wrap('<div class="slick-list"/>')
                      .parent()),
                    e.$slideTrack.css("opacity", 0),
                    (!0 !== e.options.centerMode &&
                      !0 !== e.options.swipeToSlide) ||
                      (e.options.slidesToScroll = 1),
                    t("img[data-lazy]", e.$slider)
                      .not("[src]")
                      .addClass("slick-loading"),
                    e.setupInfinite(),
                    e.buildArrows(),
                    e.buildDots(),
                    e.updateDots(),
                    e.setSlideClasses(
                      "number" == typeof e.currentSlide ? e.currentSlide : 0
                    ),
                    !0 === e.options.draggable && e.$list.addClass("draggable");
                }),
                (e.prototype.buildRows = function () {
                  var t,
                    e,
                    n,
                    i,
                    r,
                    s,
                    o,
                    a = this;
                  if (
                    ((i = document.createDocumentFragment()),
                    (s = a.$slider.children()),
                    a.options.rows > 0)
                  ) {
                    for (
                      o = a.options.slidesPerRow * a.options.rows,
                        r = Math.ceil(s.length / o),
                        t = 0;
                      t < r;
                      t++
                    ) {
                      var l = document.createElement("div");
                      for (e = 0; e < a.options.rows; e++) {
                        var c = document.createElement("div");
                        for (n = 0; n < a.options.slidesPerRow; n++) {
                          var u = t * o + (e * a.options.slidesPerRow + n);
                          s.get(u) && c.appendChild(s.get(u));
                        }
                        l.appendChild(c);
                      }
                      i.appendChild(l);
                    }
                    a.$slider.empty().append(i),
                      a.$slider
                        .children()
                        .children()
                        .children()
                        .css({
                          width: 100 / a.options.slidesPerRow + "%",
                          display: "inline-block",
                        });
                  }
                }),
                (e.prototype.checkResponsive = function (e, n) {
                  var i,
                    r,
                    s,
                    o = this,
                    a = !1,
                    l = o.$slider.width(),
                    c = window.innerWidth || t(window).width();
                  if (
                    ("window" === o.respondTo
                      ? (s = c)
                      : "slider" === o.respondTo
                      ? (s = l)
                      : "min" === o.respondTo && (s = Math.min(c, l)),
                    o.options.responsive &&
                      o.options.responsive.length &&
                      null !== o.options.responsive)
                  ) {
                    for (i in ((r = null), o.breakpoints))
                      o.breakpoints.hasOwnProperty(i) &&
                        (!1 === o.originalSettings.mobileFirst
                          ? s < o.breakpoints[i] && (r = o.breakpoints[i])
                          : s > o.breakpoints[i] && (r = o.breakpoints[i]));
                    null !== r
                      ? null !== o.activeBreakpoint
                        ? (r !== o.activeBreakpoint || n) &&
                          ((o.activeBreakpoint = r),
                          "unslick" === o.breakpointSettings[r]
                            ? o.unslick(r)
                            : ((o.options = t.extend(
                                {},
                                o.originalSettings,
                                o.breakpointSettings[r]
                              )),
                              !0 === e &&
                                (o.currentSlide = o.options.initialSlide),
                              o.refresh(e)),
                          (a = r))
                        : ((o.activeBreakpoint = r),
                          "unslick" === o.breakpointSettings[r]
                            ? o.unslick(r)
                            : ((o.options = t.extend(
                                {},
                                o.originalSettings,
                                o.breakpointSettings[r]
                              )),
                              !0 === e &&
                                (o.currentSlide = o.options.initialSlide),
                              o.refresh(e)),
                          (a = r))
                      : null !== o.activeBreakpoint &&
                        ((o.activeBreakpoint = null),
                        (o.options = o.originalSettings),
                        !0 === e && (o.currentSlide = o.options.initialSlide),
                        o.refresh(e),
                        (a = r)),
                      e || !1 === a || o.$slider.trigger("breakpoint", [o, a]);
                  }
                }),
                (e.prototype.changeSlide = function (e, n) {
                  var i,
                    r,
                    s = this,
                    o = t(e.currentTarget);
                  switch (
                    (o.is("a") && e.preventDefault(),
                    o.is("li") || (o = o.closest("li")),
                    (i =
                      s.slideCount % s.options.slidesToScroll != 0
                        ? 0
                        : (s.slideCount - s.currentSlide) %
                          s.options.slidesToScroll),
                    e.data.message)
                  ) {
                    case "previous":
                      (r =
                        0 === i
                          ? s.options.slidesToScroll
                          : s.options.slidesToShow - i),
                        s.slideCount > s.options.slidesToShow &&
                          s.slideHandler(s.currentSlide - r, !1, n);
                      break;
                    case "next":
                      (r = 0 === i ? s.options.slidesToScroll : i),
                        s.slideCount > s.options.slidesToShow &&
                          s.slideHandler(s.currentSlide + r, !1, n);
                      break;
                    case "index":
                      var a =
                        0 === e.data.index
                          ? 0
                          : e.data.index ||
                            o.index() * s.options.slidesToScroll;
                      s.slideHandler(s.checkNavigable(a), !1, n),
                        o.children().trigger("focus");
                      break;
                    default:
                      return;
                  }
                }),
                (e.prototype.checkNavigable = function (t) {
                  var e, n;
                  if (
                    ((n = 0),
                    t > (e = this.getNavigableIndexes())[e.length - 1])
                  )
                    t = e[e.length - 1];
                  else
                    for (var i in e) {
                      if (t < e[i]) {
                        t = n;
                        break;
                      }
                      n = e[i];
                    }
                  return t;
                }),
                (e.prototype.cleanUpEvents = function () {
                  var e = this;
                  e.options.dots &&
                    null !== e.$dots &&
                    (t("li", e.$dots)
                      .off("click.slick", e.changeSlide)
                      .off("mouseenter.slick", t.proxy(e.interrupt, e, !0))
                      .off("mouseleave.slick", t.proxy(e.interrupt, e, !1)),
                    !0 === e.options.accessibility &&
                      e.$dots.off("keydown.slick", e.keyHandler)),
                    e.$slider.off("focus.slick blur.slick"),
                    !0 === e.options.arrows &&
                      e.slideCount > e.options.slidesToShow &&
                      (e.$prevArrow &&
                        e.$prevArrow.off("click.slick", e.changeSlide),
                      e.$nextArrow &&
                        e.$nextArrow.off("click.slick", e.changeSlide),
                      !0 === e.options.accessibility &&
                        (e.$prevArrow &&
                          e.$prevArrow.off("keydown.slick", e.keyHandler),
                        e.$nextArrow &&
                          e.$nextArrow.off("keydown.slick", e.keyHandler))),
                    e.$list.off(
                      "touchstart.slick mousedown.slick",
                      e.swipeHandler
                    ),
                    e.$list.off(
                      "touchmove.slick mousemove.slick",
                      e.swipeHandler
                    ),
                    e.$list.off("touchend.slick mouseup.slick", e.swipeHandler),
                    e.$list.off(
                      "touchcancel.slick mouseleave.slick",
                      e.swipeHandler
                    ),
                    e.$list.off("click.slick", e.clickHandler),
                    t(document).off(e.visibilityChange, e.visibility),
                    e.cleanUpSlideEvents(),
                    !0 === e.options.accessibility &&
                      e.$list.off("keydown.slick", e.keyHandler),
                    !0 === e.options.focusOnSelect &&
                      t(e.$slideTrack)
                        .children()
                        .off("click.slick", e.selectHandler),
                    t(window).off(
                      "orientationchange.slick.slick-" + e.instanceUid,
                      e.orientationChange
                    ),
                    t(window).off(
                      "resize.slick.slick-" + e.instanceUid,
                      e.resize
                    ),
                    t("[draggable!=true]", e.$slideTrack).off(
                      "dragstart",
                      e.preventDefault
                    ),
                    t(window).off(
                      "load.slick.slick-" + e.instanceUid,
                      e.setPosition
                    );
                }),
                (e.prototype.cleanUpSlideEvents = function () {
                  var e = this;
                  e.$list.off("mouseenter.slick", t.proxy(e.interrupt, e, !0)),
                    e.$list.off(
                      "mouseleave.slick",
                      t.proxy(e.interrupt, e, !1)
                    );
                }),
                (e.prototype.cleanUpRows = function () {
                  var t,
                    e = this;
                  e.options.rows > 0 &&
                    ((t = e.$slides.children().children()).removeAttr("style"),
                    e.$slider.empty().append(t));
                }),
                (e.prototype.clickHandler = function (t) {
                  !1 === this.shouldClick &&
                    (t.stopImmediatePropagation(),
                    t.stopPropagation(),
                    t.preventDefault());
                }),
                (e.prototype.destroy = function (e) {
                  var n = this;
                  n.autoPlayClear(),
                    (n.touchObject = {}),
                    n.cleanUpEvents(),
                    t(".slick-cloned", n.$slider).detach(),
                    n.$dots && n.$dots.remove(),
                    n.$prevArrow &&
                      n.$prevArrow.length &&
                      (n.$prevArrow
                        .removeClass("slick-disabled slick-arrow slick-hidden")
                        .removeAttr("aria-hidden aria-disabled tabindex")
                        .css("display", ""),
                      n.htmlExpr.test(n.options.prevArrow) &&
                        n.$prevArrow.remove()),
                    n.$nextArrow &&
                      n.$nextArrow.length &&
                      (n.$nextArrow
                        .removeClass("slick-disabled slick-arrow slick-hidden")
                        .removeAttr("aria-hidden aria-disabled tabindex")
                        .css("display", ""),
                      n.htmlExpr.test(n.options.nextArrow) &&
                        n.$nextArrow.remove()),
                    n.$slides &&
                      (n.$slides
                        .removeClass(
                          "slick-slide slick-active slick-center slick-visible slick-current"
                        )
                        .removeAttr("aria-hidden")
                        .removeAttr("data-slick-index")
                        .each(function () {
                          t(this).attr(
                            "style",
                            t(this).data("originalStyling")
                          );
                        }),
                      n.$slideTrack.children(this.options.slide).detach(),
                      n.$slideTrack.detach(),
                      n.$list.detach(),
                      n.$slider.append(n.$slides)),
                    n.cleanUpRows(),
                    n.$slider.removeClass("slick-slider"),
                    n.$slider.removeClass("slick-initialized"),
                    n.$slider.removeClass("slick-dotted"),
                    (n.unslicked = !0),
                    e || n.$slider.trigger("destroy", [n]);
                }),
                (e.prototype.disableTransition = function (t) {
                  var e = this,
                    n = {};
                  (n[e.transitionType] = ""),
                    !1 === e.options.fade
                      ? e.$slideTrack.css(n)
                      : e.$slides.eq(t).css(n);
                }),
                (e.prototype.fadeSlide = function (t, e) {
                  var n = this;
                  !1 === n.cssTransitions
                    ? (n.$slides.eq(t).css({ zIndex: n.options.zIndex }),
                      n.$slides
                        .eq(t)
                        .animate(
                          { opacity: 1 },
                          n.options.speed,
                          n.options.easing,
                          e
                        ))
                    : (n.applyTransition(t),
                      n.$slides
                        .eq(t)
                        .css({ opacity: 1, zIndex: n.options.zIndex }),
                      e &&
                        setTimeout(function () {
                          n.disableTransition(t), e.call();
                        }, n.options.speed));
                }),
                (e.prototype.fadeSlideOut = function (t) {
                  var e = this;
                  !1 === e.cssTransitions
                    ? e.$slides
                        .eq(t)
                        .animate(
                          { opacity: 0, zIndex: e.options.zIndex - 2 },
                          e.options.speed,
                          e.options.easing
                        )
                    : (e.applyTransition(t),
                      e.$slides
                        .eq(t)
                        .css({ opacity: 0, zIndex: e.options.zIndex - 2 }));
                }),
                (e.prototype.filterSlides = e.prototype.slickFilter =
                  function (t) {
                    var e = this;
                    null !== t &&
                      ((e.$slidesCache = e.$slides),
                      e.unload(),
                      e.$slideTrack.children(this.options.slide).detach(),
                      e.$slidesCache.filter(t).appendTo(e.$slideTrack),
                      e.reinit());
                  }),
                (e.prototype.focusHandler = function () {
                  var e = this;
                  e.$slider
                    .off("focus.slick blur.slick")
                    .on("focus.slick blur.slick", "*", function (n) {
                      n.stopImmediatePropagation();
                      var i = t(this);
                      setTimeout(function () {
                        e.options.pauseOnFocus &&
                          ((e.focussed = i.is(":focus")), e.autoPlay());
                      }, 0);
                    });
                }),
                (e.prototype.getCurrent = e.prototype.slickCurrentSlide =
                  function () {
                    return this.currentSlide;
                  }),
                (e.prototype.getDotCount = function () {
                  var t = this,
                    e = 0,
                    n = 0,
                    i = 0;
                  if (!0 === t.options.infinite)
                    if (t.slideCount <= t.options.slidesToShow) ++i;
                    else
                      for (; e < t.slideCount; )
                        ++i,
                          (e = n + t.options.slidesToScroll),
                          (n +=
                            t.options.slidesToScroll <= t.options.slidesToShow
                              ? t.options.slidesToScroll
                              : t.options.slidesToShow);
                  else if (!0 === t.options.centerMode) i = t.slideCount;
                  else if (t.options.asNavFor)
                    for (; e < t.slideCount; )
                      ++i,
                        (e = n + t.options.slidesToScroll),
                        (n +=
                          t.options.slidesToScroll <= t.options.slidesToShow
                            ? t.options.slidesToScroll
                            : t.options.slidesToShow);
                  else
                    i =
                      1 +
                      Math.ceil(
                        (t.slideCount - t.options.slidesToShow) /
                          t.options.slidesToScroll
                      );
                  return i - 1;
                }),
                (e.prototype.getLeft = function (t) {
                  var e,
                    n,
                    i,
                    r,
                    s = this,
                    o = 0;
                  return (
                    (s.slideOffset = 0),
                    (n = s.$slides.first().outerHeight(!0)),
                    !0 === s.options.infinite
                      ? (s.slideCount > s.options.slidesToShow &&
                          ((s.slideOffset =
                            s.slideWidth * s.options.slidesToShow * -1),
                          (r = -1),
                          !0 === s.options.vertical &&
                            !0 === s.options.centerMode &&
                            (2 === s.options.slidesToShow
                              ? (r = -1.5)
                              : 1 === s.options.slidesToShow && (r = -2)),
                          (o = n * s.options.slidesToShow * r)),
                        s.slideCount % s.options.slidesToScroll != 0 &&
                          t + s.options.slidesToScroll > s.slideCount &&
                          s.slideCount > s.options.slidesToShow &&
                          (t > s.slideCount
                            ? ((s.slideOffset =
                                (s.options.slidesToShow - (t - s.slideCount)) *
                                s.slideWidth *
                                -1),
                              (o =
                                (s.options.slidesToShow - (t - s.slideCount)) *
                                n *
                                -1))
                            : ((s.slideOffset =
                                (s.slideCount % s.options.slidesToScroll) *
                                s.slideWidth *
                                -1),
                              (o =
                                (s.slideCount % s.options.slidesToScroll) *
                                n *
                                -1))))
                      : t + s.options.slidesToShow > s.slideCount &&
                        ((s.slideOffset =
                          (t + s.options.slidesToShow - s.slideCount) *
                          s.slideWidth),
                        (o = (t + s.options.slidesToShow - s.slideCount) * n)),
                    s.slideCount <= s.options.slidesToShow &&
                      ((s.slideOffset = 0), (o = 0)),
                    !0 === s.options.centerMode &&
                    s.slideCount <= s.options.slidesToShow
                      ? (s.slideOffset =
                          (s.slideWidth * Math.floor(s.options.slidesToShow)) /
                            2 -
                          (s.slideWidth * s.slideCount) / 2)
                      : !0 === s.options.centerMode && !0 === s.options.infinite
                      ? (s.slideOffset +=
                          s.slideWidth *
                            Math.floor(s.options.slidesToShow / 2) -
                          s.slideWidth)
                      : !0 === s.options.centerMode &&
                        ((s.slideOffset = 0),
                        (s.slideOffset +=
                          s.slideWidth *
                          Math.floor(s.options.slidesToShow / 2))),
                    (e =
                      !1 === s.options.vertical
                        ? t * s.slideWidth * -1 + s.slideOffset
                        : t * n * -1 + o),
                    !0 === s.options.variableWidth &&
                      ((i =
                        s.slideCount <= s.options.slidesToShow ||
                        !1 === s.options.infinite
                          ? s.$slideTrack.children(".slick-slide").eq(t)
                          : s.$slideTrack
                              .children(".slick-slide")
                              .eq(t + s.options.slidesToShow)),
                      (e =
                        !0 === s.options.rtl
                          ? i[0]
                            ? -1 *
                              (s.$slideTrack.width() -
                                i[0].offsetLeft -
                                i.width())
                            : 0
                          : i[0]
                          ? -1 * i[0].offsetLeft
                          : 0),
                      !0 === s.options.centerMode &&
                        ((i =
                          s.slideCount <= s.options.slidesToShow ||
                          !1 === s.options.infinite
                            ? s.$slideTrack.children(".slick-slide").eq(t)
                            : s.$slideTrack
                                .children(".slick-slide")
                                .eq(t + s.options.slidesToShow + 1)),
                        (e =
                          !0 === s.options.rtl
                            ? i[0]
                              ? -1 *
                                (s.$slideTrack.width() -
                                  i[0].offsetLeft -
                                  i.width())
                              : 0
                            : i[0]
                            ? -1 * i[0].offsetLeft
                            : 0),
                        (e += (s.$list.width() - i.outerWidth()) / 2))),
                    e
                  );
                }),
                (e.prototype.getOption = e.prototype.slickGetOption =
                  function (t) {
                    return this.options[t];
                  }),
                (e.prototype.getNavigableIndexes = function () {
                  var t,
                    e = this,
                    n = 0,
                    i = 0,
                    r = [];
                  for (
                    !1 === e.options.infinite
                      ? (t = e.slideCount)
                      : ((n = -1 * e.options.slidesToScroll),
                        (i = -1 * e.options.slidesToScroll),
                        (t = 2 * e.slideCount));
                    n < t;

                  )
                    r.push(n),
                      (n = i + e.options.slidesToScroll),
                      (i +=
                        e.options.slidesToScroll <= e.options.slidesToShow
                          ? e.options.slidesToScroll
                          : e.options.slidesToShow);
                  return r;
                }),
                (e.prototype.getSlick = function () {
                  return this;
                }),
                (e.prototype.getSlideCount = function () {
                  var e,
                    n,
                    i = this;
                  return (
                    (n =
                      !0 === i.options.centerMode
                        ? i.slideWidth * Math.floor(i.options.slidesToShow / 2)
                        : 0),
                    !0 === i.options.swipeToSlide
                      ? (i.$slideTrack
                          .find(".slick-slide")
                          .each(function (r, s) {
                            if (
                              s.offsetLeft - n + t(s).outerWidth() / 2 >
                              -1 * i.swipeLeft
                            )
                              return (e = s), !1;
                          }),
                        Math.abs(
                          t(e).attr("data-slick-index") - i.currentSlide
                        ) || 1)
                      : i.options.slidesToScroll
                  );
                }),
                (e.prototype.goTo = e.prototype.slickGoTo =
                  function (t, e) {
                    this.changeSlide(
                      { data: { message: "index", index: parseInt(t) } },
                      e
                    );
                  }),
                (e.prototype.init = function (e) {
                  var n = this;
                  t(n.$slider).hasClass("slick-initialized") ||
                    (t(n.$slider).addClass("slick-initialized"),
                    n.buildRows(),
                    n.buildOut(),
                    n.setProps(),
                    n.startLoad(),
                    n.loadSlider(),
                    n.initializeEvents(),
                    n.updateArrows(),
                    n.updateDots(),
                    n.checkResponsive(!0),
                    n.focusHandler()),
                    e && n.$slider.trigger("init", [n]),
                    !0 === n.options.accessibility && n.initADA(),
                    n.options.autoplay && ((n.paused = !1), n.autoPlay());
                }),
                (e.prototype.initADA = function () {
                  var e = this,
                    n = Math.ceil(e.slideCount / e.options.slidesToShow),
                    i = e.getNavigableIndexes().filter(function (t) {
                      return t >= 0 && t < e.slideCount;
                    });
                  e.$slides
                    .add(e.$slideTrack.find(".slick-cloned"))
                    .attr({ "aria-hidden": "true", tabindex: "-1" })
                    .find("a, input, button, select")
                    .attr({ tabindex: "-1" }),
                    null !== e.$dots &&
                      (e.$slides
                        .not(e.$slideTrack.find(".slick-cloned"))
                        .each(function (n) {
                          var r = i.indexOf(n);
                          if (
                            (t(this).attr({
                              role: "tabpanel",
                              id: "slick-slide" + e.instanceUid + n,
                              tabindex: -1,
                            }),
                            -1 !== r)
                          ) {
                            var s = "slick-slide-control" + e.instanceUid + r;
                            t("#" + s).length &&
                              t(this).attr({ "aria-describedby": s });
                          }
                        }),
                      e.$dots
                        .attr("role", "tablist")
                        .find("li")
                        .each(function (r) {
                          var s = i[r];
                          t(this).attr({ role: "presentation" }),
                            t(this)
                              .find("button")
                              .first()
                              .attr({
                                role: "tab",
                                id: "slick-slide-control" + e.instanceUid + r,
                                "aria-controls":
                                  "slick-slide" + e.instanceUid + s,
                                "aria-label": r + 1 + " of " + n,
                                "aria-selected": null,
                                tabindex: "-1",
                              });
                        })
                        .eq(e.currentSlide)
                        .find("button")
                        .attr({ "aria-selected": "true", tabindex: "0" })
                        .end());
                  for (
                    var r = e.currentSlide, s = r + e.options.slidesToShow;
                    r < s;
                    r++
                  )
                    e.options.focusOnChange
                      ? e.$slides.eq(r).attr({ tabindex: "0" })
                      : e.$slides.eq(r).removeAttr("tabindex");
                  e.activateADA();
                }),
                (e.prototype.initArrowEvents = function () {
                  var t = this;
                  !0 === t.options.arrows &&
                    t.slideCount > t.options.slidesToShow &&
                    (t.$prevArrow
                      .off("click.slick")
                      .on(
                        "click.slick",
                        { message: "previous" },
                        t.changeSlide
                      ),
                    t.$nextArrow
                      .off("click.slick")
                      .on("click.slick", { message: "next" }, t.changeSlide),
                    !0 === t.options.accessibility &&
                      (t.$prevArrow.on("keydown.slick", t.keyHandler),
                      t.$nextArrow.on("keydown.slick", t.keyHandler)));
                }),
                (e.prototype.initDotEvents = function () {
                  var e = this;
                  !0 === e.options.dots &&
                    e.slideCount > e.options.slidesToShow &&
                    (t("li", e.$dots).on(
                      "click.slick",
                      { message: "index" },
                      e.changeSlide
                    ),
                    !0 === e.options.accessibility &&
                      e.$dots.on("keydown.slick", e.keyHandler)),
                    !0 === e.options.dots &&
                      !0 === e.options.pauseOnDotsHover &&
                      e.slideCount > e.options.slidesToShow &&
                      t("li", e.$dots)
                        .on("mouseenter.slick", t.proxy(e.interrupt, e, !0))
                        .on("mouseleave.slick", t.proxy(e.interrupt, e, !1));
                }),
                (e.prototype.initSlideEvents = function () {
                  var e = this;
                  e.options.pauseOnHover &&
                    (e.$list.on(
                      "mouseenter.slick",
                      t.proxy(e.interrupt, e, !0)
                    ),
                    e.$list.on(
                      "mouseleave.slick",
                      t.proxy(e.interrupt, e, !1)
                    ));
                }),
                (e.prototype.initializeEvents = function () {
                  var e = this;
                  e.initArrowEvents(),
                    e.initDotEvents(),
                    e.initSlideEvents(),
                    e.$list.on(
                      "touchstart.slick mousedown.slick",
                      { action: "start" },
                      e.swipeHandler
                    ),
                    e.$list.on(
                      "touchmove.slick mousemove.slick",
                      { action: "move" },
                      e.swipeHandler
                    ),
                    e.$list.on(
                      "touchend.slick mouseup.slick",
                      { action: "end" },
                      e.swipeHandler
                    ),
                    e.$list.on(
                      "touchcancel.slick mouseleave.slick",
                      { action: "end" },
                      e.swipeHandler
                    ),
                    e.$list.on("click.slick", e.clickHandler),
                    t(document).on(
                      e.visibilityChange,
                      t.proxy(e.visibility, e)
                    ),
                    !0 === e.options.accessibility &&
                      e.$list.on("keydown.slick", e.keyHandler),
                    !0 === e.options.focusOnSelect &&
                      t(e.$slideTrack)
                        .children()
                        .on("click.slick", e.selectHandler),
                    t(window).on(
                      "orientationchange.slick.slick-" + e.instanceUid,
                      t.proxy(e.orientationChange, e)
                    ),
                    t(window).on(
                      "resize.slick.slick-" + e.instanceUid,
                      t.proxy(e.resize, e)
                    ),
                    t("[draggable!=true]", e.$slideTrack).on(
                      "dragstart",
                      e.preventDefault
                    ),
                    t(window).on(
                      "load.slick.slick-" + e.instanceUid,
                      e.setPosition
                    ),
                    t(e.setPosition);
                }),
                (e.prototype.initUI = function () {
                  var t = this;
                  !0 === t.options.arrows &&
                    t.slideCount > t.options.slidesToShow &&
                    (t.$prevArrow.show(), t.$nextArrow.show()),
                    !0 === t.options.dots &&
                      t.slideCount > t.options.slidesToShow &&
                      t.$dots.show();
                }),
                (e.prototype.keyHandler = function (t) {
                  var e = this;
                  t.target.tagName.match("TEXTAREA|INPUT|SELECT") ||
                    (37 === t.keyCode && !0 === e.options.accessibility
                      ? e.changeSlide({
                          data: {
                            message: !0 === e.options.rtl ? "next" : "previous",
                          },
                        })
                      : 39 === t.keyCode &&
                        !0 === e.options.accessibility &&
                        e.changeSlide({
                          data: {
                            message: !0 === e.options.rtl ? "previous" : "next",
                          },
                        }));
                }),
                (e.prototype.lazyLoad = function () {
                  var e,
                    n,
                    i,
                    r = this;
                  function s(e) {
                    t("img[data-lazy]", e).each(function () {
                      var e = t(this),
                        n = t(this).attr("data-lazy"),
                        i = t(this).attr("data-srcset"),
                        s =
                          t(this).attr("data-sizes") ||
                          r.$slider.attr("data-sizes"),
                        o = document.createElement("img");
                      (o.onload = function () {
                        e.animate({ opacity: 0 }, 100, function () {
                          i && (e.attr("srcset", i), s && e.attr("sizes", s)),
                            e
                              .attr("src", n)
                              .animate({ opacity: 1 }, 200, function () {
                                e.removeAttr(
                                  "data-lazy data-srcset data-sizes"
                                ).removeClass("slick-loading");
                              }),
                            r.$slider.trigger("lazyLoaded", [r, e, n]);
                        });
                      }),
                        (o.onerror = function () {
                          e
                            .removeAttr("data-lazy")
                            .removeClass("slick-loading")
                            .addClass("slick-lazyload-error"),
                            r.$slider.trigger("lazyLoadError", [r, e, n]);
                        }),
                        (o.src = n);
                    });
                  }
                  if (
                    (!0 === r.options.centerMode
                      ? !0 === r.options.infinite
                        ? (i =
                            (n =
                              r.currentSlide +
                              (r.options.slidesToShow / 2 + 1)) +
                            r.options.slidesToShow +
                            2)
                        : ((n = Math.max(
                            0,
                            r.currentSlide - (r.options.slidesToShow / 2 + 1)
                          )),
                          (i =
                            r.options.slidesToShow / 2 +
                            1 +
                            2 +
                            r.currentSlide))
                      : ((n = r.options.infinite
                          ? r.options.slidesToShow + r.currentSlide
                          : r.currentSlide),
                        (i = Math.ceil(n + r.options.slidesToShow)),
                        !0 === r.options.fade &&
                          (n > 0 && n--, i <= r.slideCount && i++)),
                    (e = r.$slider.find(".slick-slide").slice(n, i)),
                    "anticipated" === r.options.lazyLoad)
                  )
                    for (
                      var o = n - 1,
                        a = i,
                        l = r.$slider.find(".slick-slide"),
                        c = 0;
                      c < r.options.slidesToScroll;
                      c++
                    )
                      o < 0 && (o = r.slideCount - 1),
                        (e = (e = e.add(l.eq(o))).add(l.eq(a))),
                        o--,
                        a++;
                  s(e),
                    r.slideCount <= r.options.slidesToShow
                      ? s(r.$slider.find(".slick-slide"))
                      : r.currentSlide >= r.slideCount - r.options.slidesToShow
                      ? s(
                          r.$slider
                            .find(".slick-cloned")
                            .slice(0, r.options.slidesToShow)
                        )
                      : 0 === r.currentSlide &&
                        s(
                          r.$slider
                            .find(".slick-cloned")
                            .slice(-1 * r.options.slidesToShow)
                        );
                }),
                (e.prototype.loadSlider = function () {
                  var t = this;
                  t.setPosition(),
                    t.$slideTrack.css({ opacity: 1 }),
                    t.$slider.removeClass("slick-loading"),
                    t.initUI(),
                    "progressive" === t.options.lazyLoad &&
                      t.progressiveLazyLoad();
                }),
                (e.prototype.next = e.prototype.slickNext =
                  function () {
                    this.changeSlide({ data: { message: "next" } });
                  }),
                (e.prototype.orientationChange = function () {
                  this.checkResponsive(), this.setPosition();
                }),
                (e.prototype.pause = e.prototype.slickPause =
                  function () {
                    this.autoPlayClear(), (this.paused = !0);
                  }),
                (e.prototype.play = e.prototype.slickPlay =
                  function () {
                    var t = this;
                    t.autoPlay(),
                      (t.options.autoplay = !0),
                      (t.paused = !1),
                      (t.focussed = !1),
                      (t.interrupted = !1);
                  }),
                (e.prototype.postSlide = function (e) {
                  var n = this;
                  n.unslicked ||
                    (n.$slider.trigger("afterChange", [n, e]),
                    (n.animating = !1),
                    n.slideCount > n.options.slidesToShow && n.setPosition(),
                    (n.swipeLeft = null),
                    n.options.autoplay && n.autoPlay(),
                    !0 === n.options.accessibility &&
                      (n.initADA(),
                      n.options.focusOnChange &&
                        t(n.$slides.get(n.currentSlide))
                          .attr("tabindex", 0)
                          .focus()));
                }),
                (e.prototype.prev = e.prototype.slickPrev =
                  function () {
                    this.changeSlide({ data: { message: "previous" } });
                  }),
                (e.prototype.preventDefault = function (t) {
                  t.preventDefault();
                }),
                (e.prototype.progressiveLazyLoad = function (e) {
                  e = e || 1;
                  var n,
                    i,
                    r,
                    s,
                    o,
                    a = this,
                    l = t("img[data-lazy]", a.$slider);
                  l.length
                    ? ((n = l.first()),
                      (i = n.attr("data-lazy")),
                      (r = n.attr("data-srcset")),
                      (s =
                        n.attr("data-sizes") || a.$slider.attr("data-sizes")),
                      ((o = document.createElement("img")).onload =
                        function () {
                          r && (n.attr("srcset", r), s && n.attr("sizes", s)),
                            n
                              .attr("src", i)
                              .removeAttr("data-lazy data-srcset data-sizes")
                              .removeClass("slick-loading"),
                            !0 === a.options.adaptiveHeight && a.setPosition(),
                            a.$slider.trigger("lazyLoaded", [a, n, i]),
                            a.progressiveLazyLoad();
                        }),
                      (o.onerror = function () {
                        e < 3
                          ? setTimeout(function () {
                              a.progressiveLazyLoad(e + 1);
                            }, 500)
                          : (n
                              .removeAttr("data-lazy")
                              .removeClass("slick-loading")
                              .addClass("slick-lazyload-error"),
                            a.$slider.trigger("lazyLoadError", [a, n, i]),
                            a.progressiveLazyLoad());
                      }),
                      (o.src = i))
                    : a.$slider.trigger("allImagesLoaded", [a]);
                }),
                (e.prototype.refresh = function (e) {
                  var n,
                    i,
                    r = this;
                  (i = r.slideCount - r.options.slidesToShow),
                    !r.options.infinite &&
                      r.currentSlide > i &&
                      (r.currentSlide = i),
                    r.slideCount <= r.options.slidesToShow &&
                      (r.currentSlide = 0),
                    (n = r.currentSlide),
                    r.destroy(!0),
                    t.extend(r, r.initials, { currentSlide: n }),
                    r.init(),
                    e ||
                      r.changeSlide(
                        { data: { message: "index", index: n } },
                        !1
                      );
                }),
                (e.prototype.registerBreakpoints = function () {
                  var e,
                    n,
                    i,
                    r = this,
                    s = r.options.responsive || null;
                  if ("array" === t.type(s) && s.length) {
                    for (e in ((r.respondTo = r.options.respondTo || "window"),
                    s))
                      if (
                        ((i = r.breakpoints.length - 1), s.hasOwnProperty(e))
                      ) {
                        for (n = s[e].breakpoint; i >= 0; )
                          r.breakpoints[i] &&
                            r.breakpoints[i] === n &&
                            r.breakpoints.splice(i, 1),
                            i--;
                        r.breakpoints.push(n),
                          (r.breakpointSettings[n] = s[e].settings);
                      }
                    r.breakpoints.sort(function (t, e) {
                      return r.options.mobileFirst ? t - e : e - t;
                    });
                  }
                }),
                (e.prototype.reinit = function () {
                  var e = this;
                  (e.$slides = e.$slideTrack
                    .children(e.options.slide)
                    .addClass("slick-slide")),
                    (e.slideCount = e.$slides.length),
                    e.currentSlide >= e.slideCount &&
                      0 !== e.currentSlide &&
                      (e.currentSlide =
                        e.currentSlide - e.options.slidesToScroll),
                    e.slideCount <= e.options.slidesToShow &&
                      (e.currentSlide = 0),
                    e.registerBreakpoints(),
                    e.setProps(),
                    e.setupInfinite(),
                    e.buildArrows(),
                    e.updateArrows(),
                    e.initArrowEvents(),
                    e.buildDots(),
                    e.updateDots(),
                    e.initDotEvents(),
                    e.cleanUpSlideEvents(),
                    e.initSlideEvents(),
                    e.checkResponsive(!1, !0),
                    !0 === e.options.focusOnSelect &&
                      t(e.$slideTrack)
                        .children()
                        .on("click.slick", e.selectHandler),
                    e.setSlideClasses(
                      "number" == typeof e.currentSlide ? e.currentSlide : 0
                    ),
                    e.setPosition(),
                    e.focusHandler(),
                    (e.paused = !e.options.autoplay),
                    e.autoPlay(),
                    e.$slider.trigger("reInit", [e]);
                }),
                (e.prototype.resize = function () {
                  var e = this;
                  t(window).width() !== e.windowWidth &&
                    (clearTimeout(e.windowDelay),
                    (e.windowDelay = window.setTimeout(function () {
                      (e.windowWidth = t(window).width()),
                        e.checkResponsive(),
                        e.unslicked || e.setPosition();
                    }, 50)));
                }),
                (e.prototype.removeSlide = e.prototype.slickRemove =
                  function (t, e, n) {
                    var i = this;
                    if (
                      ((t =
                        "boolean" == typeof t
                          ? !0 === (e = t)
                            ? 0
                            : i.slideCount - 1
                          : !0 === e
                          ? --t
                          : t),
                      i.slideCount < 1 || t < 0 || t > i.slideCount - 1)
                    )
                      return !1;
                    i.unload(),
                      !0 === n
                        ? i.$slideTrack.children().remove()
                        : i.$slideTrack
                            .children(this.options.slide)
                            .eq(t)
                            .remove(),
                      (i.$slides = i.$slideTrack.children(this.options.slide)),
                      i.$slideTrack.children(this.options.slide).detach(),
                      i.$slideTrack.append(i.$slides),
                      (i.$slidesCache = i.$slides),
                      i.reinit();
                  }),
                (e.prototype.setCSS = function (t) {
                  var e,
                    n,
                    i = this,
                    r = {};
                  !0 === i.options.rtl && (t = -t),
                    (e =
                      "left" == i.positionProp ? Math.ceil(t) + "px" : "0px"),
                    (n = "top" == i.positionProp ? Math.ceil(t) + "px" : "0px"),
                    (r[i.positionProp] = t),
                    !1 === i.transformsEnabled
                      ? i.$slideTrack.css(r)
                      : ((r = {}),
                        !1 === i.cssTransitions
                          ? ((r[i.animType] =
                              "translate(" + e + ", " + n + ")"),
                            i.$slideTrack.css(r))
                          : ((r[i.animType] =
                              "translate3d(" + e + ", " + n + ", 0px)"),
                            i.$slideTrack.css(r)));
                }),
                (e.prototype.setDimensions = function () {
                  var t = this;
                  !1 === t.options.vertical
                    ? !0 === t.options.centerMode &&
                      t.$list.css({ padding: "0px " + t.options.centerPadding })
                    : (t.$list.height(
                        t.$slides.first().outerHeight(!0) *
                          t.options.slidesToShow
                      ),
                      !0 === t.options.centerMode &&
                        t.$list.css({
                          padding: t.options.centerPadding + " 0px",
                        })),
                    (t.listWidth = t.$list.width()),
                    (t.listHeight = t.$list.height()),
                    !1 === t.options.vertical && !1 === t.options.variableWidth
                      ? ((t.slideWidth = Math.ceil(
                          t.listWidth / t.options.slidesToShow
                        )),
                        t.$slideTrack.width(
                          Math.ceil(
                            t.slideWidth *
                              t.$slideTrack.children(".slick-slide").length
                          )
                        ))
                      : !0 === t.options.variableWidth
                      ? t.$slideTrack.width(5e3 * t.slideCount)
                      : ((t.slideWidth = Math.ceil(t.listWidth)),
                        t.$slideTrack.height(
                          Math.ceil(
                            t.$slides.first().outerHeight(!0) *
                              t.$slideTrack.children(".slick-slide").length
                          )
                        ));
                  var e =
                    t.$slides.first().outerWidth(!0) -
                    t.$slides.first().width();
                  !1 === t.options.variableWidth &&
                    t.$slideTrack
                      .children(".slick-slide")
                      .width(t.slideWidth - e);
                }),
                (e.prototype.setFade = function () {
                  var e,
                    n = this;
                  n.$slides.each(function (i, r) {
                    (e = n.slideWidth * i * -1),
                      !0 === n.options.rtl
                        ? t(r).css({
                            position: "relative",
                            right: e,
                            top: 0,
                            zIndex: n.options.zIndex - 2,
                            opacity: 0,
                          })
                        : t(r).css({
                            position: "relative",
                            left: e,
                            top: 0,
                            zIndex: n.options.zIndex - 2,
                            opacity: 0,
                          });
                  }),
                    n.$slides
                      .eq(n.currentSlide)
                      .css({ zIndex: n.options.zIndex - 1, opacity: 1 });
                }),
                (e.prototype.setHeight = function () {
                  var t = this;
                  if (
                    1 === t.options.slidesToShow &&
                    !0 === t.options.adaptiveHeight &&
                    !1 === t.options.vertical
                  ) {
                    var e = t.$slides.eq(t.currentSlide).outerHeight(!0);
                    t.$list.css("height", e);
                  }
                }),
                (e.prototype.setOption = e.prototype.slickSetOption =
                  function () {
                    var e,
                      n,
                      i,
                      r,
                      s,
                      o = this,
                      a = !1;
                    if (
                      ("object" === t.type(arguments[0])
                        ? ((i = arguments[0]),
                          (a = arguments[1]),
                          (s = "multiple"))
                        : "string" === t.type(arguments[0]) &&
                          ((i = arguments[0]),
                          (r = arguments[1]),
                          (a = arguments[2]),
                          "responsive" === arguments[0] &&
                          "array" === t.type(arguments[1])
                            ? (s = "responsive")
                            : void 0 !== arguments[1] && (s = "single")),
                      "single" === s)
                    )
                      o.options[i] = r;
                    else if ("multiple" === s)
                      t.each(i, function (t, e) {
                        o.options[t] = e;
                      });
                    else if ("responsive" === s)
                      for (n in r)
                        if ("array" !== t.type(o.options.responsive))
                          o.options.responsive = [r[n]];
                        else {
                          for (e = o.options.responsive.length - 1; e >= 0; )
                            o.options.responsive[e].breakpoint ===
                              r[n].breakpoint &&
                              o.options.responsive.splice(e, 1),
                              e--;
                          o.options.responsive.push(r[n]);
                        }
                    a && (o.unload(), o.reinit());
                  }),
                (e.prototype.setPosition = function () {
                  var t = this;
                  t.setDimensions(),
                    t.setHeight(),
                    !1 === t.options.fade
                      ? t.setCSS(t.getLeft(t.currentSlide))
                      : t.setFade(),
                    t.$slider.trigger("setPosition", [t]);
                }),
                (e.prototype.setProps = function () {
                  var t = this,
                    e = document.body.style;
                  (t.positionProp = !0 === t.options.vertical ? "top" : "left"),
                    "top" === t.positionProp
                      ? t.$slider.addClass("slick-vertical")
                      : t.$slider.removeClass("slick-vertical"),
                    (void 0 === e.WebkitTransition &&
                      void 0 === e.MozTransition &&
                      void 0 === e.msTransition) ||
                      (!0 === t.options.useCSS && (t.cssTransitions = !0)),
                    t.options.fade &&
                      ("number" == typeof t.options.zIndex
                        ? t.options.zIndex < 3 && (t.options.zIndex = 3)
                        : (t.options.zIndex = t.defaults.zIndex)),
                    void 0 !== e.OTransform &&
                      ((t.animType = "OTransform"),
                      (t.transformType = "-o-transform"),
                      (t.transitionType = "OTransition"),
                      void 0 === e.perspectiveProperty &&
                        void 0 === e.webkitPerspective &&
                        (t.animType = !1)),
                    void 0 !== e.MozTransform &&
                      ((t.animType = "MozTransform"),
                      (t.transformType = "-moz-transform"),
                      (t.transitionType = "MozTransition"),
                      void 0 === e.perspectiveProperty &&
                        void 0 === e.MozPerspective &&
                        (t.animType = !1)),
                    void 0 !== e.webkitTransform &&
                      ((t.animType = "webkitTransform"),
                      (t.transformType = "-webkit-transform"),
                      (t.transitionType = "webkitTransition"),
                      void 0 === e.perspectiveProperty &&
                        void 0 === e.webkitPerspective &&
                        (t.animType = !1)),
                    void 0 !== e.msTransform &&
                      ((t.animType = "msTransform"),
                      (t.transformType = "-ms-transform"),
                      (t.transitionType = "msTransition"),
                      void 0 === e.msTransform && (t.animType = !1)),
                    void 0 !== e.transform &&
                      !1 !== t.animType &&
                      ((t.animType = "transform"),
                      (t.transformType = "transform"),
                      (t.transitionType = "transition")),
                    (t.transformsEnabled =
                      t.options.useTransform &&
                      null !== t.animType &&
                      !1 !== t.animType);
                }),
                (e.prototype.setSlideClasses = function (t) {
                  var e,
                    n,
                    i,
                    r,
                    s = this;
                  if (
                    ((n = s.$slider
                      .find(".slick-slide")
                      .removeClass("slick-active slick-center slick-current")
                      .attr("aria-hidden", "true")),
                    s.$slides.eq(t).addClass("slick-current"),
                    !0 === s.options.centerMode)
                  ) {
                    var o = s.options.slidesToShow % 2 == 0 ? 1 : 0;
                    (e = Math.floor(s.options.slidesToShow / 2)),
                      !0 === s.options.infinite &&
                        (t >= e && t <= s.slideCount - 1 - e
                          ? s.$slides
                              .slice(t - e + o, t + e + 1)
                              .addClass("slick-active")
                              .attr("aria-hidden", "false")
                          : ((i = s.options.slidesToShow + t),
                            n
                              .slice(i - e + 1 + o, i + e + 2)
                              .addClass("slick-active")
                              .attr("aria-hidden", "false")),
                        0 === t
                          ? n
                              .eq(n.length - 1 - s.options.slidesToShow)
                              .addClass("slick-center")
                          : t === s.slideCount - 1 &&
                            n
                              .eq(s.options.slidesToShow)
                              .addClass("slick-center")),
                      s.$slides.eq(t).addClass("slick-center");
                  } else
                    t >= 0 && t <= s.slideCount - s.options.slidesToShow
                      ? s.$slides
                          .slice(t, t + s.options.slidesToShow)
                          .addClass("slick-active")
                          .attr("aria-hidden", "false")
                      : n.length <= s.options.slidesToShow
                      ? n.addClass("slick-active").attr("aria-hidden", "false")
                      : ((r = s.slideCount % s.options.slidesToShow),
                        (i =
                          !0 === s.options.infinite
                            ? s.options.slidesToShow + t
                            : t),
                        s.options.slidesToShow == s.options.slidesToScroll &&
                        s.slideCount - t < s.options.slidesToShow
                          ? n
                              .slice(i - (s.options.slidesToShow - r), i + r)
                              .addClass("slick-active")
                              .attr("aria-hidden", "false")
                          : n
                              .slice(i, i + s.options.slidesToShow)
                              .addClass("slick-active")
                              .attr("aria-hidden", "false"));
                  ("ondemand" !== s.options.lazyLoad &&
                    "anticipated" !== s.options.lazyLoad) ||
                    s.lazyLoad();
                }),
                (e.prototype.setupInfinite = function () {
                  var e,
                    n,
                    i,
                    r = this;
                  if (
                    (!0 === r.options.fade && (r.options.centerMode = !1),
                    !0 === r.options.infinite &&
                      !1 === r.options.fade &&
                      ((n = null), r.slideCount > r.options.slidesToShow))
                  ) {
                    for (
                      i =
                        !0 === r.options.centerMode
                          ? r.options.slidesToShow + 1
                          : r.options.slidesToShow,
                        e = r.slideCount;
                      e > r.slideCount - i;
                      e -= 1
                    )
                      (n = e - 1),
                        t(r.$slides[n])
                          .clone(!0)
                          .attr("id", "")
                          .attr("data-slick-index", n - r.slideCount)
                          .prependTo(r.$slideTrack)
                          .addClass("slick-cloned");
                    for (e = 0; e < i + r.slideCount; e += 1)
                      (n = e),
                        t(r.$slides[n])
                          .clone(!0)
                          .attr("id", "")
                          .attr("data-slick-index", n + r.slideCount)
                          .appendTo(r.$slideTrack)
                          .addClass("slick-cloned");
                    r.$slideTrack
                      .find(".slick-cloned")
                      .find("[id]")
                      .each(function () {
                        t(this).attr("id", "");
                      });
                  }
                }),
                (e.prototype.interrupt = function (t) {
                  t || this.autoPlay(), (this.interrupted = t);
                }),
                (e.prototype.selectHandler = function (e) {
                  var n = this,
                    i = t(e.target).is(".slick-slide")
                      ? t(e.target)
                      : t(e.target).parents(".slick-slide"),
                    r = parseInt(i.attr("data-slick-index"));
                  r || (r = 0),
                    n.slideCount <= n.options.slidesToShow
                      ? n.slideHandler(r, !1, !0)
                      : n.slideHandler(r);
                }),
                (e.prototype.slideHandler = function (t, e, n) {
                  var i,
                    r,
                    s,
                    o,
                    a,
                    l,
                    c = this;
                  if (
                    ((e = e || !1),
                    !(
                      (!0 === c.animating && !0 === c.options.waitForAnimate) ||
                      (!0 === c.options.fade && c.currentSlide === t)
                    ))
                  )
                    if (
                      (!1 === e && c.asNavFor(t),
                      (i = t),
                      (a = c.getLeft(i)),
                      (o = c.getLeft(c.currentSlide)),
                      (c.currentLeft = null === c.swipeLeft ? o : c.swipeLeft),
                      !1 === c.options.infinite &&
                        !1 === c.options.centerMode &&
                        (t < 0 ||
                          t > c.getDotCount() * c.options.slidesToScroll))
                    )
                      !1 === c.options.fade &&
                        ((i = c.currentSlide),
                        !0 !== n && c.slideCount > c.options.slidesToShow
                          ? c.animateSlide(o, function () {
                              c.postSlide(i);
                            })
                          : c.postSlide(i));
                    else if (
                      !1 === c.options.infinite &&
                      !0 === c.options.centerMode &&
                      (t < 0 || t > c.slideCount - c.options.slidesToScroll)
                    )
                      !1 === c.options.fade &&
                        ((i = c.currentSlide),
                        !0 !== n && c.slideCount > c.options.slidesToShow
                          ? c.animateSlide(o, function () {
                              c.postSlide(i);
                            })
                          : c.postSlide(i));
                    else {
                      if (
                        (c.options.autoplay && clearInterval(c.autoPlayTimer),
                        (r =
                          i < 0
                            ? c.slideCount % c.options.slidesToScroll != 0
                              ? c.slideCount -
                                (c.slideCount % c.options.slidesToScroll)
                              : c.slideCount + i
                            : i >= c.slideCount
                            ? c.slideCount % c.options.slidesToScroll != 0
                              ? 0
                              : i - c.slideCount
                            : i),
                        (c.animating = !0),
                        c.$slider.trigger("beforeChange", [
                          c,
                          c.currentSlide,
                          r,
                        ]),
                        (s = c.currentSlide),
                        (c.currentSlide = r),
                        c.setSlideClasses(c.currentSlide),
                        c.options.asNavFor &&
                          (l = (l = c.getNavTarget()).slick("getSlick"))
                            .slideCount <= l.options.slidesToShow &&
                          l.setSlideClasses(c.currentSlide),
                        c.updateDots(),
                        c.updateArrows(),
                        !0 === c.options.fade)
                      )
                        return (
                          !0 !== n
                            ? (c.fadeSlideOut(s),
                              c.fadeSlide(r, function () {
                                c.postSlide(r);
                              }))
                            : c.postSlide(r),
                          void c.animateHeight()
                        );
                      !0 !== n && c.slideCount > c.options.slidesToShow
                        ? c.animateSlide(a, function () {
                            c.postSlide(r);
                          })
                        : c.postSlide(r);
                    }
                }),
                (e.prototype.startLoad = function () {
                  var t = this;
                  !0 === t.options.arrows &&
                    t.slideCount > t.options.slidesToShow &&
                    (t.$prevArrow.hide(), t.$nextArrow.hide()),
                    !0 === t.options.dots &&
                      t.slideCount > t.options.slidesToShow &&
                      t.$dots.hide(),
                    t.$slider.addClass("slick-loading");
                }),
                (e.prototype.swipeDirection = function () {
                  var t,
                    e,
                    n,
                    i,
                    r = this;
                  return (
                    (t = r.touchObject.startX - r.touchObject.curX),
                    (e = r.touchObject.startY - r.touchObject.curY),
                    (n = Math.atan2(e, t)),
                    (i = Math.round((180 * n) / Math.PI)) < 0 &&
                      (i = 360 - Math.abs(i)),
                    i <= 45 && i >= 0
                      ? !1 === r.options.rtl
                        ? "left"
                        : "right"
                      : i <= 360 && i >= 315
                      ? !1 === r.options.rtl
                        ? "left"
                        : "right"
                      : i >= 135 && i <= 225
                      ? !1 === r.options.rtl
                        ? "right"
                        : "left"
                      : !0 === r.options.verticalSwiping
                      ? i >= 35 && i <= 135
                        ? "down"
                        : "up"
                      : "vertical"
                  );
                }),
                (e.prototype.swipeEnd = function (t) {
                  var e,
                    n,
                    i = this;
                  if (((i.dragging = !1), (i.swiping = !1), i.scrolling))
                    return (i.scrolling = !1), !1;
                  if (
                    ((i.interrupted = !1),
                    (i.shouldClick = !(i.touchObject.swipeLength > 10)),
                    void 0 === i.touchObject.curX)
                  )
                    return !1;
                  if (
                    (!0 === i.touchObject.edgeHit &&
                      i.$slider.trigger("edge", [i, i.swipeDirection()]),
                    i.touchObject.swipeLength >= i.touchObject.minSwipe)
                  ) {
                    switch ((n = i.swipeDirection())) {
                      case "left":
                      case "down":
                        (e = i.options.swipeToSlide
                          ? i.checkNavigable(i.currentSlide + i.getSlideCount())
                          : i.currentSlide + i.getSlideCount()),
                          (i.currentDirection = 0);
                        break;
                      case "right":
                      case "up":
                        (e = i.options.swipeToSlide
                          ? i.checkNavigable(i.currentSlide - i.getSlideCount())
                          : i.currentSlide - i.getSlideCount()),
                          (i.currentDirection = 1);
                    }
                    "vertical" != n &&
                      (i.slideHandler(e),
                      (i.touchObject = {}),
                      i.$slider.trigger("swipe", [i, n]));
                  } else
                    i.touchObject.startX !== i.touchObject.curX &&
                      (i.slideHandler(i.currentSlide), (i.touchObject = {}));
                }),
                (e.prototype.swipeHandler = function (t) {
                  var e = this;
                  if (
                    !(
                      !1 === e.options.swipe ||
                      ("ontouchend" in document && !1 === e.options.swipe) ||
                      (!1 === e.options.draggable &&
                        -1 !== t.type.indexOf("mouse"))
                    )
                  )
                    switch (
                      ((e.touchObject.fingerCount =
                        t.originalEvent && void 0 !== t.originalEvent.touches
                          ? t.originalEvent.touches.length
                          : 1),
                      (e.touchObject.minSwipe =
                        e.listWidth / e.options.touchThreshold),
                      !0 === e.options.verticalSwiping &&
                        (e.touchObject.minSwipe =
                          e.listHeight / e.options.touchThreshold),
                      t.data.action)
                    ) {
                      case "start":
                        e.swipeStart(t);
                        break;
                      case "move":
                        e.swipeMove(t);
                        break;
                      case "end":
                        e.swipeEnd(t);
                    }
                }),
                (e.prototype.swipeMove = function (t) {
                  var e,
                    n,
                    i,
                    r,
                    s,
                    o,
                    a = this;
                  return (
                    (s =
                      void 0 !== t.originalEvent
                        ? t.originalEvent.touches
                        : null),
                    !(!a.dragging || a.scrolling || (s && 1 !== s.length)) &&
                      ((e = a.getLeft(a.currentSlide)),
                      (a.touchObject.curX =
                        void 0 !== s ? s[0].pageX : t.clientX),
                      (a.touchObject.curY =
                        void 0 !== s ? s[0].pageY : t.clientY),
                      (a.touchObject.swipeLength = Math.round(
                        Math.sqrt(
                          Math.pow(a.touchObject.curX - a.touchObject.startX, 2)
                        )
                      )),
                      (o = Math.round(
                        Math.sqrt(
                          Math.pow(a.touchObject.curY - a.touchObject.startY, 2)
                        )
                      )),
                      !a.options.verticalSwiping && !a.swiping && o > 4
                        ? ((a.scrolling = !0), !1)
                        : (!0 === a.options.verticalSwiping &&
                            (a.touchObject.swipeLength = o),
                          (n = a.swipeDirection()),
                          void 0 !== t.originalEvent &&
                            a.touchObject.swipeLength > 4 &&
                            ((a.swiping = !0), t.preventDefault()),
                          (r =
                            (!1 === a.options.rtl ? 1 : -1) *
                            (a.touchObject.curX > a.touchObject.startX
                              ? 1
                              : -1)),
                          !0 === a.options.verticalSwiping &&
                            (r =
                              a.touchObject.curY > a.touchObject.startY
                                ? 1
                                : -1),
                          (i = a.touchObject.swipeLength),
                          (a.touchObject.edgeHit = !1),
                          !1 === a.options.infinite &&
                            ((0 === a.currentSlide && "right" === n) ||
                              (a.currentSlide >= a.getDotCount() &&
                                "left" === n)) &&
                            ((i =
                              a.touchObject.swipeLength *
                              a.options.edgeFriction),
                            (a.touchObject.edgeHit = !0)),
                          !1 === a.options.vertical
                            ? (a.swipeLeft = e + i * r)
                            : (a.swipeLeft =
                                e + i * (a.$list.height() / a.listWidth) * r),
                          !0 === a.options.verticalSwiping &&
                            (a.swipeLeft = e + i * r),
                          !0 !== a.options.fade &&
                            !1 !== a.options.touchMove &&
                            (!0 === a.animating
                              ? ((a.swipeLeft = null), !1)
                              : void a.setCSS(a.swipeLeft))))
                  );
                }),
                (e.prototype.swipeStart = function (t) {
                  var e,
                    n = this;
                  if (
                    ((n.interrupted = !0),
                    1 !== n.touchObject.fingerCount ||
                      n.slideCount <= n.options.slidesToShow)
                  )
                    return (n.touchObject = {}), !1;
                  void 0 !== t.originalEvent &&
                    void 0 !== t.originalEvent.touches &&
                    (e = t.originalEvent.touches[0]),
                    (n.touchObject.startX = n.touchObject.curX =
                      void 0 !== e ? e.pageX : t.clientX),
                    (n.touchObject.startY = n.touchObject.curY =
                      void 0 !== e ? e.pageY : t.clientY),
                    (n.dragging = !0);
                }),
                (e.prototype.unfilterSlides = e.prototype.slickUnfilter =
                  function () {
                    var t = this;
                    null !== t.$slidesCache &&
                      (t.unload(),
                      t.$slideTrack.children(this.options.slide).detach(),
                      t.$slidesCache.appendTo(t.$slideTrack),
                      t.reinit());
                  }),
                (e.prototype.unload = function () {
                  var e = this;
                  t(".slick-cloned", e.$slider).remove(),
                    e.$dots && e.$dots.remove(),
                    e.$prevArrow &&
                      e.htmlExpr.test(e.options.prevArrow) &&
                      e.$prevArrow.remove(),
                    e.$nextArrow &&
                      e.htmlExpr.test(e.options.nextArrow) &&
                      e.$nextArrow.remove(),
                    e.$slides
                      .removeClass(
                        "slick-slide slick-active slick-visible slick-current"
                      )
                      .attr("aria-hidden", "true")
                      .css("width", "");
                }),
                (e.prototype.unslick = function (t) {
                  var e = this;
                  e.$slider.trigger("unslick", [e, t]), e.destroy();
                }),
                (e.prototype.updateArrows = function () {
                  var t = this;
                  Math.floor(t.options.slidesToShow / 2),
                    !0 === t.options.arrows &&
                      t.slideCount > t.options.slidesToShow &&
                      !t.options.infinite &&
                      (t.$prevArrow
                        .removeClass("slick-disabled")
                        .attr("aria-disabled", "false"),
                      t.$nextArrow
                        .removeClass("slick-disabled")
                        .attr("aria-disabled", "false"),
                      0 === t.currentSlide
                        ? (t.$prevArrow
                            .addClass("slick-disabled")
                            .attr("aria-disabled", "true"),
                          t.$nextArrow
                            .removeClass("slick-disabled")
                            .attr("aria-disabled", "false"))
                        : t.currentSlide >=
                            t.slideCount - t.options.slidesToShow &&
                          !1 === t.options.centerMode
                        ? (t.$nextArrow
                            .addClass("slick-disabled")
                            .attr("aria-disabled", "true"),
                          t.$prevArrow
                            .removeClass("slick-disabled")
                            .attr("aria-disabled", "false"))
                        : t.currentSlide >= t.slideCount - 1 &&
                          !0 === t.options.centerMode &&
                          (t.$nextArrow
                            .addClass("slick-disabled")
                            .attr("aria-disabled", "true"),
                          t.$prevArrow
                            .removeClass("slick-disabled")
                            .attr("aria-disabled", "false")));
                }),
                (e.prototype.updateDots = function () {
                  var t = this;
                  null !== t.$dots &&
                    (t.$dots.find("li").removeClass("slick-active").end(),
                    t.$dots
                      .find("li")
                      .eq(Math.floor(t.currentSlide / t.options.slidesToScroll))
                      .addClass("slick-active"));
                }),
                (e.prototype.visibility = function () {
                  var t = this;
                  t.options.autoplay &&
                    (document[t.hidden]
                      ? (t.interrupted = !0)
                      : (t.interrupted = !1));
                }),
                (t.fn.slick = function () {
                  var t,
                    n,
                    i = this,
                    r = arguments[0],
                    s = Array.prototype.slice.call(arguments, 1),
                    o = i.length;
                  for (t = 0; t < o; t++)
                    if (
                      ("object" == typeof r || void 0 === r
                        ? (i[t].slick = new e(i[t], r))
                        : (n = i[t].slick[r].apply(i[t].slick, s)),
                      void 0 !== n)
                    )
                      return n;
                  return i;
                });
              var n;
            })
              ? i.apply(e, r)
              : i) || (t.exports = s);
    })();
  },
  "aET+": function (t, e, n) {
    var i,
      r,
      s = {},
      o =
        ((i = function () {
          return window && document && document.all && !window.atob;
        }),
        function () {
          return void 0 === r && (r = i.apply(this, arguments)), r;
        }),
      a = function (t, e) {
        return e ? e.querySelector(t) : document.querySelector(t);
      },
      l = (function (t) {
        var e = {};
        return function (t, n) {
          if ("function" == typeof t) return t();
          if (void 0 === e[t]) {
            var i = a.call(this, t, n);
            if (
              window.HTMLIFrameElement &&
              i instanceof window.HTMLIFrameElement
            )
              try {
                i = i.contentDocument.head;
              } catch (t) {
                i = null;
              }
            e[t] = i;
          }
          return e[t];
        };
      })(),
      c = null,
      u = 0,
      h = [],
      d = n("9tPo");
    function p(t, e) {
      for (var n = 0; n < t.length; n++) {
        var i = t[n],
          r = s[i.id];
        if (r) {
          r.refs++;
          for (var o = 0; o < r.parts.length; o++) r.parts[o](i.parts[o]);
          for (; o < i.parts.length; o++) r.parts.push(x(i.parts[o], e));
        } else {
          var a = [];
          for (o = 0; o < i.parts.length; o++) a.push(x(i.parts[o], e));
          s[i.id] = { id: i.id, refs: 1, parts: a };
        }
      }
    }
    function f(t, e) {
      for (var n = [], i = {}, r = 0; r < t.length; r++) {
        var s = t[r],
          o = e.base ? s[0] + e.base : s[0],
          a = { css: s[1], media: s[2], sourceMap: s[3] };
        i[o] ? i[o].parts.push(a) : n.push((i[o] = { id: o, parts: [a] }));
      }
      return n;
    }
    function m(t, e) {
      var n = l(t.insertInto);
      if (!n)
        throw new Error(
          "Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid."
        );
      var i = h[h.length - 1];
      if ("top" === t.insertAt)
        i
          ? i.nextSibling
            ? n.insertBefore(e, i.nextSibling)
            : n.appendChild(e)
          : n.insertBefore(e, n.firstChild),
          h.push(e);
      else if ("bottom" === t.insertAt) n.appendChild(e);
      else {
        if ("object" != typeof t.insertAt || !t.insertAt.before)
          throw new Error(
            "[Style Loader]\n\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\n Must be 'top', 'bottom', or Object.\n (https://github.com/webpack-contrib/style-loader#insertat)\n"
          );
        var r = l(t.insertAt.before, n);
        n.insertBefore(e, r);
      }
    }
    function g(t) {
      if (null === t.parentNode) return !1;
      t.parentNode.removeChild(t);
      var e = h.indexOf(t);
      e >= 0 && h.splice(e, 1);
    }
    function v(t) {
      var e = document.createElement("style");
      if (
        (void 0 === t.attrs.type && (t.attrs.type = "text/css"),
        void 0 === t.attrs.nonce)
      ) {
        var i = (function () {
          0;
          return n.nc;
        })();
        i && (t.attrs.nonce = i);
      }
      return y(e, t.attrs), m(t, e), e;
    }
    function y(t, e) {
      Object.keys(e).forEach(function (n) {
        t.setAttribute(n, e[n]);
      });
    }
    function x(t, e) {
      var n, i, r, s;
      if (e.transform && t.css) {
        if (
          !(s =
            "function" == typeof e.transform
              ? e.transform(t.css)
              : e.transform.default(t.css))
        )
          return function () {};
        t.css = s;
      }
      if (e.singleton) {
        var o = u++;
        (n = c || (c = v(e))),
          (i = w.bind(null, n, o, !1)),
          (r = w.bind(null, n, o, !0));
      } else
        t.sourceMap &&
        "function" == typeof URL &&
        "function" == typeof URL.createObjectURL &&
        "function" == typeof URL.revokeObjectURL &&
        "function" == typeof Blob &&
        "function" == typeof btoa
          ? ((n = (function (t) {
              var e = document.createElement("link");
              return (
                void 0 === t.attrs.type && (t.attrs.type = "text/css"),
                (t.attrs.rel = "stylesheet"),
                y(e, t.attrs),
                m(t, e),
                e
              );
            })(e)),
            (i = M.bind(null, n, e)),
            (r = function () {
              g(n), n.href && URL.revokeObjectURL(n.href);
            }))
          : ((n = v(e)),
            (i = S.bind(null, n)),
            (r = function () {
              g(n);
            }));
      return (
        i(t),
        function (e) {
          if (e) {
            if (
              e.css === t.css &&
              e.media === t.media &&
              e.sourceMap === t.sourceMap
            )
              return;
            i((t = e));
          } else r();
        }
      );
    }
    t.exports = function (t, e) {
      if ("undefined" != typeof DEBUG && DEBUG && "object" != typeof document)
        throw new Error(
          "The style-loader cannot be used in a non-browser environment"
        );
      ((e = e || {}).attrs = "object" == typeof e.attrs ? e.attrs : {}),
        e.singleton || "boolean" == typeof e.singleton || (e.singleton = o()),
        e.insertInto || (e.insertInto = "head"),
        e.insertAt || (e.insertAt = "bottom");
      var n = f(t, e);
      return (
        p(n, e),
        function (t) {
          for (var i = [], r = 0; r < n.length; r++) {
            var o = n[r];
            (a = s[o.id]).refs--, i.push(a);
          }
          t && p(f(t, e), e);
          for (r = 0; r < i.length; r++) {
            var a;
            if (0 === (a = i[r]).refs) {
              for (var l = 0; l < a.parts.length; l++) a.parts[l]();
              delete s[a.id];
            }
          }
        }
      );
    };
    var b,
      _ =
        ((b = []),
        function (t, e) {
          return (b[t] = e), b.filter(Boolean).join("\n");
        });
    function w(t, e, n, i) {
      var r = n ? "" : i.css;
      if (t.styleSheet) t.styleSheet.cssText = _(e, r);
      else {
        var s = document.createTextNode(r),
          o = t.childNodes;
        o[e] && t.removeChild(o[e]),
          o.length ? t.insertBefore(s, o[e]) : t.appendChild(s);
      }
    }
    function S(t, e) {
      var n = e.css,
        i = e.media;
      if ((i && t.setAttribute("media", i), t.styleSheet))
        t.styleSheet.cssText = n;
      else {
        for (; t.firstChild; ) t.removeChild(t.firstChild);
        t.appendChild(document.createTextNode(n));
      }
    }
    function M(t, e, n) {
      var i = n.css,
        r = n.sourceMap,
        s = void 0 === e.convertToAbsoluteUrls && r;
      (e.convertToAbsoluteUrls || s) && (i = d(i)),
        r &&
          (i +=
            "\n/*# sourceMappingURL=data:application/json;base64," +
            btoa(unescape(encodeURIComponent(JSON.stringify(r)))) +
            " */");
      var o = new Blob([i], { type: "text/css" }),
        a = t.href;
      (t.href = URL.createObjectURL(o)), a && URL.revokeObjectURL(a);
    }
  },
  endd: function (t, e, n) {
    "use strict";
    function i(t) {
      this.message = t;
    }
    (i.prototype.toString = function () {
      return "Cancel" + (this.message ? ": " + this.message : "");
    }),
      (i.prototype.__CANCEL__ = !0),
      (t.exports = i);
  },
  eqyj: function (t, e, n) {
    "use strict";
    var i = n("xTJ+");
    t.exports = i.isStandardBrowserEnv()
      ? {
          write: function (t, e, n, r, s, o) {
            var a = [];
            a.push(t + "=" + encodeURIComponent(e)),
              i.isNumber(n) && a.push("expires=" + new Date(n).toGMTString()),
              i.isString(r) && a.push("path=" + r),
              i.isString(s) && a.push("domain=" + s),
              !0 === o && a.push("secure"),
              (document.cookie = a.join("; "));
          },
          read: function (t) {
            var e = document.cookie.match(
              new RegExp("(^|;\\s*)(" + t + ")=([^;]*)")
            );
            return e ? decodeURIComponent(e[3]) : null;
          },
          remove: function (t) {
            this.write(t, "", Date.now() - 864e5);
          },
        }
      : {
          write: function () {},
          read: function () {
            return null;
          },
          remove: function () {},
        };
  },
  g7np: function (t, e, n) {
    "use strict";
    var i = n("2SVd"),
      r = n("5oMp");
    t.exports = function (t, e) {
      return t && !i(e) ? r(t, e) : e;
    };
  },
  hIuj: function (t, e, n) {
    "use strict";
    var i = n("SgzI"),
      r = {};
    ["object", "boolean", "number", "function", "string", "symbol"].forEach(
      function (t, e) {
        r[t] = function (n) {
          return typeof n === t || "a" + (e < 1 ? "n " : " ") + t;
        };
      }
    );
    var s = {},
      o = i.version.split(".");
    function a(t, e) {
      for (var n = e ? e.split(".") : o, i = t.split("."), r = 0; r < 3; r++) {
        if (n[r] > i[r]) return !0;
        if (n[r] < i[r]) return !1;
      }
      return !1;
    }
    (r.transitional = function (t, e, n) {
      var r = e && a(e);
      function o(t, e) {
        return (
          "[Axios v" +
          i.version +
          "] Transitional option '" +
          t +
          "'" +
          e +
          (n ? ". " + n : "")
        );
      }
      return function (n, i, a) {
        if (!1 === t) throw new Error(o(i, " has been removed in " + e));
        return (
          r &&
            !s[i] &&
            ((s[i] = !0),
            console.warn(
              o(
                i,
                " has been deprecated since v" +
                  e +
                  " and will be removed in the near future"
              )
            )),
          !t || t(n, i, a)
        );
      };
    }),
      (t.exports = {
        isOlderVersion: a,
        assertOptions: function (t, e, n) {
          if ("object" != typeof t)
            throw new TypeError("options must be an object");
          for (var i = Object.keys(t), r = i.length; r-- > 0; ) {
            var s = i[r],
              o = e[s];
            if (o) {
              var a = t[s],
                l = void 0 === a || o(a, s, t);
              if (!0 !== l)
                throw new TypeError("option " + s + " must be " + l);
            } else if (!0 !== n) throw Error("Unknown option " + s);
          }
        },
        validators: r,
      });
  },
  "jfS+": function (t, e, n) {
    "use strict";
    var i = n("endd");
    function r(t) {
      if ("function" != typeof t)
        throw new TypeError("executor must be a function.");
      var e;
      this.promise = new Promise(function (t) {
        e = t;
      });
      var n = this;
      t(function (t) {
        n.reason || ((n.reason = new i(t)), e(n.reason));
      });
    }
    (r.prototype.throwIfRequested = function () {
      if (this.reason) throw this.reason;
    }),
      (r.source = function () {
        var t;
        return {
          token: new r(function (e) {
            t = e;
          }),
          cancel: t,
        };
      }),
      (t.exports = r);
  },
  lFy7: function (t, e, n) {
    (t.exports = n("I1BE")(!1)).push([
      t.i,
      "/* Slider */\n.slick-slider\n{\n    position: relative;\n\n    display: block;\n    box-sizing: border-box;\n\n    -webkit-user-select: none;\n       -moz-user-select: none;\n        -ms-user-select: none;\n            user-select: none;\n\n    -webkit-touch-callout: none;\n    -khtml-user-select: none;\n    touch-action: pan-y;\n    -webkit-tap-highlight-color: transparent;\n}\n\n.slick-list\n{\n    position: relative;\n\n    display: block;\n    overflow: hidden;\n\n    margin: 0;\n    padding: 0;\n}\n.slick-list:focus\n{\n    outline: none;\n}\n.slick-list.dragging\n{\n    cursor: pointer;\n    cursor: hand;\n}\n\n.slick-slider .slick-track,\n.slick-slider .slick-list\n{\n    -webkit-transform: translate3d(0, 0, 0);\n            transform: translate3d(0, 0, 0);\n}\n\n.slick-track\n{\n    position: relative;\n    top: 0;\n    left: 0;\n\n    display: block;\n    margin-left: auto;\n    margin-right: auto;\n}\n.slick-track:before,\n.slick-track:after\n{\n    display: table;\n\n    content: '';\n}\n.slick-track:after\n{\n    clear: both;\n}\n.slick-loading .slick-track\n{\n    visibility: hidden;\n}\n\n.slick-slide\n{\n    display: none;\n    float: left;\n\n    height: 100%;\n    min-height: 1px;\n}\n[dir='rtl'] .slick-slide\n{\n    float: right;\n}\n.slick-slide img\n{\n    display: block;\n}\n.slick-slide.slick-loading img\n{\n    display: none;\n}\n.slick-slide.dragging img\n{\n    pointer-events: none;\n}\n.slick-initialized .slick-slide\n{\n    display: block;\n}\n.slick-loading .slick-slide\n{\n    visibility: hidden;\n}\n.slick-vertical .slick-slide\n{\n    display: block;\n\n    height: auto;\n\n    border: 1px solid transparent;\n}\n.slick-arrow.slick-hidden {\n    display: none;\n}\n",
      "",
    ]);
  },
  mPeE: function (t, e) {},
  ng4s: function (t, e, n) {
    "use strict";
    n.r(e);
    var i = n("EVdn"),
      r = n.n(i);
    (window.$ = window.jQuery = r.a), (window.axios = n("vDqi"));
    n("Zej/"), n("BFHv"), n("tyWD");
    function s(t, e) {
      for (var n = 0; n < e.length; n++) {
        var i = e[n];
        (i.enumerable = i.enumerable || !1),
          (i.configurable = !0),
          "value" in i && (i.writable = !0),
          Object.defineProperty(t, i.key, i);
      }
    }
    var o = (function () {
        function t(e) {
          !(function (t, e) {
            if (!(t instanceof e))
              throw new TypeError("Cannot call a class as a function");
          })(this, t),
            (this.container = e),
            (this.containerSlides = e.querySelector(".fabric-slider-slides")),
            (this.containerTabs = e.querySelector(".fabric-slider-tabs")),
            (this.currentSlide = 0),
            this.initSlides(),
            this.initTabs();
        }
        var e, n, i;
        return (
          (e = t),
          (n = [
            {
              key: "initSlides",
              value: function () {
                (this.slides = Array.from(
                  this.containerSlides.querySelectorAll(".slide")
                )),
                  this.slides.length &&
                    this.slides.forEach(function (t, e) {
                      0 === e
                        ? t.classList.add("active")
                        : e > 0 &&
                          (t.style.transform = "translateX(".concat(
                            -100 * e,
                            "%)"
                          ));
                    });
              },
            },
            {
              key: "selectSlide",
              value: function (t) {
                this.currentSlide !== t &&
                  (this.slides[this.currentSlide].classList.remove("active"),
                  this.tabs[this.currentSlide].classList.remove("active"),
                  this.dots[this.currentSlide].classList.remove("active"),
                  (this.currentSlide = t),
                  this.slides[this.currentSlide].classList.add("active"),
                  this.tabs[this.currentSlide].classList.add("active"),
                  this.dots[this.currentSlide].classList.add("active"));
              },
            },
            {
              key: "initTabs",
              value: function () {
                var t = this;
                this.containerTabs &&
                  ((this.tabs = Array.from(
                    this.containerTabs.querySelectorAll(".slide")
                  )),
                  (this.containerDots = null),
                  (this.dots = []),
                  this.tabs.length &&
                    ((this.containerDots = document.createElement("ul")),
                    this.containerDots.classList.add("tabs-dots"),
                    this.tabs.forEach(function (e, n) {
                      e.addEventListener("click", function () {
                        t.selectSlide(n);
                      });
                      var i = document.createElement("li");
                      0 === n
                        ? (e.classList.add("active"), i.classList.add("active"))
                        : n > 0 &&
                          (e.style.transform = "translateX(".concat(
                            -100 * n,
                            "%)"
                          ));
                      var r = document.createElement("span");
                      r.innerText = "".concat(n);
                      var s = document.createElement("button");
                      s.appendChild(r),
                        s.setAttribute("type", "button"),
                        s.addEventListener("click", function () {
                          t.selectSlide(n);
                        }),
                        i.appendChild(s),
                        t.dots.push(i),
                        t.containerDots.appendChild(i);
                    }),
                    this.containerTabs.after(this.containerDots)));
              },
            },
          ]) && s(e.prototype, n),
          i && s(e, i),
          t
        );
      })(),
      a = n("XxWc");
    const l = "136",
      c = 0,
      u = 1,
      h = 2,
      d = 1,
      p = 2,
      f = 3,
      m = 0,
      g = 1,
      v = 2,
      y = 1,
      x = 0,
      b = 1,
      _ = 2,
      w = 3,
      S = 4,
      M = 5,
      T = 100,
      E = 101,
      A = 102,
      C = 103,
      L = 104,
      R = 200,
      P = 201,
      D = 202,
      k = 203,
      I = 204,
      N = 205,
      O = 206,
      z = 207,
      H = 208,
      B = 209,
      U = 210,
      F = 0,
      V = 1,
      W = 2,
      G = 3,
      j = 4,
      q = 5,
      X = 6,
      J = 7,
      Y = 0,
      Z = 1,
      Q = 2,
      K = 0,
      tt = 1,
      et = 2,
      nt = 3,
      it = 4,
      rt = 5,
      st = 300,
      ot = 301,
      at = 302,
      lt = 303,
      ct = 304,
      ut = 306,
      ht = 307,
      dt = 1e3,
      pt = 1001,
      ft = 1002,
      mt = 1003,
      gt = 1004,
      vt = 1005,
      yt = 1006,
      xt = 1007,
      bt = 1008,
      _t = 1009,
      wt = 1010,
      St = 1011,
      Mt = 1012,
      Tt = 1013,
      Et = 1014,
      At = 1015,
      Ct = 1016,
      Lt = 1017,
      Rt = 1018,
      Pt = 1019,
      Dt = 1020,
      kt = 1021,
      It = 1022,
      Nt = 1023,
      Ot = 1024,
      zt = 1025,
      Ht = 1026,
      Bt = 1027,
      Ut = 1028,
      Ft = 1029,
      Vt = 1030,
      Wt = 1031,
      Gt = 1032,
      jt = 1033,
      qt = 33776,
      $t = 33777,
      Xt = 33778,
      Jt = 33779,
      Yt = 35840,
      Zt = 35841,
      Qt = 35842,
      Kt = 35843,
      te = 36196,
      ee = 37492,
      ne = 37496,
      ie = 37808,
      re = 37809,
      se = 37810,
      oe = 37811,
      ae = 37812,
      le = 37813,
      ce = 37814,
      ue = 37815,
      he = 37816,
      de = 37817,
      pe = 37818,
      fe = 37819,
      me = 37820,
      ge = 37821,
      ve = 36492,
      ye = 37840,
      xe = 37841,
      be = 37842,
      _e = 37843,
      we = 37844,
      Se = 37845,
      Me = 37846,
      Te = 37847,
      Ee = 37848,
      Ae = 37849,
      Ce = 37850,
      Le = 37851,
      Re = 37852,
      Pe = 37853,
      De = 2200,
      ke = 2201,
      Ie = 2202,
      Ne = 2300,
      Oe = 2301,
      ze = 2302,
      He = 2400,
      Be = 2401,
      Ue = 2402,
      Fe = 2500,
      Ve = 2501,
      We = 3e3,
      Ge = 3001,
      je = 3200,
      qe = 3201,
      $e = 0,
      Xe = 1,
      Je = 7680,
      Ye = 519,
      Ze = 35044,
      Qe = 35048,
      Ke = "300 es";
    class tn {
      addEventListener(t, e) {
        void 0 === this._listeners && (this._listeners = {});
        const n = this._listeners;
        void 0 === n[t] && (n[t] = []), -1 === n[t].indexOf(e) && n[t].push(e);
      }
      hasEventListener(t, e) {
        if (void 0 === this._listeners) return !1;
        const n = this._listeners;
        return void 0 !== n[t] && -1 !== n[t].indexOf(e);
      }
      removeEventListener(t, e) {
        if (void 0 === this._listeners) return;
        const n = this._listeners[t];
        if (void 0 !== n) {
          const t = n.indexOf(e);
          -1 !== t && n.splice(t, 1);
        }
      }
      dispatchEvent(t) {
        if (void 0 === this._listeners) return;
        const e = this._listeners[t.type];
        if (void 0 !== e) {
          t.target = this;
          const n = e.slice(0);
          for (let e = 0, i = n.length; e < i; e++) n[e].call(this, t);
          t.target = null;
        }
      }
    }
    const en = [];
    for (let t = 0; t < 256; t++) en[t] = (t < 16 ? "0" : "") + t.toString(16);
    const nn = Math.PI / 180,
      rn = 180 / Math.PI;
    function sn() {
      const t = (4294967295 * Math.random()) | 0,
        e = (4294967295 * Math.random()) | 0,
        n = (4294967295 * Math.random()) | 0,
        i = (4294967295 * Math.random()) | 0;
      return (
        en[255 & t] +
        en[(t >> 8) & 255] +
        en[(t >> 16) & 255] +
        en[(t >> 24) & 255] +
        "-" +
        en[255 & e] +
        en[(e >> 8) & 255] +
        "-" +
        en[((e >> 16) & 15) | 64] +
        en[(e >> 24) & 255] +
        "-" +
        en[(63 & n) | 128] +
        en[(n >> 8) & 255] +
        "-" +
        en[(n >> 16) & 255] +
        en[(n >> 24) & 255] +
        en[255 & i] +
        en[(i >> 8) & 255] +
        en[(i >> 16) & 255] +
        en[(i >> 24) & 255]
      ).toUpperCase();
    }
    function on(t, e, n) {
      return Math.max(e, Math.min(n, t));
    }
    function an(t, e) {
      return ((t % e) + e) % e;
    }
    function ln(t, e, n) {
      return (1 - n) * t + n * e;
    }
    function cn(t) {
      return 0 == (t & (t - 1)) && 0 !== t;
    }
    function un(t) {
      return Math.pow(2, Math.floor(Math.log(t) / Math.LN2));
    }
    class hn {
      constructor(t = 0, e = 0) {
        (this.x = t), (this.y = e);
      }
      get width() {
        return this.x;
      }
      set width(t) {
        this.x = t;
      }
      get height() {
        return this.y;
      }
      set height(t) {
        this.y = t;
      }
      set(t, e) {
        return (this.x = t), (this.y = e), this;
      }
      setScalar(t) {
        return (this.x = t), (this.y = t), this;
      }
      setX(t) {
        return (this.x = t), this;
      }
      setY(t) {
        return (this.y = t), this;
      }
      setComponent(t, e) {
        switch (t) {
          case 0:
            this.x = e;
            break;
          case 1:
            this.y = e;
            break;
          default:
            throw new Error("index is out of range: " + t);
        }
        return this;
      }
      getComponent(t) {
        switch (t) {
          case 0:
            return this.x;
          case 1:
            return this.y;
          default:
            throw new Error("index is out of range: " + t);
        }
      }
      clone() {
        return new this.constructor(this.x, this.y);
      }
      copy(t) {
        return (this.x = t.x), (this.y = t.y), this;
      }
      add(t, e) {
        return void 0 !== e
          ? (console.warn(
              "THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
            ),
            this.addVectors(t, e))
          : ((this.x += t.x), (this.y += t.y), this);
      }
      addScalar(t) {
        return (this.x += t), (this.y += t), this;
      }
      addVectors(t, e) {
        return (this.x = t.x + e.x), (this.y = t.y + e.y), this;
      }
      addScaledVector(t, e) {
        return (this.x += t.x * e), (this.y += t.y * e), this;
      }
      sub(t, e) {
        return void 0 !== e
          ? (console.warn(
              "THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
            ),
            this.subVectors(t, e))
          : ((this.x -= t.x), (this.y -= t.y), this);
      }
      subScalar(t) {
        return (this.x -= t), (this.y -= t), this;
      }
      subVectors(t, e) {
        return (this.x = t.x - e.x), (this.y = t.y - e.y), this;
      }
      multiply(t) {
        return (this.x *= t.x), (this.y *= t.y), this;
      }
      multiplyScalar(t) {
        return (this.x *= t), (this.y *= t), this;
      }
      divide(t) {
        return (this.x /= t.x), (this.y /= t.y), this;
      }
      divideScalar(t) {
        return this.multiplyScalar(1 / t);
      }
      applyMatrix3(t) {
        const e = this.x,
          n = this.y,
          i = t.elements;
        return (
          (this.x = i[0] * e + i[3] * n + i[6]),
          (this.y = i[1] * e + i[4] * n + i[7]),
          this
        );
      }
      min(t) {
        return (
          (this.x = Math.min(this.x, t.x)),
          (this.y = Math.min(this.y, t.y)),
          this
        );
      }
      max(t) {
        return (
          (this.x = Math.max(this.x, t.x)),
          (this.y = Math.max(this.y, t.y)),
          this
        );
      }
      clamp(t, e) {
        return (
          (this.x = Math.max(t.x, Math.min(e.x, this.x))),
          (this.y = Math.max(t.y, Math.min(e.y, this.y))),
          this
        );
      }
      clampScalar(t, e) {
        return (
          (this.x = Math.max(t, Math.min(e, this.x))),
          (this.y = Math.max(t, Math.min(e, this.y))),
          this
        );
      }
      clampLength(t, e) {
        const n = this.length();
        return this.divideScalar(n || 1).multiplyScalar(
          Math.max(t, Math.min(e, n))
        );
      }
      floor() {
        return (
          (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this
        );
      }
      ceil() {
        return (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this;
      }
      round() {
        return (
          (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this
        );
      }
      roundToZero() {
        return (
          (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
          (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
          this
        );
      }
      negate() {
        return (this.x = -this.x), (this.y = -this.y), this;
      }
      dot(t) {
        return this.x * t.x + this.y * t.y;
      }
      cross(t) {
        return this.x * t.y - this.y * t.x;
      }
      lengthSq() {
        return this.x * this.x + this.y * this.y;
      }
      length() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
      }
      manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y);
      }
      normalize() {
        return this.divideScalar(this.length() || 1);
      }
      angle() {
        return Math.atan2(-this.y, -this.x) + Math.PI;
      }
      distanceTo(t) {
        return Math.sqrt(this.distanceToSquared(t));
      }
      distanceToSquared(t) {
        const e = this.x - t.x,
          n = this.y - t.y;
        return e * e + n * n;
      }
      manhattanDistanceTo(t) {
        return Math.abs(this.x - t.x) + Math.abs(this.y - t.y);
      }
      setLength(t) {
        return this.normalize().multiplyScalar(t);
      }
      lerp(t, e) {
        return (
          (this.x += (t.x - this.x) * e), (this.y += (t.y - this.y) * e), this
        );
      }
      lerpVectors(t, e, n) {
        return (
          (this.x = t.x + (e.x - t.x) * n),
          (this.y = t.y + (e.y - t.y) * n),
          this
        );
      }
      equals(t) {
        return t.x === this.x && t.y === this.y;
      }
      fromArray(t, e = 0) {
        return (this.x = t[e]), (this.y = t[e + 1]), this;
      }
      toArray(t = [], e = 0) {
        return (t[e] = this.x), (t[e + 1] = this.y), t;
      }
      fromBufferAttribute(t, e, n) {
        return (
          void 0 !== n &&
            console.warn(
              "THREE.Vector2: offset has been removed from .fromBufferAttribute()."
            ),
          (this.x = t.getX(e)),
          (this.y = t.getY(e)),
          this
        );
      }
      rotateAround(t, e) {
        const n = Math.cos(e),
          i = Math.sin(e),
          r = this.x - t.x,
          s = this.y - t.y;
        return (
          (this.x = r * n - s * i + t.x), (this.y = r * i + s * n + t.y), this
        );
      }
      random() {
        return (this.x = Math.random()), (this.y = Math.random()), this;
      }
      *[Symbol.iterator]() {
        yield this.x, yield this.y;
      }
    }
    hn.prototype.isVector2 = !0;
    class dn {
      constructor() {
        (this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
          arguments.length > 0 &&
            console.error(
              "THREE.Matrix3: the constructor no longer reads arguments. use .set() instead."
            );
      }
      set(t, e, n, i, r, s, o, a, l) {
        const c = this.elements;
        return (
          (c[0] = t),
          (c[1] = i),
          (c[2] = o),
          (c[3] = e),
          (c[4] = r),
          (c[5] = a),
          (c[6] = n),
          (c[7] = s),
          (c[8] = l),
          this
        );
      }
      identity() {
        return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
      }
      copy(t) {
        const e = this.elements,
          n = t.elements;
        return (
          (e[0] = n[0]),
          (e[1] = n[1]),
          (e[2] = n[2]),
          (e[3] = n[3]),
          (e[4] = n[4]),
          (e[5] = n[5]),
          (e[6] = n[6]),
          (e[7] = n[7]),
          (e[8] = n[8]),
          this
        );
      }
      extractBasis(t, e, n) {
        return (
          t.setFromMatrix3Column(this, 0),
          e.setFromMatrix3Column(this, 1),
          n.setFromMatrix3Column(this, 2),
          this
        );
      }
      setFromMatrix4(t) {
        const e = t.elements;
        return (
          this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]), this
        );
      }
      multiply(t) {
        return this.multiplyMatrices(this, t);
      }
      premultiply(t) {
        return this.multiplyMatrices(t, this);
      }
      multiplyMatrices(t, e) {
        const n = t.elements,
          i = e.elements,
          r = this.elements,
          s = n[0],
          o = n[3],
          a = n[6],
          l = n[1],
          c = n[4],
          u = n[7],
          h = n[2],
          d = n[5],
          p = n[8],
          f = i[0],
          m = i[3],
          g = i[6],
          v = i[1],
          y = i[4],
          x = i[7],
          b = i[2],
          _ = i[5],
          w = i[8];
        return (
          (r[0] = s * f + o * v + a * b),
          (r[3] = s * m + o * y + a * _),
          (r[6] = s * g + o * x + a * w),
          (r[1] = l * f + c * v + u * b),
          (r[4] = l * m + c * y + u * _),
          (r[7] = l * g + c * x + u * w),
          (r[2] = h * f + d * v + p * b),
          (r[5] = h * m + d * y + p * _),
          (r[8] = h * g + d * x + p * w),
          this
        );
      }
      multiplyScalar(t) {
        const e = this.elements;
        return (
          (e[0] *= t),
          (e[3] *= t),
          (e[6] *= t),
          (e[1] *= t),
          (e[4] *= t),
          (e[7] *= t),
          (e[2] *= t),
          (e[5] *= t),
          (e[8] *= t),
          this
        );
      }
      determinant() {
        const t = this.elements,
          e = t[0],
          n = t[1],
          i = t[2],
          r = t[3],
          s = t[4],
          o = t[5],
          a = t[6],
          l = t[7],
          c = t[8];
        return (
          e * s * c - e * o * l - n * r * c + n * o * a + i * r * l - i * s * a
        );
      }
      invert() {
        const t = this.elements,
          e = t[0],
          n = t[1],
          i = t[2],
          r = t[3],
          s = t[4],
          o = t[5],
          a = t[6],
          l = t[7],
          c = t[8],
          u = c * s - o * l,
          h = o * a - c * r,
          d = l * r - s * a,
          p = e * u + n * h + i * d;
        if (0 === p) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
        const f = 1 / p;
        return (
          (t[0] = u * f),
          (t[1] = (i * l - c * n) * f),
          (t[2] = (o * n - i * s) * f),
          (t[3] = h * f),
          (t[4] = (c * e - i * a) * f),
          (t[5] = (i * r - o * e) * f),
          (t[6] = d * f),
          (t[7] = (n * a - l * e) * f),
          (t[8] = (s * e - n * r) * f),
          this
        );
      }
      transpose() {
        let t;
        const e = this.elements;
        return (
          (t = e[1]),
          (e[1] = e[3]),
          (e[3] = t),
          (t = e[2]),
          (e[2] = e[6]),
          (e[6] = t),
          (t = e[5]),
          (e[5] = e[7]),
          (e[7] = t),
          this
        );
      }
      getNormalMatrix(t) {
        return this.setFromMatrix4(t).invert().transpose();
      }
      transposeIntoArray(t) {
        const e = this.elements;
        return (
          (t[0] = e[0]),
          (t[1] = e[3]),
          (t[2] = e[6]),
          (t[3] = e[1]),
          (t[4] = e[4]),
          (t[5] = e[7]),
          (t[6] = e[2]),
          (t[7] = e[5]),
          (t[8] = e[8]),
          this
        );
      }
      setUvTransform(t, e, n, i, r, s, o) {
        const a = Math.cos(r),
          l = Math.sin(r);
        return (
          this.set(
            n * a,
            n * l,
            -n * (a * s + l * o) + s + t,
            -i * l,
            i * a,
            -i * (-l * s + a * o) + o + e,
            0,
            0,
            1
          ),
          this
        );
      }
      scale(t, e) {
        const n = this.elements;
        return (
          (n[0] *= t),
          (n[3] *= t),
          (n[6] *= t),
          (n[1] *= e),
          (n[4] *= e),
          (n[7] *= e),
          this
        );
      }
      rotate(t) {
        const e = Math.cos(t),
          n = Math.sin(t),
          i = this.elements,
          r = i[0],
          s = i[3],
          o = i[6],
          a = i[1],
          l = i[4],
          c = i[7];
        return (
          (i[0] = e * r + n * a),
          (i[3] = e * s + n * l),
          (i[6] = e * o + n * c),
          (i[1] = -n * r + e * a),
          (i[4] = -n * s + e * l),
          (i[7] = -n * o + e * c),
          this
        );
      }
      translate(t, e) {
        const n = this.elements;
        return (
          (n[0] += t * n[2]),
          (n[3] += t * n[5]),
          (n[6] += t * n[8]),
          (n[1] += e * n[2]),
          (n[4] += e * n[5]),
          (n[7] += e * n[8]),
          this
        );
      }
      equals(t) {
        const e = this.elements,
          n = t.elements;
        for (let t = 0; t < 9; t++) if (e[t] !== n[t]) return !1;
        return !0;
      }
      fromArray(t, e = 0) {
        for (let n = 0; n < 9; n++) this.elements[n] = t[n + e];
        return this;
      }
      toArray(t = [], e = 0) {
        const n = this.elements;
        return (
          (t[e] = n[0]),
          (t[e + 1] = n[1]),
          (t[e + 2] = n[2]),
          (t[e + 3] = n[3]),
          (t[e + 4] = n[4]),
          (t[e + 5] = n[5]),
          (t[e + 6] = n[6]),
          (t[e + 7] = n[7]),
          (t[e + 8] = n[8]),
          t
        );
      }
      clone() {
        return new this.constructor().fromArray(this.elements);
      }
    }
    function pn(t) {
      if (0 === t.length) return -1 / 0;
      let e = t[0];
      for (let n = 1, i = t.length; n < i; ++n) t[n] > e && (e = t[n]);
      return e;
    }
    dn.prototype.isMatrix3 = !0;
    Int8Array,
      Uint8Array,
      Uint8ClampedArray,
      Int16Array,
      Uint16Array,
      Int32Array,
      Uint32Array,
      Float32Array,
      Float64Array;
    function fn(t) {
      return document.createElementNS("http://www.w3.org/1999/xhtml", t);
    }
    let mn;
    class gn {
      static getDataURL(t) {
        if (/^data:/i.test(t.src)) return t.src;
        if ("undefined" == typeof HTMLCanvasElement) return t.src;
        let e;
        if (t instanceof HTMLCanvasElement) e = t;
        else {
          void 0 === mn && (mn = fn("canvas")),
            (mn.width = t.width),
            (mn.height = t.height);
          const n = mn.getContext("2d");
          t instanceof ImageData
            ? n.putImageData(t, 0, 0)
            : n.drawImage(t, 0, 0, t.width, t.height),
            (e = mn);
        }
        return e.width > 2048 || e.height > 2048
          ? (console.warn(
              "THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",
              t
            ),
            e.toDataURL("image/jpeg", 0.6))
          : e.toDataURL("image/png");
      }
    }
    let vn = 0;
    class yn extends tn {
      constructor(
        t = yn.DEFAULT_IMAGE,
        e = yn.DEFAULT_MAPPING,
        n = pt,
        i = pt,
        r = yt,
        s = bt,
        o = Nt,
        a = _t,
        l = 1,
        c = We
      ) {
        super(),
          Object.defineProperty(this, "id", { value: vn++ }),
          (this.uuid = sn()),
          (this.name = ""),
          (this.image = t),
          (this.mipmaps = []),
          (this.mapping = e),
          (this.wrapS = n),
          (this.wrapT = i),
          (this.magFilter = r),
          (this.minFilter = s),
          (this.anisotropy = l),
          (this.format = o),
          (this.internalFormat = null),
          (this.type = a),
          (this.offset = new hn(0, 0)),
          (this.repeat = new hn(1, 1)),
          (this.center = new hn(0, 0)),
          (this.rotation = 0),
          (this.matrixAutoUpdate = !0),
          (this.matrix = new dn()),
          (this.generateMipmaps = !0),
          (this.premultiplyAlpha = !1),
          (this.flipY = !0),
          (this.unpackAlignment = 4),
          (this.encoding = c),
          (this.userData = {}),
          (this.version = 0),
          (this.onUpdate = null),
          (this.isRenderTargetTexture = !1);
      }
      updateMatrix() {
        this.matrix.setUvTransform(
          this.offset.x,
          this.offset.y,
          this.repeat.x,
          this.repeat.y,
          this.rotation,
          this.center.x,
          this.center.y
        );
      }
      clone() {
        return new this.constructor().copy(this);
      }
      copy(t) {
        return (
          (this.name = t.name),
          (this.image = t.image),
          (this.mipmaps = t.mipmaps.slice(0)),
          (this.mapping = t.mapping),
          (this.wrapS = t.wrapS),
          (this.wrapT = t.wrapT),
          (this.magFilter = t.magFilter),
          (this.minFilter = t.minFilter),
          (this.anisotropy = t.anisotropy),
          (this.format = t.format),
          (this.internalFormat = t.internalFormat),
          (this.type = t.type),
          this.offset.copy(t.offset),
          this.repeat.copy(t.repeat),
          this.center.copy(t.center),
          (this.rotation = t.rotation),
          (this.matrixAutoUpdate = t.matrixAutoUpdate),
          this.matrix.copy(t.matrix),
          (this.generateMipmaps = t.generateMipmaps),
          (this.premultiplyAlpha = t.premultiplyAlpha),
          (this.flipY = t.flipY),
          (this.unpackAlignment = t.unpackAlignment),
          (this.encoding = t.encoding),
          (this.userData = JSON.parse(JSON.stringify(t.userData))),
          this
        );
      }
      toJSON(t) {
        const e = void 0 === t || "string" == typeof t;
        if (!e && void 0 !== t.textures[this.uuid])
          return t.textures[this.uuid];
        const n = {
          metadata: {
            version: 4.5,
            type: "Texture",
            generator: "Texture.toJSON",
          },
          uuid: this.uuid,
          name: this.name,
          mapping: this.mapping,
          repeat: [this.repeat.x, this.repeat.y],
          offset: [this.offset.x, this.offset.y],
          center: [this.center.x, this.center.y],
          rotation: this.rotation,
          wrap: [this.wrapS, this.wrapT],
          format: this.format,
          type: this.type,
          encoding: this.encoding,
          minFilter: this.minFilter,
          magFilter: this.magFilter,
          anisotropy: this.anisotropy,
          flipY: this.flipY,
          premultiplyAlpha: this.premultiplyAlpha,
          unpackAlignment: this.unpackAlignment,
        };
        if (void 0 !== this.image) {
          const i = this.image;
          if (
            (void 0 === i.uuid && (i.uuid = sn()),
            !e && void 0 === t.images[i.uuid])
          ) {
            let e;
            if (Array.isArray(i)) {
              e = [];
              for (let t = 0, n = i.length; t < n; t++)
                i[t].isDataTexture ? e.push(xn(i[t].image)) : e.push(xn(i[t]));
            } else e = xn(i);
            t.images[i.uuid] = { uuid: i.uuid, url: e };
          }
          n.image = i.uuid;
        }
        return (
          "{}" !== JSON.stringify(this.userData) &&
            (n.userData = this.userData),
          e || (t.textures[this.uuid] = n),
          n
        );
      }
      dispose() {
        this.dispatchEvent({ type: "dispose" });
      }
      transformUv(t) {
        if (this.mapping !== st) return t;
        if ((t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1))
          switch (this.wrapS) {
            case dt:
              t.x = t.x - Math.floor(t.x);
              break;
            case pt:
              t.x = t.x < 0 ? 0 : 1;
              break;
            case ft:
              1 === Math.abs(Math.floor(t.x) % 2)
                ? (t.x = Math.ceil(t.x) - t.x)
                : (t.x = t.x - Math.floor(t.x));
          }
        if (t.y < 0 || t.y > 1)
          switch (this.wrapT) {
            case dt:
              t.y = t.y - Math.floor(t.y);
              break;
            case pt:
              t.y = t.y < 0 ? 0 : 1;
              break;
            case ft:
              1 === Math.abs(Math.floor(t.y) % 2)
                ? (t.y = Math.ceil(t.y) - t.y)
                : (t.y = t.y - Math.floor(t.y));
          }
        return this.flipY && (t.y = 1 - t.y), t;
      }
      set needsUpdate(t) {
        !0 === t && this.version++;
      }
    }
    function xn(t) {
      return ("undefined" != typeof HTMLImageElement &&
        t instanceof HTMLImageElement) ||
        ("undefined" != typeof HTMLCanvasElement &&
          t instanceof HTMLCanvasElement) ||
        ("undefined" != typeof ImageBitmap && t instanceof ImageBitmap)
        ? gn.getDataURL(t)
        : t.data
        ? {
            data: Array.prototype.slice.call(t.data),
            width: t.width,
            height: t.height,
            type: t.data.constructor.name,
          }
        : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
    }
    (yn.DEFAULT_IMAGE = void 0),
      (yn.DEFAULT_MAPPING = st),
      (yn.prototype.isTexture = !0);
    class bn {
      constructor(t = 0, e = 0, n = 0, i = 1) {
        (this.x = t), (this.y = e), (this.z = n), (this.w = i);
      }
      get width() {
        return this.z;
      }
      set width(t) {
        this.z = t;
      }
      get height() {
        return this.w;
      }
      set height(t) {
        this.w = t;
      }
      set(t, e, n, i) {
        return (this.x = t), (this.y = e), (this.z = n), (this.w = i), this;
      }
      setScalar(t) {
        return (this.x = t), (this.y = t), (this.z = t), (this.w = t), this;
      }
      setX(t) {
        return (this.x = t), this;
      }
      setY(t) {
        return (this.y = t), this;
      }
      setZ(t) {
        return (this.z = t), this;
      }
      setW(t) {
        return (this.w = t), this;
      }
      setComponent(t, e) {
        switch (t) {
          case 0:
            this.x = e;
            break;
          case 1:
            this.y = e;
            break;
          case 2:
            this.z = e;
            break;
          case 3:
            this.w = e;
            break;
          default:
            throw new Error("index is out of range: " + t);
        }
        return this;
      }
      getComponent(t) {
        switch (t) {
          case 0:
            return this.x;
          case 1:
            return this.y;
          case 2:
            return this.z;
          case 3:
            return this.w;
          default:
            throw new Error("index is out of range: " + t);
        }
      }
      clone() {
        return new this.constructor(this.x, this.y, this.z, this.w);
      }
      copy(t) {
        return (
          (this.x = t.x),
          (this.y = t.y),
          (this.z = t.z),
          (this.w = void 0 !== t.w ? t.w : 1),
          this
        );
      }
      add(t, e) {
        return void 0 !== e
          ? (console.warn(
              "THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
            ),
            this.addVectors(t, e))
          : ((this.x += t.x),
            (this.y += t.y),
            (this.z += t.z),
            (this.w += t.w),
            this);
      }
      addScalar(t) {
        return (this.x += t), (this.y += t), (this.z += t), (this.w += t), this;
      }
      addVectors(t, e) {
        return (
          (this.x = t.x + e.x),
          (this.y = t.y + e.y),
          (this.z = t.z + e.z),
          (this.w = t.w + e.w),
          this
        );
      }
      addScaledVector(t, e) {
        return (
          (this.x += t.x * e),
          (this.y += t.y * e),
          (this.z += t.z * e),
          (this.w += t.w * e),
          this
        );
      }
      sub(t, e) {
        return void 0 !== e
          ? (console.warn(
              "THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
            ),
            this.subVectors(t, e))
          : ((this.x -= t.x),
            (this.y -= t.y),
            (this.z -= t.z),
            (this.w -= t.w),
            this);
      }
      subScalar(t) {
        return (this.x -= t), (this.y -= t), (this.z -= t), (this.w -= t), this;
      }
      subVectors(t, e) {
        return (
          (this.x = t.x - e.x),
          (this.y = t.y - e.y),
          (this.z = t.z - e.z),
          (this.w = t.w - e.w),
          this
        );
      }
      multiply(t) {
        return (
          (this.x *= t.x),
          (this.y *= t.y),
          (this.z *= t.z),
          (this.w *= t.w),
          this
        );
      }
      multiplyScalar(t) {
        return (this.x *= t), (this.y *= t), (this.z *= t), (this.w *= t), this;
      }
      applyMatrix4(t) {
        const e = this.x,
          n = this.y,
          i = this.z,
          r = this.w,
          s = t.elements;
        return (
          (this.x = s[0] * e + s[4] * n + s[8] * i + s[12] * r),
          (this.y = s[1] * e + s[5] * n + s[9] * i + s[13] * r),
          (this.z = s[2] * e + s[6] * n + s[10] * i + s[14] * r),
          (this.w = s[3] * e + s[7] * n + s[11] * i + s[15] * r),
          this
        );
      }
      divideScalar(t) {
        return this.multiplyScalar(1 / t);
      }
      setAxisAngleFromQuaternion(t) {
        this.w = 2 * Math.acos(t.w);
        const e = Math.sqrt(1 - t.w * t.w);
        return (
          e < 1e-4
            ? ((this.x = 1), (this.y = 0), (this.z = 0))
            : ((this.x = t.x / e), (this.y = t.y / e), (this.z = t.z / e)),
          this
        );
      }
      setAxisAngleFromRotationMatrix(t) {
        let e, n, i, r;
        const s = t.elements,
          o = s[0],
          a = s[4],
          l = s[8],
          c = s[1],
          u = s[5],
          h = s[9],
          d = s[2],
          p = s[6],
          f = s[10];
        if (
          Math.abs(a - c) < 0.01 &&
          Math.abs(l - d) < 0.01 &&
          Math.abs(h - p) < 0.01
        ) {
          if (
            Math.abs(a + c) < 0.1 &&
            Math.abs(l + d) < 0.1 &&
            Math.abs(h + p) < 0.1 &&
            Math.abs(o + u + f - 3) < 0.1
          )
            return this.set(1, 0, 0, 0), this;
          e = Math.PI;
          const t = (o + 1) / 2,
            s = (u + 1) / 2,
            m = (f + 1) / 2,
            g = (a + c) / 4,
            v = (l + d) / 4,
            y = (h + p) / 4;
          return (
            t > s && t > m
              ? t < 0.01
                ? ((n = 0), (i = 0.707106781), (r = 0.707106781))
                : ((n = Math.sqrt(t)), (i = g / n), (r = v / n))
              : s > m
              ? s < 0.01
                ? ((n = 0.707106781), (i = 0), (r = 0.707106781))
                : ((i = Math.sqrt(s)), (n = g / i), (r = y / i))
              : m < 0.01
              ? ((n = 0.707106781), (i = 0.707106781), (r = 0))
              : ((r = Math.sqrt(m)), (n = v / r), (i = y / r)),
            this.set(n, i, r, e),
            this
          );
        }
        let m = Math.sqrt(
          (p - h) * (p - h) + (l - d) * (l - d) + (c - a) * (c - a)
        );
        return (
          Math.abs(m) < 0.001 && (m = 1),
          (this.x = (p - h) / m),
          (this.y = (l - d) / m),
          (this.z = (c - a) / m),
          (this.w = Math.acos((o + u + f - 1) / 2)),
          this
        );
      }
      min(t) {
        return (
          (this.x = Math.min(this.x, t.x)),
          (this.y = Math.min(this.y, t.y)),
          (this.z = Math.min(this.z, t.z)),
          (this.w = Math.min(this.w, t.w)),
          this
        );
      }
      max(t) {
        return (
          (this.x = Math.max(this.x, t.x)),
          (this.y = Math.max(this.y, t.y)),
          (this.z = Math.max(this.z, t.z)),
          (this.w = Math.max(this.w, t.w)),
          this
        );
      }
      clamp(t, e) {
        return (
          (this.x = Math.max(t.x, Math.min(e.x, this.x))),
          (this.y = Math.max(t.y, Math.min(e.y, this.y))),
          (this.z = Math.max(t.z, Math.min(e.z, this.z))),
          (this.w = Math.max(t.w, Math.min(e.w, this.w))),
          this
        );
      }
      clampScalar(t, e) {
        return (
          (this.x = Math.max(t, Math.min(e, this.x))),
          (this.y = Math.max(t, Math.min(e, this.y))),
          (this.z = Math.max(t, Math.min(e, this.z))),
          (this.w = Math.max(t, Math.min(e, this.w))),
          this
        );
      }
      clampLength(t, e) {
        const n = this.length();
        return this.divideScalar(n || 1).multiplyScalar(
          Math.max(t, Math.min(e, n))
        );
      }
      floor() {
        return (
          (this.x = Math.floor(this.x)),
          (this.y = Math.floor(this.y)),
          (this.z = Math.floor(this.z)),
          (this.w = Math.floor(this.w)),
          this
        );
      }
      ceil() {
        return (
          (this.x = Math.ceil(this.x)),
          (this.y = Math.ceil(this.y)),
          (this.z = Math.ceil(this.z)),
          (this.w = Math.ceil(this.w)),
          this
        );
      }
      round() {
        return (
          (this.x = Math.round(this.x)),
          (this.y = Math.round(this.y)),
          (this.z = Math.round(this.z)),
          (this.w = Math.round(this.w)),
          this
        );
      }
      roundToZero() {
        return (
          (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
          (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
          (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
          (this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w)),
          this
        );
      }
      negate() {
        return (
          (this.x = -this.x),
          (this.y = -this.y),
          (this.z = -this.z),
          (this.w = -this.w),
          this
        );
      }
      dot(t) {
        return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w;
      }
      lengthSq() {
        return (
          this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
        );
      }
      length() {
        return Math.sqrt(
          this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
        );
      }
      manhattanLength() {
        return (
          Math.abs(this.x) +
          Math.abs(this.y) +
          Math.abs(this.z) +
          Math.abs(this.w)
        );
      }
      normalize() {
        return this.divideScalar(this.length() || 1);
      }
      setLength(t) {
        return this.normalize().multiplyScalar(t);
      }
      lerp(t, e) {
        return (
          (this.x += (t.x - this.x) * e),
          (this.y += (t.y - this.y) * e),
          (this.z += (t.z - this.z) * e),
          (this.w += (t.w - this.w) * e),
          this
        );
      }
      lerpVectors(t, e, n) {
        return (
          (this.x = t.x + (e.x - t.x) * n),
          (this.y = t.y + (e.y - t.y) * n),
          (this.z = t.z + (e.z - t.z) * n),
          (this.w = t.w + (e.w - t.w) * n),
          this
        );
      }
      equals(t) {
        return (
          t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w
        );
      }
      fromArray(t, e = 0) {
        return (
          (this.x = t[e]),
          (this.y = t[e + 1]),
          (this.z = t[e + 2]),
          (this.w = t[e + 3]),
          this
        );
      }
      toArray(t = [], e = 0) {
        return (
          (t[e] = this.x),
          (t[e + 1] = this.y),
          (t[e + 2] = this.z),
          (t[e + 3] = this.w),
          t
        );
      }
      fromBufferAttribute(t, e, n) {
        return (
          void 0 !== n &&
            console.warn(
              "THREE.Vector4: offset has been removed from .fromBufferAttribute()."
            ),
          (this.x = t.getX(e)),
          (this.y = t.getY(e)),
          (this.z = t.getZ(e)),
          (this.w = t.getW(e)),
          this
        );
      }
      random() {
        return (
          (this.x = Math.random()),
          (this.y = Math.random()),
          (this.z = Math.random()),
          (this.w = Math.random()),
          this
        );
      }
      *[Symbol.iterator]() {
        yield this.x, yield this.y, yield this.z, yield this.w;
      }
    }
    bn.prototype.isVector4 = !0;
    class _n extends tn {
      constructor(t, e, n = {}) {
        super(),
          (this.width = t),
          (this.height = e),
          (this.depth = 1),
          (this.scissor = new bn(0, 0, t, e)),
          (this.scissorTest = !1),
          (this.viewport = new bn(0, 0, t, e)),
          (this.texture = new yn(
            void 0,
            n.mapping,
            n.wrapS,
            n.wrapT,
            n.magFilter,
            n.minFilter,
            n.format,
            n.type,
            n.anisotropy,
            n.encoding
          )),
          (this.texture.isRenderTargetTexture = !0),
          (this.texture.image = { width: t, height: e, depth: 1 }),
          (this.texture.generateMipmaps =
            void 0 !== n.generateMipmaps && n.generateMipmaps),
          (this.texture.internalFormat =
            void 0 !== n.internalFormat ? n.internalFormat : null),
          (this.texture.minFilter = void 0 !== n.minFilter ? n.minFilter : yt),
          (this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer),
          (this.stencilBuffer = void 0 !== n.stencilBuffer && n.stencilBuffer),
          (this.depthTexture =
            void 0 !== n.depthTexture ? n.depthTexture : null);
      }
      setTexture(t) {
        (t.image = {
          width: this.width,
          height: this.height,
          depth: this.depth,
        }),
          (this.texture = t);
      }
      setSize(t, e, n = 1) {
        (this.width === t && this.height === e && this.depth === n) ||
          ((this.width = t),
          (this.height = e),
          (this.depth = n),
          (this.texture.image.width = t),
          (this.texture.image.height = e),
          (this.texture.image.depth = n),
          this.dispose()),
          this.viewport.set(0, 0, t, e),
          this.scissor.set(0, 0, t, e);
      }
      clone() {
        return new this.constructor().copy(this);
      }
      copy(t) {
        return (
          (this.width = t.width),
          (this.height = t.height),
          (this.depth = t.depth),
          this.viewport.copy(t.viewport),
          (this.texture = t.texture.clone()),
          (this.texture.image = { ...this.texture.image }),
          (this.depthBuffer = t.depthBuffer),
          (this.stencilBuffer = t.stencilBuffer),
          (this.depthTexture = t.depthTexture),
          this
        );
      }
      dispose() {
        this.dispatchEvent({ type: "dispose" });
      }
    }
    _n.prototype.isWebGLRenderTarget = !0;
    (class extends _n {
      constructor(t, e, n) {
        super(t, e);
        const i = this.texture;
        this.texture = [];
        for (let t = 0; t < n; t++) this.texture[t] = i.clone();
      }
      setSize(t, e, n = 1) {
        if (this.width !== t || this.height !== e || this.depth !== n) {
          (this.width = t), (this.height = e), (this.depth = n);
          for (let i = 0, r = this.texture.length; i < r; i++)
            (this.texture[i].image.width = t),
              (this.texture[i].image.height = e),
              (this.texture[i].image.depth = n);
          this.dispose();
        }
        return (
          this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e), this
        );
      }
      copy(t) {
        this.dispose(),
          (this.width = t.width),
          (this.height = t.height),
          (this.depth = t.depth),
          this.viewport.set(0, 0, this.width, this.height),
          this.scissor.set(0, 0, this.width, this.height),
          (this.depthBuffer = t.depthBuffer),
          (this.stencilBuffer = t.stencilBuffer),
          (this.depthTexture = t.depthTexture),
          (this.texture.length = 0);
        for (let e = 0, n = t.texture.length; e < n; e++)
          this.texture[e] = t.texture[e].clone();
        return this;
      }
    }.prototype.isWebGLMultipleRenderTargets = !0);
    class wn extends _n {
      constructor(t, e, n = {}) {
        super(t, e, n),
          (this.samples = 4),
          (this.ignoreDepthForMultisampleCopy =
            void 0 === n.ignoreDepth || n.ignoreDepth),
          (this.useRenderToTexture =
            void 0 !== n.useRenderToTexture && n.useRenderToTexture),
          (this.useRenderbuffer = !1 === this.useRenderToTexture);
      }
      copy(t) {
        return (
          super.copy.call(this, t),
          (this.samples = t.samples),
          (this.useRenderToTexture = t.useRenderToTexture),
          (this.useRenderbuffer = t.useRenderbuffer),
          this
        );
      }
    }
    wn.prototype.isWebGLMultisampleRenderTarget = !0;
    class Sn {
      constructor(t = 0, e = 0, n = 0, i = 1) {
        (this._x = t), (this._y = e), (this._z = n), (this._w = i);
      }
      static slerp(t, e, n, i) {
        return (
          console.warn(
            "THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."
          ),
          n.slerpQuaternions(t, e, i)
        );
      }
      static slerpFlat(t, e, n, i, r, s, o) {
        let a = n[i + 0],
          l = n[i + 1],
          c = n[i + 2],
          u = n[i + 3];
        const h = r[s + 0],
          d = r[s + 1],
          p = r[s + 2],
          f = r[s + 3];
        if (0 === o)
          return (
            (t[e + 0] = a), (t[e + 1] = l), (t[e + 2] = c), void (t[e + 3] = u)
          );
        if (1 === o)
          return (
            (t[e + 0] = h), (t[e + 1] = d), (t[e + 2] = p), void (t[e + 3] = f)
          );
        if (u !== f || a !== h || l !== d || c !== p) {
          let t = 1 - o;
          const e = a * h + l * d + c * p + u * f,
            n = e >= 0 ? 1 : -1,
            i = 1 - e * e;
          if (i > Number.EPSILON) {
            const r = Math.sqrt(i),
              s = Math.atan2(r, e * n);
            (t = Math.sin(t * s) / r), (o = Math.sin(o * s) / r);
          }
          const r = o * n;
          if (
            ((a = a * t + h * r),
            (l = l * t + d * r),
            (c = c * t + p * r),
            (u = u * t + f * r),
            t === 1 - o)
          ) {
            const t = 1 / Math.sqrt(a * a + l * l + c * c + u * u);
            (a *= t), (l *= t), (c *= t), (u *= t);
          }
        }
        (t[e] = a), (t[e + 1] = l), (t[e + 2] = c), (t[e + 3] = u);
      }
      static multiplyQuaternionsFlat(t, e, n, i, r, s) {
        const o = n[i],
          a = n[i + 1],
          l = n[i + 2],
          c = n[i + 3],
          u = r[s],
          h = r[s + 1],
          d = r[s + 2],
          p = r[s + 3];
        return (
          (t[e] = o * p + c * u + a * d - l * h),
          (t[e + 1] = a * p + c * h + l * u - o * d),
          (t[e + 2] = l * p + c * d + o * h - a * u),
          (t[e + 3] = c * p - o * u - a * h - l * d),
          t
        );
      }
      get x() {
        return this._x;
      }
      set x(t) {
        (this._x = t), this._onChangeCallback();
      }
      get y() {
        return this._y;
      }
      set y(t) {
        (this._y = t), this._onChangeCallback();
      }
      get z() {
        return this._z;
      }
      set z(t) {
        (this._z = t), this._onChangeCallback();
      }
      get w() {
        return this._w;
      }
      set w(t) {
        (this._w = t), this._onChangeCallback();
      }
      set(t, e, n, i) {
        return (
          (this._x = t),
          (this._y = e),
          (this._z = n),
          (this._w = i),
          this._onChangeCallback(),
          this
        );
      }
      clone() {
        return new this.constructor(this._x, this._y, this._z, this._w);
      }
      copy(t) {
        return (
          (this._x = t.x),
          (this._y = t.y),
          (this._z = t.z),
          (this._w = t.w),
          this._onChangeCallback(),
          this
        );
      }
      setFromEuler(t, e) {
        if (!t || !t.isEuler)
          throw new Error(
            "THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order."
          );
        const n = t._x,
          i = t._y,
          r = t._z,
          s = t._order,
          o = Math.cos,
          a = Math.sin,
          l = o(n / 2),
          c = o(i / 2),
          u = o(r / 2),
          h = a(n / 2),
          d = a(i / 2),
          p = a(r / 2);
        switch (s) {
          case "XYZ":
            (this._x = h * c * u + l * d * p),
              (this._y = l * d * u - h * c * p),
              (this._z = l * c * p + h * d * u),
              (this._w = l * c * u - h * d * p);
            break;
          case "YXZ":
            (this._x = h * c * u + l * d * p),
              (this._y = l * d * u - h * c * p),
              (this._z = l * c * p - h * d * u),
              (this._w = l * c * u + h * d * p);
            break;
          case "ZXY":
            (this._x = h * c * u - l * d * p),
              (this._y = l * d * u + h * c * p),
              (this._z = l * c * p + h * d * u),
              (this._w = l * c * u - h * d * p);
            break;
          case "ZYX":
            (this._x = h * c * u - l * d * p),
              (this._y = l * d * u + h * c * p),
              (this._z = l * c * p - h * d * u),
              (this._w = l * c * u + h * d * p);
            break;
          case "YZX":
            (this._x = h * c * u + l * d * p),
              (this._y = l * d * u + h * c * p),
              (this._z = l * c * p - h * d * u),
              (this._w = l * c * u - h * d * p);
            break;
          case "XZY":
            (this._x = h * c * u - l * d * p),
              (this._y = l * d * u - h * c * p),
              (this._z = l * c * p + h * d * u),
              (this._w = l * c * u + h * d * p);
            break;
          default:
            console.warn(
              "THREE.Quaternion: .setFromEuler() encountered an unknown order: " +
                s
            );
        }
        return !1 !== e && this._onChangeCallback(), this;
      }
      setFromAxisAngle(t, e) {
        const n = e / 2,
          i = Math.sin(n);
        return (
          (this._x = t.x * i),
          (this._y = t.y * i),
          (this._z = t.z * i),
          (this._w = Math.cos(n)),
          this._onChangeCallback(),
          this
        );
      }
      setFromRotationMatrix(t) {
        const e = t.elements,
          n = e[0],
          i = e[4],
          r = e[8],
          s = e[1],
          o = e[5],
          a = e[9],
          l = e[2],
          c = e[6],
          u = e[10],
          h = n + o + u;
        if (h > 0) {
          const t = 0.5 / Math.sqrt(h + 1);
          (this._w = 0.25 / t),
            (this._x = (c - a) * t),
            (this._y = (r - l) * t),
            (this._z = (s - i) * t);
        } else if (n > o && n > u) {
          const t = 2 * Math.sqrt(1 + n - o - u);
          (this._w = (c - a) / t),
            (this._x = 0.25 * t),
            (this._y = (i + s) / t),
            (this._z = (r + l) / t);
        } else if (o > u) {
          const t = 2 * Math.sqrt(1 + o - n - u);
          (this._w = (r - l) / t),
            (this._x = (i + s) / t),
            (this._y = 0.25 * t),
            (this._z = (a + c) / t);
        } else {
          const t = 2 * Math.sqrt(1 + u - n - o);
          (this._w = (s - i) / t),
            (this._x = (r + l) / t),
            (this._y = (a + c) / t),
            (this._z = 0.25 * t);
        }
        return this._onChangeCallback(), this;
      }
      setFromUnitVectors(t, e) {
        let n = t.dot(e) + 1;
        return (
          n < Number.EPSILON
            ? ((n = 0),
              Math.abs(t.x) > Math.abs(t.z)
                ? ((this._x = -t.y),
                  (this._y = t.x),
                  (this._z = 0),
                  (this._w = n))
                : ((this._x = 0),
                  (this._y = -t.z),
                  (this._z = t.y),
                  (this._w = n)))
            : ((this._x = t.y * e.z - t.z * e.y),
              (this._y = t.z * e.x - t.x * e.z),
              (this._z = t.x * e.y - t.y * e.x),
              (this._w = n)),
          this.normalize()
        );
      }
      angleTo(t) {
        return 2 * Math.acos(Math.abs(on(this.dot(t), -1, 1)));
      }
      rotateTowards(t, e) {
        const n = this.angleTo(t);
        if (0 === n) return this;
        const i = Math.min(1, e / n);
        return this.slerp(t, i), this;
      }
      identity() {
        return this.set(0, 0, 0, 1);
      }
      invert() {
        return this.conjugate();
      }
      conjugate() {
        return (
          (this._x *= -1),
          (this._y *= -1),
          (this._z *= -1),
          this._onChangeCallback(),
          this
        );
      }
      dot(t) {
        return (
          this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w
        );
      }
      lengthSq() {
        return (
          this._x * this._x +
          this._y * this._y +
          this._z * this._z +
          this._w * this._w
        );
      }
      length() {
        return Math.sqrt(
          this._x * this._x +
            this._y * this._y +
            this._z * this._z +
            this._w * this._w
        );
      }
      normalize() {
        let t = this.length();
        return (
          0 === t
            ? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1))
            : ((t = 1 / t),
              (this._x = this._x * t),
              (this._y = this._y * t),
              (this._z = this._z * t),
              (this._w = this._w * t)),
          this._onChangeCallback(),
          this
        );
      }
      multiply(t, e) {
        return void 0 !== e
          ? (console.warn(
              "THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."
            ),
            this.multiplyQuaternions(t, e))
          : this.multiplyQuaternions(this, t);
      }
      premultiply(t) {
        return this.multiplyQuaternions(t, this);
      }
      multiplyQuaternions(t, e) {
        const n = t._x,
          i = t._y,
          r = t._z,
          s = t._w,
          o = e._x,
          a = e._y,
          l = e._z,
          c = e._w;
        return (
          (this._x = n * c + s * o + i * l - r * a),
          (this._y = i * c + s * a + r * o - n * l),
          (this._z = r * c + s * l + n * a - i * o),
          (this._w = s * c - n * o - i * a - r * l),
          this._onChangeCallback(),
          this
        );
      }
      slerp(t, e) {
        if (0 === e) return this;
        if (1 === e) return this.copy(t);
        const n = this._x,
          i = this._y,
          r = this._z,
          s = this._w;
        let o = s * t._w + n * t._x + i * t._y + r * t._z;
        if (
          (o < 0
            ? ((this._w = -t._w),
              (this._x = -t._x),
              (this._y = -t._y),
              (this._z = -t._z),
              (o = -o))
            : this.copy(t),
          o >= 1)
        )
          return (
            (this._w = s), (this._x = n), (this._y = i), (this._z = r), this
          );
        const a = 1 - o * o;
        if (a <= Number.EPSILON) {
          const t = 1 - e;
          return (
            (this._w = t * s + e * this._w),
            (this._x = t * n + e * this._x),
            (this._y = t * i + e * this._y),
            (this._z = t * r + e * this._z),
            this.normalize(),
            this._onChangeCallback(),
            this
          );
        }
        const l = Math.sqrt(a),
          c = Math.atan2(l, o),
          u = Math.sin((1 - e) * c) / l,
          h = Math.sin(e * c) / l;
        return (
          (this._w = s * u + this._w * h),
          (this._x = n * u + this._x * h),
          (this._y = i * u + this._y * h),
          (this._z = r * u + this._z * h),
          this._onChangeCallback(),
          this
        );
      }
      slerpQuaternions(t, e, n) {
        this.copy(t).slerp(e, n);
      }
      random() {
        const t = Math.random(),
          e = Math.sqrt(1 - t),
          n = Math.sqrt(t),
          i = 2 * Math.PI * Math.random(),
          r = 2 * Math.PI * Math.random();
        return this.set(
          e * Math.cos(i),
          n * Math.sin(r),
          n * Math.cos(r),
          e * Math.sin(i)
        );
      }
      equals(t) {
        return (
          t._x === this._x &&
          t._y === this._y &&
          t._z === this._z &&
          t._w === this._w
        );
      }
      fromArray(t, e = 0) {
        return (
          (this._x = t[e]),
          (this._y = t[e + 1]),
          (this._z = t[e + 2]),
          (this._w = t[e + 3]),
          this._onChangeCallback(),
          this
        );
      }
      toArray(t = [], e = 0) {
        return (
          (t[e] = this._x),
          (t[e + 1] = this._y),
          (t[e + 2] = this._z),
          (t[e + 3] = this._w),
          t
        );
      }
      fromBufferAttribute(t, e) {
        return (
          (this._x = t.getX(e)),
          (this._y = t.getY(e)),
          (this._z = t.getZ(e)),
          (this._w = t.getW(e)),
          this
        );
      }
      _onChange(t) {
        return (this._onChangeCallback = t), this;
      }
      _onChangeCallback() {}
    }
    Sn.prototype.isQuaternion = !0;
    class Mn {
      constructor(t = 0, e = 0, n = 0) {
        (this.x = t), (this.y = e), (this.z = n);
      }
      set(t, e, n) {
        return (
          void 0 === n && (n = this.z),
          (this.x = t),
          (this.y = e),
          (this.z = n),
          this
        );
      }
      setScalar(t) {
        return (this.x = t), (this.y = t), (this.z = t), this;
      }
      setX(t) {
        return (this.x = t), this;
      }
      setY(t) {
        return (this.y = t), this;
      }
      setZ(t) {
        return (this.z = t), this;
      }
      setComponent(t, e) {
        switch (t) {
          case 0:
            this.x = e;
            break;
          case 1:
            this.y = e;
            break;
          case 2:
            this.z = e;
            break;
          default:
            throw new Error("index is out of range: " + t);
        }
        return this;
      }
      getComponent(t) {
        switch (t) {
          case 0:
            return this.x;
          case 1:
            return this.y;
          case 2:
            return this.z;
          default:
            throw new Error("index is out of range: " + t);
        }
      }
      clone() {
        return new this.constructor(this.x, this.y, this.z);
      }
      copy(t) {
        return (this.x = t.x), (this.y = t.y), (this.z = t.z), this;
      }
      add(t, e) {
        return void 0 !== e
          ? (console.warn(
              "THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
            ),
            this.addVectors(t, e))
          : ((this.x += t.x), (this.y += t.y), (this.z += t.z), this);
      }
      addScalar(t) {
        return (this.x += t), (this.y += t), (this.z += t), this;
      }
      addVectors(t, e) {
        return (
          (this.x = t.x + e.x), (this.y = t.y + e.y), (this.z = t.z + e.z), this
        );
      }
      addScaledVector(t, e) {
        return (
          (this.x += t.x * e), (this.y += t.y * e), (this.z += t.z * e), this
        );
      }
      sub(t, e) {
        return void 0 !== e
          ? (console.warn(
              "THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
            ),
            this.subVectors(t, e))
          : ((this.x -= t.x), (this.y -= t.y), (this.z -= t.z), this);
      }
      subScalar(t) {
        return (this.x -= t), (this.y -= t), (this.z -= t), this;
      }
      subVectors(t, e) {
        return (
          (this.x = t.x - e.x), (this.y = t.y - e.y), (this.z = t.z - e.z), this
        );
      }
      multiply(t, e) {
        return void 0 !== e
          ? (console.warn(
              "THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."
            ),
            this.multiplyVectors(t, e))
          : ((this.x *= t.x), (this.y *= t.y), (this.z *= t.z), this);
      }
      multiplyScalar(t) {
        return (this.x *= t), (this.y *= t), (this.z *= t), this;
      }
      multiplyVectors(t, e) {
        return (
          (this.x = t.x * e.x), (this.y = t.y * e.y), (this.z = t.z * e.z), this
        );
      }
      applyEuler(t) {
        return (
          (t && t.isEuler) ||
            console.error(
              "THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."
            ),
          this.applyQuaternion(En.setFromEuler(t))
        );
      }
      applyAxisAngle(t, e) {
        return this.applyQuaternion(En.setFromAxisAngle(t, e));
      }
      applyMatrix3(t) {
        const e = this.x,
          n = this.y,
          i = this.z,
          r = t.elements;
        return (
          (this.x = r[0] * e + r[3] * n + r[6] * i),
          (this.y = r[1] * e + r[4] * n + r[7] * i),
          (this.z = r[2] * e + r[5] * n + r[8] * i),
          this
        );
      }
      applyNormalMatrix(t) {
        return this.applyMatrix3(t).normalize();
      }
      applyMatrix4(t) {
        const e = this.x,
          n = this.y,
          i = this.z,
          r = t.elements,
          s = 1 / (r[3] * e + r[7] * n + r[11] * i + r[15]);
        return (
          (this.x = (r[0] * e + r[4] * n + r[8] * i + r[12]) * s),
          (this.y = (r[1] * e + r[5] * n + r[9] * i + r[13]) * s),
          (this.z = (r[2] * e + r[6] * n + r[10] * i + r[14]) * s),
          this
        );
      }
      applyQuaternion(t) {
        const e = this.x,
          n = this.y,
          i = this.z,
          r = t.x,
          s = t.y,
          o = t.z,
          a = t.w,
          l = a * e + s * i - o * n,
          c = a * n + o * e - r * i,
          u = a * i + r * n - s * e,
          h = -r * e - s * n - o * i;
        return (
          (this.x = l * a + h * -r + c * -o - u * -s),
          (this.y = c * a + h * -s + u * -r - l * -o),
          (this.z = u * a + h * -o + l * -s - c * -r),
          this
        );
      }
      project(t) {
        return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(
          t.projectionMatrix
        );
      }
      unproject(t) {
        return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(
          t.matrixWorld
        );
      }
      transformDirection(t) {
        const e = this.x,
          n = this.y,
          i = this.z,
          r = t.elements;
        return (
          (this.x = r[0] * e + r[4] * n + r[8] * i),
          (this.y = r[1] * e + r[5] * n + r[9] * i),
          (this.z = r[2] * e + r[6] * n + r[10] * i),
          this.normalize()
        );
      }
      divide(t) {
        return (this.x /= t.x), (this.y /= t.y), (this.z /= t.z), this;
      }
      divideScalar(t) {
        return this.multiplyScalar(1 / t);
      }
      min(t) {
        return (
          (this.x = Math.min(this.x, t.x)),
          (this.y = Math.min(this.y, t.y)),
          (this.z = Math.min(this.z, t.z)),
          this
        );
      }
      max(t) {
        return (
          (this.x = Math.max(this.x, t.x)),
          (this.y = Math.max(this.y, t.y)),
          (this.z = Math.max(this.z, t.z)),
          this
        );
      }
      clamp(t, e) {
        return (
          (this.x = Math.max(t.x, Math.min(e.x, this.x))),
          (this.y = Math.max(t.y, Math.min(e.y, this.y))),
          (this.z = Math.max(t.z, Math.min(e.z, this.z))),
          this
        );
      }
      clampScalar(t, e) {
        return (
          (this.x = Math.max(t, Math.min(e, this.x))),
          (this.y = Math.max(t, Math.min(e, this.y))),
          (this.z = Math.max(t, Math.min(e, this.z))),
          this
        );
      }
      clampLength(t, e) {
        const n = this.length();
        return this.divideScalar(n || 1).multiplyScalar(
          Math.max(t, Math.min(e, n))
        );
      }
      floor() {
        return (
          (this.x = Math.floor(this.x)),
          (this.y = Math.floor(this.y)),
          (this.z = Math.floor(this.z)),
          this
        );
      }
      ceil() {
        return (
          (this.x = Math.ceil(this.x)),
          (this.y = Math.ceil(this.y)),
          (this.z = Math.ceil(this.z)),
          this
        );
      }
      round() {
        return (
          (this.x = Math.round(this.x)),
          (this.y = Math.round(this.y)),
          (this.z = Math.round(this.z)),
          this
        );
      }
      roundToZero() {
        return (
          (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
          (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
          (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
          this
        );
      }
      negate() {
        return (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this;
      }
      dot(t) {
        return this.x * t.x + this.y * t.y + this.z * t.z;
      }
      lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z;
      }
      length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
      }
      manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
      }
      normalize() {
        return this.divideScalar(this.length() || 1);
      }
      setLength(t) {
        return this.normalize().multiplyScalar(t);
      }
      lerp(t, e) {
        return (
          (this.x += (t.x - this.x) * e),
          (this.y += (t.y - this.y) * e),
          (this.z += (t.z - this.z) * e),
          this
        );
      }
      lerpVectors(t, e, n) {
        return (
          (this.x = t.x + (e.x - t.x) * n),
          (this.y = t.y + (e.y - t.y) * n),
          (this.z = t.z + (e.z - t.z) * n),
          this
        );
      }
      cross(t, e) {
        return void 0 !== e
          ? (console.warn(
              "THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."
            ),
            this.crossVectors(t, e))
          : this.crossVectors(this, t);
      }
      crossVectors(t, e) {
        const n = t.x,
          i = t.y,
          r = t.z,
          s = e.x,
          o = e.y,
          a = e.z;
        return (
          (this.x = i * a - r * o),
          (this.y = r * s - n * a),
          (this.z = n * o - i * s),
          this
        );
      }
      projectOnVector(t) {
        const e = t.lengthSq();
        if (0 === e) return this.set(0, 0, 0);
        const n = t.dot(this) / e;
        return this.copy(t).multiplyScalar(n);
      }
      projectOnPlane(t) {
        return Tn.copy(this).projectOnVector(t), this.sub(Tn);
      }
      reflect(t) {
        return this.sub(Tn.copy(t).multiplyScalar(2 * this.dot(t)));
      }
      angleTo(t) {
        const e = Math.sqrt(this.lengthSq() * t.lengthSq());
        if (0 === e) return Math.PI / 2;
        const n = this.dot(t) / e;
        return Math.acos(on(n, -1, 1));
      }
      distanceTo(t) {
        return Math.sqrt(this.distanceToSquared(t));
      }
      distanceToSquared(t) {
        const e = this.x - t.x,
          n = this.y - t.y,
          i = this.z - t.z;
        return e * e + n * n + i * i;
      }
      manhattanDistanceTo(t) {
        return (
          Math.abs(this.x - t.x) +
          Math.abs(this.y - t.y) +
          Math.abs(this.z - t.z)
        );
      }
      setFromSpherical(t) {
        return this.setFromSphericalCoords(t.radius, t.phi, t.theta);
      }
      setFromSphericalCoords(t, e, n) {
        const i = Math.sin(e) * t;
        return (
          (this.x = i * Math.sin(n)),
          (this.y = Math.cos(e) * t),
          (this.z = i * Math.cos(n)),
          this
        );
      }
      setFromCylindrical(t) {
        return this.setFromCylindricalCoords(t.radius, t.theta, t.y);
      }
      setFromCylindricalCoords(t, e, n) {
        return (
          (this.x = t * Math.sin(e)),
          (this.y = n),
          (this.z = t * Math.cos(e)),
          this
        );
      }
      setFromMatrixPosition(t) {
        const e = t.elements;
        return (this.x = e[12]), (this.y = e[13]), (this.z = e[14]), this;
      }
      setFromMatrixScale(t) {
        const e = this.setFromMatrixColumn(t, 0).length(),
          n = this.setFromMatrixColumn(t, 1).length(),
          i = this.setFromMatrixColumn(t, 2).length();
        return (this.x = e), (this.y = n), (this.z = i), this;
      }
      setFromMatrixColumn(t, e) {
        return this.fromArray(t.elements, 4 * e);
      }
      setFromMatrix3Column(t, e) {
        return this.fromArray(t.elements, 3 * e);
      }
      equals(t) {
        return t.x === this.x && t.y === this.y && t.z === this.z;
      }
      fromArray(t, e = 0) {
        return (this.x = t[e]), (this.y = t[e + 1]), (this.z = t[e + 2]), this;
      }
      toArray(t = [], e = 0) {
        return (t[e] = this.x), (t[e + 1] = this.y), (t[e + 2] = this.z), t;
      }
      fromBufferAttribute(t, e, n) {
        return (
          void 0 !== n &&
            console.warn(
              "THREE.Vector3: offset has been removed from .fromBufferAttribute()."
            ),
          (this.x = t.getX(e)),
          (this.y = t.getY(e)),
          (this.z = t.getZ(e)),
          this
        );
      }
      random() {
        return (
          (this.x = Math.random()),
          (this.y = Math.random()),
          (this.z = Math.random()),
          this
        );
      }
      randomDirection() {
        const t = 2 * (Math.random() - 0.5),
          e = Math.random() * Math.PI * 2,
          n = Math.sqrt(1 - t ** 2);
        return (
          (this.x = n * Math.cos(e)),
          (this.y = n * Math.sin(e)),
          (this.z = t),
          this
        );
      }
      *[Symbol.iterator]() {
        yield this.x, yield this.y, yield this.z;
      }
    }
    Mn.prototype.isVector3 = !0;
    const Tn = new Mn(),
      En = new Sn();
    class An {
      constructor(
        t = new Mn(1 / 0, 1 / 0, 1 / 0),
        e = new Mn(-1 / 0, -1 / 0, -1 / 0)
      ) {
        (this.min = t), (this.max = e);
      }
      set(t, e) {
        return this.min.copy(t), this.max.copy(e), this;
      }
      setFromArray(t) {
        let e = 1 / 0,
          n = 1 / 0,
          i = 1 / 0,
          r = -1 / 0,
          s = -1 / 0,
          o = -1 / 0;
        for (let a = 0, l = t.length; a < l; a += 3) {
          const l = t[a],
            c = t[a + 1],
            u = t[a + 2];
          l < e && (e = l),
            c < n && (n = c),
            u < i && (i = u),
            l > r && (r = l),
            c > s && (s = c),
            u > o && (o = u);
        }
        return this.min.set(e, n, i), this.max.set(r, s, o), this;
      }
      setFromBufferAttribute(t) {
        let e = 1 / 0,
          n = 1 / 0,
          i = 1 / 0,
          r = -1 / 0,
          s = -1 / 0,
          o = -1 / 0;
        for (let a = 0, l = t.count; a < l; a++) {
          const l = t.getX(a),
            c = t.getY(a),
            u = t.getZ(a);
          l < e && (e = l),
            c < n && (n = c),
            u < i && (i = u),
            l > r && (r = l),
            c > s && (s = c),
            u > o && (o = u);
        }
        return this.min.set(e, n, i), this.max.set(r, s, o), this;
      }
      setFromPoints(t) {
        this.makeEmpty();
        for (let e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]);
        return this;
      }
      setFromCenterAndSize(t, e) {
        const n = Ln.copy(e).multiplyScalar(0.5);
        return this.min.copy(t).sub(n), this.max.copy(t).add(n), this;
      }
      setFromObject(t) {
        return this.makeEmpty(), this.expandByObject(t);
      }
      clone() {
        return new this.constructor().copy(this);
      }
      copy(t) {
        return this.min.copy(t.min), this.max.copy(t.max), this;
      }
      makeEmpty() {
        return (
          (this.min.x = this.min.y = this.min.z = 1 / 0),
          (this.max.x = this.max.y = this.max.z = -1 / 0),
          this
        );
      }
      isEmpty() {
        return (
          this.max.x < this.min.x ||
          this.max.y < this.min.y ||
          this.max.z < this.min.z
        );
      }
      getCenter(t) {
        return this.isEmpty()
          ? t.set(0, 0, 0)
          : t.addVectors(this.min, this.max).multiplyScalar(0.5);
      }
      getSize(t) {
        return this.isEmpty()
          ? t.set(0, 0, 0)
          : t.subVectors(this.max, this.min);
      }
      expandByPoint(t) {
        return this.min.min(t), this.max.max(t), this;
      }
      expandByVector(t) {
        return this.min.sub(t), this.max.add(t), this;
      }
      expandByScalar(t) {
        return this.min.addScalar(-t), this.max.addScalar(t), this;
      }
      expandByObject(t) {
        t.updateWorldMatrix(!1, !1);
        const e = t.geometry;
        void 0 !== e &&
          (null === e.boundingBox && e.computeBoundingBox(),
          Rn.copy(e.boundingBox),
          Rn.applyMatrix4(t.matrixWorld),
          this.union(Rn));
        const n = t.children;
        for (let t = 0, e = n.length; t < e; t++) this.expandByObject(n[t]);
        return this;
      }
      containsPoint(t) {
        return !(
          t.x < this.min.x ||
          t.x > this.max.x ||
          t.y < this.min.y ||
          t.y > this.max.y ||
          t.z < this.min.z ||
          t.z > this.max.z
        );
      }
      containsBox(t) {
        return (
          this.min.x <= t.min.x &&
          t.max.x <= this.max.x &&
          this.min.y <= t.min.y &&
          t.max.y <= this.max.y &&
          this.min.z <= t.min.z &&
          t.max.z <= this.max.z
        );
      }
      getParameter(t, e) {
        return e.set(
          (t.x - this.min.x) / (this.max.x - this.min.x),
          (t.y - this.min.y) / (this.max.y - this.min.y),
          (t.z - this.min.z) / (this.max.z - this.min.z)
        );
      }
      intersectsBox(t) {
        return !(
          t.max.x < this.min.x ||
          t.min.x > this.max.x ||
          t.max.y < this.min.y ||
          t.min.y > this.max.y ||
          t.max.z < this.min.z ||
          t.min.z > this.max.z
        );
      }
      intersectsSphere(t) {
        return (
          this.clampPoint(t.center, Ln),
          Ln.distanceToSquared(t.center) <= t.radius * t.radius
        );
      }
      intersectsPlane(t) {
        let e, n;
        return (
          t.normal.x > 0
            ? ((e = t.normal.x * this.min.x), (n = t.normal.x * this.max.x))
            : ((e = t.normal.x * this.max.x), (n = t.normal.x * this.min.x)),
          t.normal.y > 0
            ? ((e += t.normal.y * this.min.y), (n += t.normal.y * this.max.y))
            : ((e += t.normal.y * this.max.y), (n += t.normal.y * this.min.y)),
          t.normal.z > 0
            ? ((e += t.normal.z * this.min.z), (n += t.normal.z * this.max.z))
            : ((e += t.normal.z * this.max.z), (n += t.normal.z * this.min.z)),
          e <= -t.constant && n >= -t.constant
        );
      }
      intersectsTriangle(t) {
        if (this.isEmpty()) return !1;
        this.getCenter(zn),
          Hn.subVectors(this.max, zn),
          Pn.subVectors(t.a, zn),
          Dn.subVectors(t.b, zn),
          kn.subVectors(t.c, zn),
          In.subVectors(Dn, Pn),
          Nn.subVectors(kn, Dn),
          On.subVectors(Pn, kn);
        let e = [
          0,
          -In.z,
          In.y,
          0,
          -Nn.z,
          Nn.y,
          0,
          -On.z,
          On.y,
          In.z,
          0,
          -In.x,
          Nn.z,
          0,
          -Nn.x,
          On.z,
          0,
          -On.x,
          -In.y,
          In.x,
          0,
          -Nn.y,
          Nn.x,
          0,
          -On.y,
          On.x,
          0,
        ];
        return (
          !!Fn(e, Pn, Dn, kn, Hn) &&
          ((e = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
          !!Fn(e, Pn, Dn, kn, Hn) &&
            (Bn.crossVectors(In, Nn),
            (e = [Bn.x, Bn.y, Bn.z]),
            Fn(e, Pn, Dn, kn, Hn)))
        );
      }
      clampPoint(t, e) {
        return e.copy(t).clamp(this.min, this.max);
      }
      distanceToPoint(t) {
        return Ln.copy(t).clamp(this.min, this.max).sub(t).length();
      }
      getBoundingSphere(t) {
        return (
          this.getCenter(t.center),
          (t.radius = 0.5 * this.getSize(Ln).length()),
          t
        );
      }
      intersect(t) {
        return (
          this.min.max(t.min),
          this.max.min(t.max),
          this.isEmpty() && this.makeEmpty(),
          this
        );
      }
      union(t) {
        return this.min.min(t.min), this.max.max(t.max), this;
      }
      applyMatrix4(t) {
        return this.isEmpty()
          ? this
          : (Cn[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t),
            Cn[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t),
            Cn[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t),
            Cn[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t),
            Cn[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t),
            Cn[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t),
            Cn[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t),
            Cn[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t),
            this.setFromPoints(Cn),
            this);
      }
      translate(t) {
        return this.min.add(t), this.max.add(t), this;
      }
      equals(t) {
        return t.min.equals(this.min) && t.max.equals(this.max);
      }
    }
    An.prototype.isBox3 = !0;
    const Cn = [
        new Mn(),
        new Mn(),
        new Mn(),
        new Mn(),
        new Mn(),
        new Mn(),
        new Mn(),
        new Mn(),
      ],
      Ln = new Mn(),
      Rn = new An(),
      Pn = new Mn(),
      Dn = new Mn(),
      kn = new Mn(),
      In = new Mn(),
      Nn = new Mn(),
      On = new Mn(),
      zn = new Mn(),
      Hn = new Mn(),
      Bn = new Mn(),
      Un = new Mn();
    function Fn(t, e, n, i, r) {
      for (let s = 0, o = t.length - 3; s <= o; s += 3) {
        Un.fromArray(t, s);
        const o =
            r.x * Math.abs(Un.x) + r.y * Math.abs(Un.y) + r.z * Math.abs(Un.z),
          a = e.dot(Un),
          l = n.dot(Un),
          c = i.dot(Un);
        if (Math.max(-Math.max(a, l, c), Math.min(a, l, c)) > o) return !1;
      }
      return !0;
    }
    const Vn = new An(),
      Wn = new Mn(),
      Gn = new Mn(),
      jn = new Mn();
    class qn {
      constructor(t = new Mn(), e = -1) {
        (this.center = t), (this.radius = e);
      }
      set(t, e) {
        return this.center.copy(t), (this.radius = e), this;
      }
      setFromPoints(t, e) {
        const n = this.center;
        void 0 !== e ? n.copy(e) : Vn.setFromPoints(t).getCenter(n);
        let i = 0;
        for (let e = 0, r = t.length; e < r; e++)
          i = Math.max(i, n.distanceToSquared(t[e]));
        return (this.radius = Math.sqrt(i)), this;
      }
      copy(t) {
        return this.center.copy(t.center), (this.radius = t.radius), this;
      }
      isEmpty() {
        return this.radius < 0;
      }
      makeEmpty() {
        return this.center.set(0, 0, 0), (this.radius = -1), this;
      }
      containsPoint(t) {
        return t.distanceToSquared(this.center) <= this.radius * this.radius;
      }
      distanceToPoint(t) {
        return t.distanceTo(this.center) - this.radius;
      }
      intersectsSphere(t) {
        const e = this.radius + t.radius;
        return t.center.distanceToSquared(this.center) <= e * e;
      }
      intersectsBox(t) {
        return t.intersectsSphere(this);
      }
      intersectsPlane(t) {
        return Math.abs(t.distanceToPoint(this.center)) <= this.radius;
      }
      clampPoint(t, e) {
        const n = this.center.distanceToSquared(t);
        return (
          e.copy(t),
          n > this.radius * this.radius &&
            (e.sub(this.center).normalize(),
            e.multiplyScalar(this.radius).add(this.center)),
          e
        );
      }
      getBoundingBox(t) {
        return this.isEmpty()
          ? (t.makeEmpty(), t)
          : (t.set(this.center, this.center), t.expandByScalar(this.radius), t);
      }
      applyMatrix4(t) {
        return (
          this.center.applyMatrix4(t),
          (this.radius = this.radius * t.getMaxScaleOnAxis()),
          this
        );
      }
      translate(t) {
        return this.center.add(t), this;
      }
      expandByPoint(t) {
        jn.subVectors(t, this.center);
        const e = jn.lengthSq();
        if (e > this.radius * this.radius) {
          const t = Math.sqrt(e),
            n = 0.5 * (t - this.radius);
          this.center.add(jn.multiplyScalar(n / t)), (this.radius += n);
        }
        return this;
      }
      union(t) {
        return (
          !0 === this.center.equals(t.center)
            ? Gn.set(0, 0, 1).multiplyScalar(t.radius)
            : Gn.subVectors(t.center, this.center)
                .normalize()
                .multiplyScalar(t.radius),
          this.expandByPoint(Wn.copy(t.center).add(Gn)),
          this.expandByPoint(Wn.copy(t.center).sub(Gn)),
          this
        );
      }
      equals(t) {
        return t.center.equals(this.center) && t.radius === this.radius;
      }
      clone() {
        return new this.constructor().copy(this);
      }
    }
    const $n = new Mn(),
      Xn = new Mn(),
      Jn = new Mn(),
      Yn = new Mn(),
      Zn = new Mn(),
      Qn = new Mn(),
      Kn = new Mn();
    class ti {
      constructor(t = new Mn(), e = new Mn(0, 0, -1)) {
        (this.origin = t), (this.direction = e);
      }
      set(t, e) {
        return this.origin.copy(t), this.direction.copy(e), this;
      }
      copy(t) {
        return (
          this.origin.copy(t.origin), this.direction.copy(t.direction), this
        );
      }
      at(t, e) {
        return e.copy(this.direction).multiplyScalar(t).add(this.origin);
      }
      lookAt(t) {
        return this.direction.copy(t).sub(this.origin).normalize(), this;
      }
      recast(t) {
        return this.origin.copy(this.at(t, $n)), this;
      }
      closestPointToPoint(t, e) {
        e.subVectors(t, this.origin);
        const n = e.dot(this.direction);
        return n < 0
          ? e.copy(this.origin)
          : e.copy(this.direction).multiplyScalar(n).add(this.origin);
      }
      distanceToPoint(t) {
        return Math.sqrt(this.distanceSqToPoint(t));
      }
      distanceSqToPoint(t) {
        const e = $n.subVectors(t, this.origin).dot(this.direction);
        return e < 0
          ? this.origin.distanceToSquared(t)
          : ($n.copy(this.direction).multiplyScalar(e).add(this.origin),
            $n.distanceToSquared(t));
      }
      distanceSqToSegment(t, e, n, i) {
        Xn.copy(t).add(e).multiplyScalar(0.5),
          Jn.copy(e).sub(t).normalize(),
          Yn.copy(this.origin).sub(Xn);
        const r = 0.5 * t.distanceTo(e),
          s = -this.direction.dot(Jn),
          o = Yn.dot(this.direction),
          a = -Yn.dot(Jn),
          l = Yn.lengthSq(),
          c = Math.abs(1 - s * s);
        let u, h, d, p;
        if (c > 0)
          if (((u = s * a - o), (h = s * o - a), (p = r * c), u >= 0))
            if (h >= -p)
              if (h <= p) {
                const t = 1 / c;
                (u *= t),
                  (h *= t),
                  (d = u * (u + s * h + 2 * o) + h * (s * u + h + 2 * a) + l);
              } else
                (h = r),
                  (u = Math.max(0, -(s * h + o))),
                  (d = -u * u + h * (h + 2 * a) + l);
            else
              (h = -r),
                (u = Math.max(0, -(s * h + o))),
                (d = -u * u + h * (h + 2 * a) + l);
          else
            h <= -p
              ? ((u = Math.max(0, -(-s * r + o))),
                (h = u > 0 ? -r : Math.min(Math.max(-r, -a), r)),
                (d = -u * u + h * (h + 2 * a) + l))
              : h <= p
              ? ((u = 0),
                (h = Math.min(Math.max(-r, -a), r)),
                (d = h * (h + 2 * a) + l))
              : ((u = Math.max(0, -(s * r + o))),
                (h = u > 0 ? r : Math.min(Math.max(-r, -a), r)),
                (d = -u * u + h * (h + 2 * a) + l));
        else
          (h = s > 0 ? -r : r),
            (u = Math.max(0, -(s * h + o))),
            (d = -u * u + h * (h + 2 * a) + l);
        return (
          n && n.copy(this.direction).multiplyScalar(u).add(this.origin),
          i && i.copy(Jn).multiplyScalar(h).add(Xn),
          d
        );
      }
      intersectSphere(t, e) {
        $n.subVectors(t.center, this.origin);
        const n = $n.dot(this.direction),
          i = $n.dot($n) - n * n,
          r = t.radius * t.radius;
        if (i > r) return null;
        const s = Math.sqrt(r - i),
          o = n - s,
          a = n + s;
        return o < 0 && a < 0 ? null : o < 0 ? this.at(a, e) : this.at(o, e);
      }
      intersectsSphere(t) {
        return this.distanceSqToPoint(t.center) <= t.radius * t.radius;
      }
      distanceToPlane(t) {
        const e = t.normal.dot(this.direction);
        if (0 === e) return 0 === t.distanceToPoint(this.origin) ? 0 : null;
        const n = -(this.origin.dot(t.normal) + t.constant) / e;
        return n >= 0 ? n : null;
      }
      intersectPlane(t, e) {
        const n = this.distanceToPlane(t);
        return null === n ? null : this.at(n, e);
      }
      intersectsPlane(t) {
        const e = t.distanceToPoint(this.origin);
        return 0 === e || t.normal.dot(this.direction) * e < 0;
      }
      intersectBox(t, e) {
        let n, i, r, s, o, a;
        const l = 1 / this.direction.x,
          c = 1 / this.direction.y,
          u = 1 / this.direction.z,
          h = this.origin;
        return (
          l >= 0
            ? ((n = (t.min.x - h.x) * l), (i = (t.max.x - h.x) * l))
            : ((n = (t.max.x - h.x) * l), (i = (t.min.x - h.x) * l)),
          c >= 0
            ? ((r = (t.min.y - h.y) * c), (s = (t.max.y - h.y) * c))
            : ((r = (t.max.y - h.y) * c), (s = (t.min.y - h.y) * c)),
          n > s || r > i
            ? null
            : ((r > n || n != n) && (n = r),
              (s < i || i != i) && (i = s),
              u >= 0
                ? ((o = (t.min.z - h.z) * u), (a = (t.max.z - h.z) * u))
                : ((o = (t.max.z - h.z) * u), (a = (t.min.z - h.z) * u)),
              n > a || o > i
                ? null
                : ((o > n || n != n) && (n = o),
                  (a < i || i != i) && (i = a),
                  i < 0 ? null : this.at(n >= 0 ? n : i, e)))
        );
      }
      intersectsBox(t) {
        return null !== this.intersectBox(t, $n);
      }
      intersectTriangle(t, e, n, i, r) {
        Zn.subVectors(e, t), Qn.subVectors(n, t), Kn.crossVectors(Zn, Qn);
        let s,
          o = this.direction.dot(Kn);
        if (o > 0) {
          if (i) return null;
          s = 1;
        } else {
          if (!(o < 0)) return null;
          (s = -1), (o = -o);
        }
        Yn.subVectors(this.origin, t);
        const a = s * this.direction.dot(Qn.crossVectors(Yn, Qn));
        if (a < 0) return null;
        const l = s * this.direction.dot(Zn.cross(Yn));
        if (l < 0) return null;
        if (a + l > o) return null;
        const c = -s * Yn.dot(Kn);
        return c < 0 ? null : this.at(c / o, r);
      }
      applyMatrix4(t) {
        return (
          this.origin.applyMatrix4(t),
          this.direction.transformDirection(t),
          this
        );
      }
      equals(t) {
        return (
          t.origin.equals(this.origin) && t.direction.equals(this.direction)
        );
      }
      clone() {
        return new this.constructor().copy(this);
      }
    }
    class ei {
      constructor() {
        (this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
          arguments.length > 0 &&
            console.error(
              "THREE.Matrix4: the constructor no longer reads arguments. use .set() instead."
            );
      }
      set(t, e, n, i, r, s, o, a, l, c, u, h, d, p, f, m) {
        const g = this.elements;
        return (
          (g[0] = t),
          (g[4] = e),
          (g[8] = n),
          (g[12] = i),
          (g[1] = r),
          (g[5] = s),
          (g[9] = o),
          (g[13] = a),
          (g[2] = l),
          (g[6] = c),
          (g[10] = u),
          (g[14] = h),
          (g[3] = d),
          (g[7] = p),
          (g[11] = f),
          (g[15] = m),
          this
        );
      }
      identity() {
        return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
      }
      clone() {
        return new ei().fromArray(this.elements);
      }
      copy(t) {
        const e = this.elements,
          n = t.elements;
        return (
          (e[0] = n[0]),
          (e[1] = n[1]),
          (e[2] = n[2]),
          (e[3] = n[3]),
          (e[4] = n[4]),
          (e[5] = n[5]),
          (e[6] = n[6]),
          (e[7] = n[7]),
          (e[8] = n[8]),
          (e[9] = n[9]),
          (e[10] = n[10]),
          (e[11] = n[11]),
          (e[12] = n[12]),
          (e[13] = n[13]),
          (e[14] = n[14]),
          (e[15] = n[15]),
          this
        );
      }
      copyPosition(t) {
        const e = this.elements,
          n = t.elements;
        return (e[12] = n[12]), (e[13] = n[13]), (e[14] = n[14]), this;
      }
      setFromMatrix3(t) {
        const e = t.elements;
        return (
          this.set(
            e[0],
            e[3],
            e[6],
            0,
            e[1],
            e[4],
            e[7],
            0,
            e[2],
            e[5],
            e[8],
            0,
            0,
            0,
            0,
            1
          ),
          this
        );
      }
      extractBasis(t, e, n) {
        return (
          t.setFromMatrixColumn(this, 0),
          e.setFromMatrixColumn(this, 1),
          n.setFromMatrixColumn(this, 2),
          this
        );
      }
      makeBasis(t, e, n) {
        return (
          this.set(
            t.x,
            e.x,
            n.x,
            0,
            t.y,
            e.y,
            n.y,
            0,
            t.z,
            e.z,
            n.z,
            0,
            0,
            0,
            0,
            1
          ),
          this
        );
      }
      extractRotation(t) {
        const e = this.elements,
          n = t.elements,
          i = 1 / ni.setFromMatrixColumn(t, 0).length(),
          r = 1 / ni.setFromMatrixColumn(t, 1).length(),
          s = 1 / ni.setFromMatrixColumn(t, 2).length();
        return (
          (e[0] = n[0] * i),
          (e[1] = n[1] * i),
          (e[2] = n[2] * i),
          (e[3] = 0),
          (e[4] = n[4] * r),
          (e[5] = n[5] * r),
          (e[6] = n[6] * r),
          (e[7] = 0),
          (e[8] = n[8] * s),
          (e[9] = n[9] * s),
          (e[10] = n[10] * s),
          (e[11] = 0),
          (e[12] = 0),
          (e[13] = 0),
          (e[14] = 0),
          (e[15] = 1),
          this
        );
      }
      makeRotationFromEuler(t) {
        (t && t.isEuler) ||
          console.error(
            "THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order."
          );
        const e = this.elements,
          n = t.x,
          i = t.y,
          r = t.z,
          s = Math.cos(n),
          o = Math.sin(n),
          a = Math.cos(i),
          l = Math.sin(i),
          c = Math.cos(r),
          u = Math.sin(r);
        if ("XYZ" === t.order) {
          const t = s * c,
            n = s * u,
            i = o * c,
            r = o * u;
          (e[0] = a * c),
            (e[4] = -a * u),
            (e[8] = l),
            (e[1] = n + i * l),
            (e[5] = t - r * l),
            (e[9] = -o * a),
            (e[2] = r - t * l),
            (e[6] = i + n * l),
            (e[10] = s * a);
        } else if ("YXZ" === t.order) {
          const t = a * c,
            n = a * u,
            i = l * c,
            r = l * u;
          (e[0] = t + r * o),
            (e[4] = i * o - n),
            (e[8] = s * l),
            (e[1] = s * u),
            (e[5] = s * c),
            (e[9] = -o),
            (e[2] = n * o - i),
            (e[6] = r + t * o),
            (e[10] = s * a);
        } else if ("ZXY" === t.order) {
          const t = a * c,
            n = a * u,
            i = l * c,
            r = l * u;
          (e[0] = t - r * o),
            (e[4] = -s * u),
            (e[8] = i + n * o),
            (e[1] = n + i * o),
            (e[5] = s * c),
            (e[9] = r - t * o),
            (e[2] = -s * l),
            (e[6] = o),
            (e[10] = s * a);
        } else if ("ZYX" === t.order) {
          const t = s * c,
            n = s * u,
            i = o * c,
            r = o * u;
          (e[0] = a * c),
            (e[4] = i * l - n),
            (e[8] = t * l + r),
            (e[1] = a * u),
            (e[5] = r * l + t),
            (e[9] = n * l - i),
            (e[2] = -l),
            (e[6] = o * a),
            (e[10] = s * a);
        } else if ("YZX" === t.order) {
          const t = s * a,
            n = s * l,
            i = o * a,
            r = o * l;
          (e[0] = a * c),
            (e[4] = r - t * u),
            (e[8] = i * u + n),
            (e[1] = u),
            (e[5] = s * c),
            (e[9] = -o * c),
            (e[2] = -l * c),
            (e[6] = n * u + i),
            (e[10] = t - r * u);
        } else if ("XZY" === t.order) {
          const t = s * a,
            n = s * l,
            i = o * a,
            r = o * l;
          (e[0] = a * c),
            (e[4] = -u),
            (e[8] = l * c),
            (e[1] = t * u + r),
            (e[5] = s * c),
            (e[9] = n * u - i),
            (e[2] = i * u - n),
            (e[6] = o * c),
            (e[10] = r * u + t);
        }
        return (
          (e[3] = 0),
          (e[7] = 0),
          (e[11] = 0),
          (e[12] = 0),
          (e[13] = 0),
          (e[14] = 0),
          (e[15] = 1),
          this
        );
      }
      makeRotationFromQuaternion(t) {
        return this.compose(ri, t, si);
      }
      lookAt(t, e, n) {
        const i = this.elements;
        return (
          li.subVectors(t, e),
          0 === li.lengthSq() && (li.z = 1),
          li.normalize(),
          oi.crossVectors(n, li),
          0 === oi.lengthSq() &&
            (1 === Math.abs(n.z) ? (li.x += 1e-4) : (li.z += 1e-4),
            li.normalize(),
            oi.crossVectors(n, li)),
          oi.normalize(),
          ai.crossVectors(li, oi),
          (i[0] = oi.x),
          (i[4] = ai.x),
          (i[8] = li.x),
          (i[1] = oi.y),
          (i[5] = ai.y),
          (i[9] = li.y),
          (i[2] = oi.z),
          (i[6] = ai.z),
          (i[10] = li.z),
          this
        );
      }
      multiply(t, e) {
        return void 0 !== e
          ? (console.warn(
              "THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."
            ),
            this.multiplyMatrices(t, e))
          : this.multiplyMatrices(this, t);
      }
      premultiply(t) {
        return this.multiplyMatrices(t, this);
      }
      multiplyMatrices(t, e) {
        const n = t.elements,
          i = e.elements,
          r = this.elements,
          s = n[0],
          o = n[4],
          a = n[8],
          l = n[12],
          c = n[1],
          u = n[5],
          h = n[9],
          d = n[13],
          p = n[2],
          f = n[6],
          m = n[10],
          g = n[14],
          v = n[3],
          y = n[7],
          x = n[11],
          b = n[15],
          _ = i[0],
          w = i[4],
          S = i[8],
          M = i[12],
          T = i[1],
          E = i[5],
          A = i[9],
          C = i[13],
          L = i[2],
          R = i[6],
          P = i[10],
          D = i[14],
          k = i[3],
          I = i[7],
          N = i[11],
          O = i[15];
        return (
          (r[0] = s * _ + o * T + a * L + l * k),
          (r[4] = s * w + o * E + a * R + l * I),
          (r[8] = s * S + o * A + a * P + l * N),
          (r[12] = s * M + o * C + a * D + l * O),
          (r[1] = c * _ + u * T + h * L + d * k),
          (r[5] = c * w + u * E + h * R + d * I),
          (r[9] = c * S + u * A + h * P + d * N),
          (r[13] = c * M + u * C + h * D + d * O),
          (r[2] = p * _ + f * T + m * L + g * k),
          (r[6] = p * w + f * E + m * R + g * I),
          (r[10] = p * S + f * A + m * P + g * N),
          (r[14] = p * M + f * C + m * D + g * O),
          (r[3] = v * _ + y * T + x * L + b * k),
          (r[7] = v * w + y * E + x * R + b * I),
          (r[11] = v * S + y * A + x * P + b * N),
          (r[15] = v * M + y * C + x * D + b * O),
          this
        );
      }
      multiplyScalar(t) {
        const e = this.elements;
        return (
          (e[0] *= t),
          (e[4] *= t),
          (e[8] *= t),
          (e[12] *= t),
          (e[1] *= t),
          (e[5] *= t),
          (e[9] *= t),
          (e[13] *= t),
          (e[2] *= t),
          (e[6] *= t),
          (e[10] *= t),
          (e[14] *= t),
          (e[3] *= t),
          (e[7] *= t),
          (e[11] *= t),
          (e[15] *= t),
          this
        );
      }
      determinant() {
        const t = this.elements,
          e = t[0],
          n = t[4],
          i = t[8],
          r = t[12],
          s = t[1],
          o = t[5],
          a = t[9],
          l = t[13],
          c = t[2],
          u = t[6],
          h = t[10],
          d = t[14];
        return (
          t[3] *
            (+r * a * u -
              i * l * u -
              r * o * h +
              n * l * h +
              i * o * d -
              n * a * d) +
          t[7] *
            (+e * a * d -
              e * l * h +
              r * s * h -
              i * s * d +
              i * l * c -
              r * a * c) +
          t[11] *
            (+e * l * u -
              e * o * d -
              r * s * u +
              n * s * d +
              r * o * c -
              n * l * c) +
          t[15] *
            (-i * o * c -
              e * a * u +
              e * o * h +
              i * s * u -
              n * s * h +
              n * a * c)
        );
      }
      transpose() {
        const t = this.elements;
        let e;
        return (
          (e = t[1]),
          (t[1] = t[4]),
          (t[4] = e),
          (e = t[2]),
          (t[2] = t[8]),
          (t[8] = e),
          (e = t[6]),
          (t[6] = t[9]),
          (t[9] = e),
          (e = t[3]),
          (t[3] = t[12]),
          (t[12] = e),
          (e = t[7]),
          (t[7] = t[13]),
          (t[13] = e),
          (e = t[11]),
          (t[11] = t[14]),
          (t[14] = e),
          this
        );
      }
      setPosition(t, e, n) {
        const i = this.elements;
        return (
          t.isVector3
            ? ((i[12] = t.x), (i[13] = t.y), (i[14] = t.z))
            : ((i[12] = t), (i[13] = e), (i[14] = n)),
          this
        );
      }
      invert() {
        const t = this.elements,
          e = t[0],
          n = t[1],
          i = t[2],
          r = t[3],
          s = t[4],
          o = t[5],
          a = t[6],
          l = t[7],
          c = t[8],
          u = t[9],
          h = t[10],
          d = t[11],
          p = t[12],
          f = t[13],
          m = t[14],
          g = t[15],
          v =
            u * m * l -
            f * h * l +
            f * a * d -
            o * m * d -
            u * a * g +
            o * h * g,
          y =
            p * h * l -
            c * m * l -
            p * a * d +
            s * m * d +
            c * a * g -
            s * h * g,
          x =
            c * f * l -
            p * u * l +
            p * o * d -
            s * f * d -
            c * o * g +
            s * u * g,
          b =
            p * u * a -
            c * f * a -
            p * o * h +
            s * f * h +
            c * o * m -
            s * u * m,
          _ = e * v + n * y + i * x + r * b;
        if (0 === _)
          return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        const w = 1 / _;
        return (
          (t[0] = v * w),
          (t[1] =
            (f * h * r -
              u * m * r -
              f * i * d +
              n * m * d +
              u * i * g -
              n * h * g) *
            w),
          (t[2] =
            (o * m * r -
              f * a * r +
              f * i * l -
              n * m * l -
              o * i * g +
              n * a * g) *
            w),
          (t[3] =
            (u * a * r -
              o * h * r -
              u * i * l +
              n * h * l +
              o * i * d -
              n * a * d) *
            w),
          (t[4] = y * w),
          (t[5] =
            (c * m * r -
              p * h * r +
              p * i * d -
              e * m * d -
              c * i * g +
              e * h * g) *
            w),
          (t[6] =
            (p * a * r -
              s * m * r -
              p * i * l +
              e * m * l +
              s * i * g -
              e * a * g) *
            w),
          (t[7] =
            (s * h * r -
              c * a * r +
              c * i * l -
              e * h * l -
              s * i * d +
              e * a * d) *
            w),
          (t[8] = x * w),
          (t[9] =
            (p * u * r -
              c * f * r -
              p * n * d +
              e * f * d +
              c * n * g -
              e * u * g) *
            w),
          (t[10] =
            (s * f * r -
              p * o * r +
              p * n * l -
              e * f * l -
              s * n * g +
              e * o * g) *
            w),
          (t[11] =
            (c * o * r -
              s * u * r -
              c * n * l +
              e * u * l +
              s * n * d -
              e * o * d) *
            w),
          (t[12] = b * w),
          (t[13] =
            (c * f * i -
              p * u * i +
              p * n * h -
              e * f * h -
              c * n * m +
              e * u * m) *
            w),
          (t[14] =
            (p * o * i -
              s * f * i -
              p * n * a +
              e * f * a +
              s * n * m -
              e * o * m) *
            w),
          (t[15] =
            (s * u * i -
              c * o * i +
              c * n * a -
              e * u * a -
              s * n * h +
              e * o * h) *
            w),
          this
        );
      }
      scale(t) {
        const e = this.elements,
          n = t.x,
          i = t.y,
          r = t.z;
        return (
          (e[0] *= n),
          (e[4] *= i),
          (e[8] *= r),
          (e[1] *= n),
          (e[5] *= i),
          (e[9] *= r),
          (e[2] *= n),
          (e[6] *= i),
          (e[10] *= r),
          (e[3] *= n),
          (e[7] *= i),
          (e[11] *= r),
          this
        );
      }
      getMaxScaleOnAxis() {
        const t = this.elements,
          e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2],
          n = t[4] * t[4] + t[5] * t[5] + t[6] * t[6],
          i = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
        return Math.sqrt(Math.max(e, n, i));
      }
      makeTranslation(t, e, n) {
        return this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, n, 0, 0, 0, 1), this;
      }
      makeRotationX(t) {
        const e = Math.cos(t),
          n = Math.sin(t);
        return this.set(1, 0, 0, 0, 0, e, -n, 0, 0, n, e, 0, 0, 0, 0, 1), this;
      }
      makeRotationY(t) {
        const e = Math.cos(t),
          n = Math.sin(t);
        return this.set(e, 0, n, 0, 0, 1, 0, 0, -n, 0, e, 0, 0, 0, 0, 1), this;
      }
      makeRotationZ(t) {
        const e = Math.cos(t),
          n = Math.sin(t);
        return this.set(e, -n, 0, 0, n, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
      }
      makeRotationAxis(t, e) {
        const n = Math.cos(e),
          i = Math.sin(e),
          r = 1 - n,
          s = t.x,
          o = t.y,
          a = t.z,
          l = r * s,
          c = r * o;
        return (
          this.set(
            l * s + n,
            l * o - i * a,
            l * a + i * o,
            0,
            l * o + i * a,
            c * o + n,
            c * a - i * s,
            0,
            l * a - i * o,
            c * a + i * s,
            r * a * a + n,
            0,
            0,
            0,
            0,
            1
          ),
          this
        );
      }
      makeScale(t, e, n) {
        return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this;
      }
      makeShear(t, e, n, i, r, s) {
        return this.set(1, n, r, 0, t, 1, s, 0, e, i, 1, 0, 0, 0, 0, 1), this;
      }
      compose(t, e, n) {
        const i = this.elements,
          r = e._x,
          s = e._y,
          o = e._z,
          a = e._w,
          l = r + r,
          c = s + s,
          u = o + o,
          h = r * l,
          d = r * c,
          p = r * u,
          f = s * c,
          m = s * u,
          g = o * u,
          v = a * l,
          y = a * c,
          x = a * u,
          b = n.x,
          _ = n.y,
          w = n.z;
        return (
          (i[0] = (1 - (f + g)) * b),
          (i[1] = (d + x) * b),
          (i[2] = (p - y) * b),
          (i[3] = 0),
          (i[4] = (d - x) * _),
          (i[5] = (1 - (h + g)) * _),
          (i[6] = (m + v) * _),
          (i[7] = 0),
          (i[8] = (p + y) * w),
          (i[9] = (m - v) * w),
          (i[10] = (1 - (h + f)) * w),
          (i[11] = 0),
          (i[12] = t.x),
          (i[13] = t.y),
          (i[14] = t.z),
          (i[15] = 1),
          this
        );
      }
      decompose(t, e, n) {
        const i = this.elements;
        let r = ni.set(i[0], i[1], i[2]).length();
        const s = ni.set(i[4], i[5], i[6]).length(),
          o = ni.set(i[8], i[9], i[10]).length();
        this.determinant() < 0 && (r = -r),
          (t.x = i[12]),
          (t.y = i[13]),
          (t.z = i[14]),
          ii.copy(this);
        const a = 1 / r,
          l = 1 / s,
          c = 1 / o;
        return (
          (ii.elements[0] *= a),
          (ii.elements[1] *= a),
          (ii.elements[2] *= a),
          (ii.elements[4] *= l),
          (ii.elements[5] *= l),
          (ii.elements[6] *= l),
          (ii.elements[8] *= c),
          (ii.elements[9] *= c),
          (ii.elements[10] *= c),
          e.setFromRotationMatrix(ii),
          (n.x = r),
          (n.y = s),
          (n.z = o),
          this
        );
      }
      makePerspective(t, e, n, i, r, s) {
        void 0 === s &&
          console.warn(
            "THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs."
          );
        const o = this.elements,
          a = (2 * r) / (e - t),
          l = (2 * r) / (n - i),
          c = (e + t) / (e - t),
          u = (n + i) / (n - i),
          h = -(s + r) / (s - r),
          d = (-2 * s * r) / (s - r);
        return (
          (o[0] = a),
          (o[4] = 0),
          (o[8] = c),
          (o[12] = 0),
          (o[1] = 0),
          (o[5] = l),
          (o[9] = u),
          (o[13] = 0),
          (o[2] = 0),
          (o[6] = 0),
          (o[10] = h),
          (o[14] = d),
          (o[3] = 0),
          (o[7] = 0),
          (o[11] = -1),
          (o[15] = 0),
          this
        );
      }
      makeOrthographic(t, e, n, i, r, s) {
        const o = this.elements,
          a = 1 / (e - t),
          l = 1 / (n - i),
          c = 1 / (s - r),
          u = (e + t) * a,
          h = (n + i) * l,
          d = (s + r) * c;
        return (
          (o[0] = 2 * a),
          (o[4] = 0),
          (o[8] = 0),
          (o[12] = -u),
          (o[1] = 0),
          (o[5] = 2 * l),
          (o[9] = 0),
          (o[13] = -h),
          (o[2] = 0),
          (o[6] = 0),
          (o[10] = -2 * c),
          (o[14] = -d),
          (o[3] = 0),
          (o[7] = 0),
          (o[11] = 0),
          (o[15] = 1),
          this
        );
      }
      equals(t) {
        const e = this.elements,
          n = t.elements;
        for (let t = 0; t < 16; t++) if (e[t] !== n[t]) return !1;
        return !0;
      }
      fromArray(t, e = 0) {
        for (let n = 0; n < 16; n++) this.elements[n] = t[n + e];
        return this;
      }
      toArray(t = [], e = 0) {
        const n = this.elements;
        return (
          (t[e] = n[0]),
          (t[e + 1] = n[1]),
          (t[e + 2] = n[2]),
          (t[e + 3] = n[3]),
          (t[e + 4] = n[4]),
          (t[e + 5] = n[5]),
          (t[e + 6] = n[6]),
          (t[e + 7] = n[7]),
          (t[e + 8] = n[8]),
          (t[e + 9] = n[9]),
          (t[e + 10] = n[10]),
          (t[e + 11] = n[11]),
          (t[e + 12] = n[12]),
          (t[e + 13] = n[13]),
          (t[e + 14] = n[14]),
          (t[e + 15] = n[15]),
          t
        );
      }
    }
    ei.prototype.isMatrix4 = !0;
    const ni = new Mn(),
      ii = new ei(),
      ri = new Mn(0, 0, 0),
      si = new Mn(1, 1, 1),
      oi = new Mn(),
      ai = new Mn(),
      li = new Mn(),
      ci = new ei(),
      ui = new Sn();
    class hi {
      constructor(t = 0, e = 0, n = 0, i = hi.DefaultOrder) {
        (this._x = t), (this._y = e), (this._z = n), (this._order = i);
      }
      get x() {
        return this._x;
      }
      set x(t) {
        (this._x = t), this._onChangeCallback();
      }
      get y() {
        return this._y;
      }
      set y(t) {
        (this._y = t), this._onChangeCallback();
      }
      get z() {
        return this._z;
      }
      set z(t) {
        (this._z = t), this._onChangeCallback();
      }
      get order() {
        return this._order;
      }
      set order(t) {
        (this._order = t), this._onChangeCallback();
      }
      set(t, e, n, i = this._order) {
        return (
          (this._x = t),
          (this._y = e),
          (this._z = n),
          (this._order = i),
          this._onChangeCallback(),
          this
        );
      }
      clone() {
        return new this.constructor(this._x, this._y, this._z, this._order);
      }
      copy(t) {
        return (
          (this._x = t._x),
          (this._y = t._y),
          (this._z = t._z),
          (this._order = t._order),
          this._onChangeCallback(),
          this
        );
      }
      setFromRotationMatrix(t, e = this._order, n = !0) {
        const i = t.elements,
          r = i[0],
          s = i[4],
          o = i[8],
          a = i[1],
          l = i[5],
          c = i[9],
          u = i[2],
          h = i[6],
          d = i[10];
        switch (e) {
          case "XYZ":
            (this._y = Math.asin(on(o, -1, 1))),
              Math.abs(o) < 0.9999999
                ? ((this._x = Math.atan2(-c, d)), (this._z = Math.atan2(-s, r)))
                : ((this._x = Math.atan2(h, l)), (this._z = 0));
            break;
          case "YXZ":
            (this._x = Math.asin(-on(c, -1, 1))),
              Math.abs(c) < 0.9999999
                ? ((this._y = Math.atan2(o, d)), (this._z = Math.atan2(a, l)))
                : ((this._y = Math.atan2(-u, r)), (this._z = 0));
            break;
          case "ZXY":
            (this._x = Math.asin(on(h, -1, 1))),
              Math.abs(h) < 0.9999999
                ? ((this._y = Math.atan2(-u, d)), (this._z = Math.atan2(-s, l)))
                : ((this._y = 0), (this._z = Math.atan2(a, r)));
            break;
          case "ZYX":
            (this._y = Math.asin(-on(u, -1, 1))),
              Math.abs(u) < 0.9999999
                ? ((this._x = Math.atan2(h, d)), (this._z = Math.atan2(a, r)))
                : ((this._x = 0), (this._z = Math.atan2(-s, l)));
            break;
          case "YZX":
            (this._z = Math.asin(on(a, -1, 1))),
              Math.abs(a) < 0.9999999
                ? ((this._x = Math.atan2(-c, l)), (this._y = Math.atan2(-u, r)))
                : ((this._x = 0), (this._y = Math.atan2(o, d)));
            break;
          case "XZY":
            (this._z = Math.asin(-on(s, -1, 1))),
              Math.abs(s) < 0.9999999
                ? ((this._x = Math.atan2(h, l)), (this._y = Math.atan2(o, r)))
                : ((this._x = Math.atan2(-c, d)), (this._y = 0));
            break;
          default:
            console.warn(
              "THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " +
                e
            );
        }
        return (this._order = e), !0 === n && this._onChangeCallback(), this;
      }
      setFromQuaternion(t, e, n) {
        return (
          ci.makeRotationFromQuaternion(t), this.setFromRotationMatrix(ci, e, n)
        );
      }
      setFromVector3(t, e = this._order) {
        return this.set(t.x, t.y, t.z, e);
      }
      reorder(t) {
        return ui.setFromEuler(this), this.setFromQuaternion(ui, t);
      }
      equals(t) {
        return (
          t._x === this._x &&
          t._y === this._y &&
          t._z === this._z &&
          t._order === this._order
        );
      }
      fromArray(t) {
        return (
          (this._x = t[0]),
          (this._y = t[1]),
          (this._z = t[2]),
          void 0 !== t[3] && (this._order = t[3]),
          this._onChangeCallback(),
          this
        );
      }
      toArray(t = [], e = 0) {
        return (
          (t[e] = this._x),
          (t[e + 1] = this._y),
          (t[e + 2] = this._z),
          (t[e + 3] = this._order),
          t
        );
      }
      toVector3(t) {
        return t
          ? t.set(this._x, this._y, this._z)
          : new Mn(this._x, this._y, this._z);
      }
      _onChange(t) {
        return (this._onChangeCallback = t), this;
      }
      _onChangeCallback() {}
    }
    (hi.prototype.isEuler = !0),
      (hi.DefaultOrder = "XYZ"),
      (hi.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"]);
    class di {
      constructor() {
        this.mask = 1;
      }
      set(t) {
        this.mask = ((1 << t) | 0) >>> 0;
      }
      enable(t) {
        this.mask |= (1 << t) | 0;
      }
      enableAll() {
        this.mask = -1;
      }
      toggle(t) {
        this.mask ^= (1 << t) | 0;
      }
      disable(t) {
        this.mask &= ~((1 << t) | 0);
      }
      disableAll() {
        this.mask = 0;
      }
      test(t) {
        return 0 != (this.mask & t.mask);
      }
      isEnabled(t) {
        return 0 != (this.mask & ((1 << t) | 0));
      }
    }
    let pi = 0;
    const fi = new Mn(),
      mi = new Sn(),
      gi = new ei(),
      vi = new Mn(),
      yi = new Mn(),
      xi = new Mn(),
      bi = new Sn(),
      _i = new Mn(1, 0, 0),
      wi = new Mn(0, 1, 0),
      Si = new Mn(0, 0, 1),
      Mi = { type: "added" },
      Ti = { type: "removed" };
    class Ei extends tn {
      constructor() {
        super(),
          Object.defineProperty(this, "id", { value: pi++ }),
          (this.uuid = sn()),
          (this.name = ""),
          (this.type = "Object3D"),
          (this.parent = null),
          (this.children = []),
          (this.up = Ei.DefaultUp.clone());
        const t = new Mn(),
          e = new hi(),
          n = new Sn(),
          i = new Mn(1, 1, 1);
        e._onChange(function () {
          n.setFromEuler(e, !1);
        }),
          n._onChange(function () {
            e.setFromQuaternion(n, void 0, !1);
          }),
          Object.defineProperties(this, {
            position: { configurable: !0, enumerable: !0, value: t },
            rotation: { configurable: !0, enumerable: !0, value: e },
            quaternion: { configurable: !0, enumerable: !0, value: n },
            scale: { configurable: !0, enumerable: !0, value: i },
            modelViewMatrix: { value: new ei() },
            normalMatrix: { value: new dn() },
          }),
          (this.matrix = new ei()),
          (this.matrixWorld = new ei()),
          (this.matrixAutoUpdate = Ei.DefaultMatrixAutoUpdate),
          (this.matrixWorldNeedsUpdate = !1),
          (this.layers = new di()),
          (this.visible = !0),
          (this.castShadow = !1),
          (this.receiveShadow = !1),
          (this.frustumCulled = !0),
          (this.renderOrder = 0),
          (this.animations = []),
          (this.userData = {});
      }
      onBeforeRender() {}
      onAfterRender() {}
      applyMatrix4(t) {
        this.matrixAutoUpdate && this.updateMatrix(),
          this.matrix.premultiply(t),
          this.matrix.decompose(this.position, this.quaternion, this.scale);
      }
      applyQuaternion(t) {
        return this.quaternion.premultiply(t), this;
      }
      setRotationFromAxisAngle(t, e) {
        this.quaternion.setFromAxisAngle(t, e);
      }
      setRotationFromEuler(t) {
        this.quaternion.setFromEuler(t, !0);
      }
      setRotationFromMatrix(t) {
        this.quaternion.setFromRotationMatrix(t);
      }
      setRotationFromQuaternion(t) {
        this.quaternion.copy(t);
      }
      rotateOnAxis(t, e) {
        return mi.setFromAxisAngle(t, e), this.quaternion.multiply(mi), this;
      }
      rotateOnWorldAxis(t, e) {
        return mi.setFromAxisAngle(t, e), this.quaternion.premultiply(mi), this;
      }
      rotateX(t) {
        return this.rotateOnAxis(_i, t);
      }
      rotateY(t) {
        return this.rotateOnAxis(wi, t);
      }
      rotateZ(t) {
        return this.rotateOnAxis(Si, t);
      }
      translateOnAxis(t, e) {
        return (
          fi.copy(t).applyQuaternion(this.quaternion),
          this.position.add(fi.multiplyScalar(e)),
          this
        );
      }
      translateX(t) {
        return this.translateOnAxis(_i, t);
      }
      translateY(t) {
        return this.translateOnAxis(wi, t);
      }
      translateZ(t) {
        return this.translateOnAxis(Si, t);
      }
      localToWorld(t) {
        return t.applyMatrix4(this.matrixWorld);
      }
      worldToLocal(t) {
        return t.applyMatrix4(gi.copy(this.matrixWorld).invert());
      }
      lookAt(t, e, n) {
        t.isVector3 ? vi.copy(t) : vi.set(t, e, n);
        const i = this.parent;
        this.updateWorldMatrix(!0, !1),
          yi.setFromMatrixPosition(this.matrixWorld),
          this.isCamera || this.isLight
            ? gi.lookAt(yi, vi, this.up)
            : gi.lookAt(vi, yi, this.up),
          this.quaternion.setFromRotationMatrix(gi),
          i &&
            (gi.extractRotation(i.matrixWorld),
            mi.setFromRotationMatrix(gi),
            this.quaternion.premultiply(mi.invert()));
      }
      add(t) {
        if (arguments.length > 1) {
          for (let t = 0; t < arguments.length; t++) this.add(arguments[t]);
          return this;
        }
        return t === this
          ? (console.error(
              "THREE.Object3D.add: object can't be added as a child of itself.",
              t
            ),
            this)
          : (t && t.isObject3D
              ? (null !== t.parent && t.parent.remove(t),
                (t.parent = this),
                this.children.push(t),
                t.dispatchEvent(Mi))
              : console.error(
                  "THREE.Object3D.add: object not an instance of THREE.Object3D.",
                  t
                ),
            this);
      }
      remove(t) {
        if (arguments.length > 1) {
          for (let t = 0; t < arguments.length; t++) this.remove(arguments[t]);
          return this;
        }
        const e = this.children.indexOf(t);
        return (
          -1 !== e &&
            ((t.parent = null),
            this.children.splice(e, 1),
            t.dispatchEvent(Ti)),
          this
        );
      }
      removeFromParent() {
        const t = this.parent;
        return null !== t && t.remove(this), this;
      }
      clear() {
        for (let t = 0; t < this.children.length; t++) {
          const e = this.children[t];
          (e.parent = null), e.dispatchEvent(Ti);
        }
        return (this.children.length = 0), this;
      }
      attach(t) {
        return (
          this.updateWorldMatrix(!0, !1),
          gi.copy(this.matrixWorld).invert(),
          null !== t.parent &&
            (t.parent.updateWorldMatrix(!0, !1),
            gi.multiply(t.parent.matrixWorld)),
          t.applyMatrix4(gi),
          this.add(t),
          t.updateWorldMatrix(!1, !0),
          this
        );
      }
      getObjectById(t) {
        return this.getObjectByProperty("id", t);
      }
      getObjectByName(t) {
        return this.getObjectByProperty("name", t);
      }
      getObjectByProperty(t, e) {
        if (this[t] === e) return this;
        for (let n = 0, i = this.children.length; n < i; n++) {
          const i = this.children[n].getObjectByProperty(t, e);
          if (void 0 !== i) return i;
        }
      }
      getWorldPosition(t) {
        return (
          this.updateWorldMatrix(!0, !1),
          t.setFromMatrixPosition(this.matrixWorld)
        );
      }
      getWorldQuaternion(t) {
        return (
          this.updateWorldMatrix(!0, !1),
          this.matrixWorld.decompose(yi, t, xi),
          t
        );
      }
      getWorldScale(t) {
        return (
          this.updateWorldMatrix(!0, !1),
          this.matrixWorld.decompose(yi, bi, t),
          t
        );
      }
      getWorldDirection(t) {
        this.updateWorldMatrix(!0, !1);
        const e = this.matrixWorld.elements;
        return t.set(e[8], e[9], e[10]).normalize();
      }
      raycast() {}
      traverse(t) {
        t(this);
        const e = this.children;
        for (let n = 0, i = e.length; n < i; n++) e[n].traverse(t);
      }
      traverseVisible(t) {
        if (!1 === this.visible) return;
        t(this);
        const e = this.children;
        for (let n = 0, i = e.length; n < i; n++) e[n].traverseVisible(t);
      }
      traverseAncestors(t) {
        const e = this.parent;
        null !== e && (t(e), e.traverseAncestors(t));
      }
      updateMatrix() {
        this.matrix.compose(this.position, this.quaternion, this.scale),
          (this.matrixWorldNeedsUpdate = !0);
      }
      updateMatrixWorld(t) {
        this.matrixAutoUpdate && this.updateMatrix(),
          (this.matrixWorldNeedsUpdate || t) &&
            (null === this.parent
              ? this.matrixWorld.copy(this.matrix)
              : this.matrixWorld.multiplyMatrices(
                  this.parent.matrixWorld,
                  this.matrix
                ),
            (this.matrixWorldNeedsUpdate = !1),
            (t = !0));
        const e = this.children;
        for (let n = 0, i = e.length; n < i; n++) e[n].updateMatrixWorld(t);
      }
      updateWorldMatrix(t, e) {
        const n = this.parent;
        if (
          (!0 === t && null !== n && n.updateWorldMatrix(!0, !1),
          this.matrixAutoUpdate && this.updateMatrix(),
          null === this.parent
            ? this.matrixWorld.copy(this.matrix)
            : this.matrixWorld.multiplyMatrices(
                this.parent.matrixWorld,
                this.matrix
              ),
          !0 === e)
        ) {
          const t = this.children;
          for (let e = 0, n = t.length; e < n; e++)
            t[e].updateWorldMatrix(!1, !0);
        }
      }
      toJSON(t) {
        const e = void 0 === t || "string" == typeof t,
          n = {};
        e &&
          ((t = {
            geometries: {},
            materials: {},
            textures: {},
            images: {},
            shapes: {},
            skeletons: {},
            animations: {},
          }),
          (n.metadata = {
            version: 4.5,
            type: "Object",
            generator: "Object3D.toJSON",
          }));
        const i = {};
        function r(e, n) {
          return void 0 === e[n.uuid] && (e[n.uuid] = n.toJSON(t)), n.uuid;
        }
        if (
          ((i.uuid = this.uuid),
          (i.type = this.type),
          "" !== this.name && (i.name = this.name),
          !0 === this.castShadow && (i.castShadow = !0),
          !0 === this.receiveShadow && (i.receiveShadow = !0),
          !1 === this.visible && (i.visible = !1),
          !1 === this.frustumCulled && (i.frustumCulled = !1),
          0 !== this.renderOrder && (i.renderOrder = this.renderOrder),
          "{}" !== JSON.stringify(this.userData) &&
            (i.userData = this.userData),
          (i.layers = this.layers.mask),
          (i.matrix = this.matrix.toArray()),
          !1 === this.matrixAutoUpdate && (i.matrixAutoUpdate = !1),
          this.isInstancedMesh &&
            ((i.type = "InstancedMesh"),
            (i.count = this.count),
            (i.instanceMatrix = this.instanceMatrix.toJSON()),
            null !== this.instanceColor &&
              (i.instanceColor = this.instanceColor.toJSON())),
          this.isScene)
        )
          this.background &&
            (this.background.isColor
              ? (i.background = this.background.toJSON())
              : this.background.isTexture &&
                (i.background = this.background.toJSON(t).uuid)),
            this.environment &&
              this.environment.isTexture &&
              (i.environment = this.environment.toJSON(t).uuid);
        else if (this.isMesh || this.isLine || this.isPoints) {
          i.geometry = r(t.geometries, this.geometry);
          const e = this.geometry.parameters;
          if (void 0 !== e && void 0 !== e.shapes) {
            const n = e.shapes;
            if (Array.isArray(n))
              for (let e = 0, i = n.length; e < i; e++) {
                const i = n[e];
                r(t.shapes, i);
              }
            else r(t.shapes, n);
          }
        }
        if (
          (this.isSkinnedMesh &&
            ((i.bindMode = this.bindMode),
            (i.bindMatrix = this.bindMatrix.toArray()),
            void 0 !== this.skeleton &&
              (r(t.skeletons, this.skeleton),
              (i.skeleton = this.skeleton.uuid))),
          void 0 !== this.material)
        )
          if (Array.isArray(this.material)) {
            const e = [];
            for (let n = 0, i = this.material.length; n < i; n++)
              e.push(r(t.materials, this.material[n]));
            i.material = e;
          } else i.material = r(t.materials, this.material);
        if (this.children.length > 0) {
          i.children = [];
          for (let e = 0; e < this.children.length; e++)
            i.children.push(this.children[e].toJSON(t).object);
        }
        if (this.animations.length > 0) {
          i.animations = [];
          for (let e = 0; e < this.animations.length; e++) {
            const n = this.animations[e];
            i.animations.push(r(t.animations, n));
          }
        }
        if (e) {
          const e = s(t.geometries),
            i = s(t.materials),
            r = s(t.textures),
            o = s(t.images),
            a = s(t.shapes),
            l = s(t.skeletons),
            c = s(t.animations);
          e.length > 0 && (n.geometries = e),
            i.length > 0 && (n.materials = i),
            r.length > 0 && (n.textures = r),
            o.length > 0 && (n.images = o),
            a.length > 0 && (n.shapes = a),
            l.length > 0 && (n.skeletons = l),
            c.length > 0 && (n.animations = c);
        }
        return (n.object = i), n;
        function s(t) {
          const e = [];
          for (const n in t) {
            const i = t[n];
            delete i.metadata, e.push(i);
          }
          return e;
        }
      }
      clone(t) {
        return new this.constructor().copy(this, t);
      }
      copy(t, e = !0) {
        if (
          ((this.name = t.name),
          this.up.copy(t.up),
          this.position.copy(t.position),
          (this.rotation.order = t.rotation.order),
          this.quaternion.copy(t.quaternion),
          this.scale.copy(t.scale),
          this.matrix.copy(t.matrix),
          this.matrixWorld.copy(t.matrixWorld),
          (this.matrixAutoUpdate = t.matrixAutoUpdate),
          (this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate),
          (this.layers.mask = t.layers.mask),
          (this.visible = t.visible),
          (this.castShadow = t.castShadow),
          (this.receiveShadow = t.receiveShadow),
          (this.frustumCulled = t.frustumCulled),
          (this.renderOrder = t.renderOrder),
          (this.userData = JSON.parse(JSON.stringify(t.userData))),
          !0 === e)
        )
          for (let e = 0; e < t.children.length; e++) {
            const n = t.children[e];
            this.add(n.clone());
          }
        return this;
      }
    }
    (Ei.DefaultUp = new Mn(0, 1, 0)),
      (Ei.DefaultMatrixAutoUpdate = !0),
      (Ei.prototype.isObject3D = !0);
    const Ai = new Mn(),
      Ci = new Mn(),
      Li = new Mn(),
      Ri = new Mn(),
      Pi = new Mn(),
      Di = new Mn(),
      ki = new Mn(),
      Ii = new Mn(),
      Ni = new Mn(),
      Oi = new Mn();
    class zi {
      constructor(t = new Mn(), e = new Mn(), n = new Mn()) {
        (this.a = t), (this.b = e), (this.c = n);
      }
      static getNormal(t, e, n, i) {
        i.subVectors(n, e), Ai.subVectors(t, e), i.cross(Ai);
        const r = i.lengthSq();
        return r > 0 ? i.multiplyScalar(1 / Math.sqrt(r)) : i.set(0, 0, 0);
      }
      static getBarycoord(t, e, n, i, r) {
        Ai.subVectors(i, e), Ci.subVectors(n, e), Li.subVectors(t, e);
        const s = Ai.dot(Ai),
          o = Ai.dot(Ci),
          a = Ai.dot(Li),
          l = Ci.dot(Ci),
          c = Ci.dot(Li),
          u = s * l - o * o;
        if (0 === u) return r.set(-2, -1, -1);
        const h = 1 / u,
          d = (l * a - o * c) * h,
          p = (s * c - o * a) * h;
        return r.set(1 - d - p, p, d);
      }
      static containsPoint(t, e, n, i) {
        return (
          this.getBarycoord(t, e, n, i, Ri),
          Ri.x >= 0 && Ri.y >= 0 && Ri.x + Ri.y <= 1
        );
      }
      static getUV(t, e, n, i, r, s, o, a) {
        return (
          this.getBarycoord(t, e, n, i, Ri),
          a.set(0, 0),
          a.addScaledVector(r, Ri.x),
          a.addScaledVector(s, Ri.y),
          a.addScaledVector(o, Ri.z),
          a
        );
      }
      static isFrontFacing(t, e, n, i) {
        return (
          Ai.subVectors(n, e), Ci.subVectors(t, e), Ai.cross(Ci).dot(i) < 0
        );
      }
      set(t, e, n) {
        return this.a.copy(t), this.b.copy(e), this.c.copy(n), this;
      }
      setFromPointsAndIndices(t, e, n, i) {
        return this.a.copy(t[e]), this.b.copy(t[n]), this.c.copy(t[i]), this;
      }
      setFromAttributeAndIndices(t, e, n, i) {
        return (
          this.a.fromBufferAttribute(t, e),
          this.b.fromBufferAttribute(t, n),
          this.c.fromBufferAttribute(t, i),
          this
        );
      }
      clone() {
        return new this.constructor().copy(this);
      }
      copy(t) {
        return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this;
      }
      getArea() {
        return (
          Ai.subVectors(this.c, this.b),
          Ci.subVectors(this.a, this.b),
          0.5 * Ai.cross(Ci).length()
        );
      }
      getMidpoint(t) {
        return t
          .addVectors(this.a, this.b)
          .add(this.c)
          .multiplyScalar(1 / 3);
      }
      getNormal(t) {
        return zi.getNormal(this.a, this.b, this.c, t);
      }
      getPlane(t) {
        return t.setFromCoplanarPoints(this.a, this.b, this.c);
      }
      getBarycoord(t, e) {
        return zi.getBarycoord(t, this.a, this.b, this.c, e);
      }
      getUV(t, e, n, i, r) {
        return zi.getUV(t, this.a, this.b, this.c, e, n, i, r);
      }
      containsPoint(t) {
        return zi.containsPoint(t, this.a, this.b, this.c);
      }
      isFrontFacing(t) {
        return zi.isFrontFacing(this.a, this.b, this.c, t);
      }
      intersectsBox(t) {
        return t.intersectsTriangle(this);
      }
      closestPointToPoint(t, e) {
        const n = this.a,
          i = this.b,
          r = this.c;
        let s, o;
        Pi.subVectors(i, n), Di.subVectors(r, n), Ii.subVectors(t, n);
        const a = Pi.dot(Ii),
          l = Di.dot(Ii);
        if (a <= 0 && l <= 0) return e.copy(n);
        Ni.subVectors(t, i);
        const c = Pi.dot(Ni),
          u = Di.dot(Ni);
        if (c >= 0 && u <= c) return e.copy(i);
        const h = a * u - c * l;
        if (h <= 0 && a >= 0 && c <= 0)
          return (s = a / (a - c)), e.copy(n).addScaledVector(Pi, s);
        Oi.subVectors(t, r);
        const d = Pi.dot(Oi),
          p = Di.dot(Oi);
        if (p >= 0 && d <= p) return e.copy(r);
        const f = d * l - a * p;
        if (f <= 0 && l >= 0 && p <= 0)
          return (o = l / (l - p)), e.copy(n).addScaledVector(Di, o);
        const m = c * p - d * u;
        if (m <= 0 && u - c >= 0 && d - p >= 0)
          return (
            ki.subVectors(r, i),
            (o = (u - c) / (u - c + (d - p))),
            e.copy(i).addScaledVector(ki, o)
          );
        const g = 1 / (m + f + h);
        return (
          (s = f * g),
          (o = h * g),
          e.copy(n).addScaledVector(Pi, s).addScaledVector(Di, o)
        );
      }
      equals(t) {
        return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c);
      }
    }
    let Hi = 0;
    class Bi extends tn {
      constructor() {
        super(),
          Object.defineProperty(this, "id", { value: Hi++ }),
          (this.uuid = sn()),
          (this.name = ""),
          (this.type = "Material"),
          (this.fog = !0),
          (this.blending = b),
          (this.side = m),
          (this.vertexColors = !1),
          (this.opacity = 1),
          (this.format = Nt),
          (this.transparent = !1),
          (this.blendSrc = I),
          (this.blendDst = N),
          (this.blendEquation = T),
          (this.blendSrcAlpha = null),
          (this.blendDstAlpha = null),
          (this.blendEquationAlpha = null),
          (this.depthFunc = G),
          (this.depthTest = !0),
          (this.depthWrite = !0),
          (this.stencilWriteMask = 255),
          (this.stencilFunc = Ye),
          (this.stencilRef = 0),
          (this.stencilFuncMask = 255),
          (this.stencilFail = Je),
          (this.stencilZFail = Je),
          (this.stencilZPass = Je),
          (this.stencilWrite = !1),
          (this.clippingPlanes = null),
          (this.clipIntersection = !1),
          (this.clipShadows = !1),
          (this.shadowSide = null),
          (this.colorWrite = !0),
          (this.precision = null),
          (this.polygonOffset = !1),
          (this.polygonOffsetFactor = 0),
          (this.polygonOffsetUnits = 0),
          (this.dithering = !1),
          (this.alphaToCoverage = !1),
          (this.premultipliedAlpha = !1),
          (this.visible = !0),
          (this.toneMapped = !0),
          (this.userData = {}),
          (this.version = 0),
          (this._alphaTest = 0);
      }
      get alphaTest() {
        return this._alphaTest;
      }
      set alphaTest(t) {
        this._alphaTest > 0 != t > 0 && this.version++, (this._alphaTest = t);
      }
      onBuild() {}
      onBeforeRender() {}
      onBeforeCompile() {}
      customProgramCacheKey() {
        return this.onBeforeCompile.toString();
      }
      setValues(t) {
        if (void 0 !== t)
          for (const e in t) {
            const n = t[e];
            if (void 0 === n) {
              console.warn(
                "THREE.Material: '" + e + "' parameter is undefined."
              );
              continue;
            }
            if ("shading" === e) {
              console.warn(
                "THREE." +
                  this.type +
                  ": .shading has been removed. Use the boolean .flatShading instead."
              ),
                (this.flatShading = n === y);
              continue;
            }
            const i = this[e];
            void 0 !== i
              ? i && i.isColor
                ? i.set(n)
                : i && i.isVector3 && n && n.isVector3
                ? i.copy(n)
                : (this[e] = n)
              : console.warn(
                  "THREE." +
                    this.type +
                    ": '" +
                    e +
                    "' is not a property of this material."
                );
          }
      }
      toJSON(t) {
        const e = void 0 === t || "string" == typeof t;
        e && (t = { textures: {}, images: {} });
        const n = {
          metadata: {
            version: 4.5,
            type: "Material",
            generator: "Material.toJSON",
          },
        };
        function i(t) {
          const e = [];
          for (const n in t) {
            const i = t[n];
            delete i.metadata, e.push(i);
          }
          return e;
        }
        if (
          ((n.uuid = this.uuid),
          (n.type = this.type),
          "" !== this.name && (n.name = this.name),
          this.color && this.color.isColor && (n.color = this.color.getHex()),
          void 0 !== this.roughness && (n.roughness = this.roughness),
          void 0 !== this.metalness && (n.metalness = this.metalness),
          void 0 !== this.sheen && (n.sheen = this.sheen),
          this.sheenColor &&
            this.sheenColor.isColor &&
            (n.sheenColor = this.sheenColor.getHex()),
          void 0 !== this.sheenRoughness &&
            (n.sheenRoughness = this.sheenRoughness),
          this.emissive &&
            this.emissive.isColor &&
            (n.emissive = this.emissive.getHex()),
          this.emissiveIntensity &&
            1 !== this.emissiveIntensity &&
            (n.emissiveIntensity = this.emissiveIntensity),
          this.specular &&
            this.specular.isColor &&
            (n.specular = this.specular.getHex()),
          void 0 !== this.specularIntensity &&
            (n.specularIntensity = this.specularIntensity),
          this.specularColor &&
            this.specularColor.isColor &&
            (n.specularColor = this.specularColor.getHex()),
          void 0 !== this.shininess && (n.shininess = this.shininess),
          void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat),
          void 0 !== this.clearcoatRoughness &&
            (n.clearcoatRoughness = this.clearcoatRoughness),
          this.clearcoatMap &&
            this.clearcoatMap.isTexture &&
            (n.clearcoatMap = this.clearcoatMap.toJSON(t).uuid),
          this.clearcoatRoughnessMap &&
            this.clearcoatRoughnessMap.isTexture &&
            (n.clearcoatRoughnessMap =
              this.clearcoatRoughnessMap.toJSON(t).uuid),
          this.clearcoatNormalMap &&
            this.clearcoatNormalMap.isTexture &&
            ((n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid),
            (n.clearcoatNormalScale = this.clearcoatNormalScale.toArray())),
          this.map && this.map.isTexture && (n.map = this.map.toJSON(t).uuid),
          this.matcap &&
            this.matcap.isTexture &&
            (n.matcap = this.matcap.toJSON(t).uuid),
          this.alphaMap &&
            this.alphaMap.isTexture &&
            (n.alphaMap = this.alphaMap.toJSON(t).uuid),
          this.lightMap &&
            this.lightMap.isTexture &&
            ((n.lightMap = this.lightMap.toJSON(t).uuid),
            (n.lightMapIntensity = this.lightMapIntensity)),
          this.aoMap &&
            this.aoMap.isTexture &&
            ((n.aoMap = this.aoMap.toJSON(t).uuid),
            (n.aoMapIntensity = this.aoMapIntensity)),
          this.bumpMap &&
            this.bumpMap.isTexture &&
            ((n.bumpMap = this.bumpMap.toJSON(t).uuid),
            (n.bumpScale = this.bumpScale)),
          this.normalMap &&
            this.normalMap.isTexture &&
            ((n.normalMap = this.normalMap.toJSON(t).uuid),
            (n.normalMapType = this.normalMapType),
            (n.normalScale = this.normalScale.toArray())),
          this.displacementMap &&
            this.displacementMap.isTexture &&
            ((n.displacementMap = this.displacementMap.toJSON(t).uuid),
            (n.displacementScale = this.displacementScale),
            (n.displacementBias = this.displacementBias)),
          this.roughnessMap &&
            this.roughnessMap.isTexture &&
            (n.roughnessMap = this.roughnessMap.toJSON(t).uuid),
          this.metalnessMap &&
            this.metalnessMap.isTexture &&
            (n.metalnessMap = this.metalnessMap.toJSON(t).uuid),
          this.emissiveMap &&
            this.emissiveMap.isTexture &&
            (n.emissiveMap = this.emissiveMap.toJSON(t).uuid),
          this.specularMap &&
            this.specularMap.isTexture &&
            (n.specularMap = this.specularMap.toJSON(t).uuid),
          this.specularIntensityMap &&
            this.specularIntensityMap.isTexture &&
            (n.specularIntensityMap = this.specularIntensityMap.toJSON(t).uuid),
          this.specularColorMap &&
            this.specularColorMap.isTexture &&
            (n.specularColorMap = this.specularColorMap.toJSON(t).uuid),
          this.envMap &&
            this.envMap.isTexture &&
            ((n.envMap = this.envMap.toJSON(t).uuid),
            void 0 !== this.combine && (n.combine = this.combine)),
          void 0 !== this.envMapIntensity &&
            (n.envMapIntensity = this.envMapIntensity),
          void 0 !== this.reflectivity && (n.reflectivity = this.reflectivity),
          void 0 !== this.refractionRatio &&
            (n.refractionRatio = this.refractionRatio),
          this.gradientMap &&
            this.gradientMap.isTexture &&
            (n.gradientMap = this.gradientMap.toJSON(t).uuid),
          void 0 !== this.transmission && (n.transmission = this.transmission),
          this.transmissionMap &&
            this.transmissionMap.isTexture &&
            (n.transmissionMap = this.transmissionMap.toJSON(t).uuid),
          void 0 !== this.thickness && (n.thickness = this.thickness),
          this.thicknessMap &&
            this.thicknessMap.isTexture &&
            (n.thicknessMap = this.thicknessMap.toJSON(t).uuid),
          void 0 !== this.attenuationDistance &&
            (n.attenuationDistance = this.attenuationDistance),
          void 0 !== this.attenuationColor &&
            (n.attenuationColor = this.attenuationColor.getHex()),
          void 0 !== this.size && (n.size = this.size),
          null !== this.shadowSide && (n.shadowSide = this.shadowSide),
          void 0 !== this.sizeAttenuation &&
            (n.sizeAttenuation = this.sizeAttenuation),
          this.blending !== b && (n.blending = this.blending),
          this.side !== m && (n.side = this.side),
          this.vertexColors && (n.vertexColors = !0),
          this.opacity < 1 && (n.opacity = this.opacity),
          this.format !== Nt && (n.format = this.format),
          !0 === this.transparent && (n.transparent = this.transparent),
          (n.depthFunc = this.depthFunc),
          (n.depthTest = this.depthTest),
          (n.depthWrite = this.depthWrite),
          (n.colorWrite = this.colorWrite),
          (n.stencilWrite = this.stencilWrite),
          (n.stencilWriteMask = this.stencilWriteMask),
          (n.stencilFunc = this.stencilFunc),
          (n.stencilRef = this.stencilRef),
          (n.stencilFuncMask = this.stencilFuncMask),
          (n.stencilFail = this.stencilFail),
          (n.stencilZFail = this.stencilZFail),
          (n.stencilZPass = this.stencilZPass),
          this.rotation && 0 !== this.rotation && (n.rotation = this.rotation),
          !0 === this.polygonOffset && (n.polygonOffset = !0),
          0 !== this.polygonOffsetFactor &&
            (n.polygonOffsetFactor = this.polygonOffsetFactor),
          0 !== this.polygonOffsetUnits &&
            (n.polygonOffsetUnits = this.polygonOffsetUnits),
          this.linewidth &&
            1 !== this.linewidth &&
            (n.linewidth = this.linewidth),
          void 0 !== this.dashSize && (n.dashSize = this.dashSize),
          void 0 !== this.gapSize && (n.gapSize = this.gapSize),
          void 0 !== this.scale && (n.scale = this.scale),
          !0 === this.dithering && (n.dithering = !0),
          this.alphaTest > 0 && (n.alphaTest = this.alphaTest),
          !0 === this.alphaToCoverage &&
            (n.alphaToCoverage = this.alphaToCoverage),
          !0 === this.premultipliedAlpha &&
            (n.premultipliedAlpha = this.premultipliedAlpha),
          !0 === this.wireframe && (n.wireframe = this.wireframe),
          this.wireframeLinewidth > 1 &&
            (n.wireframeLinewidth = this.wireframeLinewidth),
          "round" !== this.wireframeLinecap &&
            (n.wireframeLinecap = this.wireframeLinecap),
          "round" !== this.wireframeLinejoin &&
            (n.wireframeLinejoin = this.wireframeLinejoin),
          !0 === this.flatShading && (n.flatShading = this.flatShading),
          !1 === this.visible && (n.visible = !1),
          !1 === this.toneMapped && (n.toneMapped = !1),
          "{}" !== JSON.stringify(this.userData) &&
            (n.userData = this.userData),
          e)
        ) {
          const e = i(t.textures),
            r = i(t.images);
          e.length > 0 && (n.textures = e), r.length > 0 && (n.images = r);
        }
        return n;
      }
      clone() {
        return new this.constructor().copy(this);
      }
      copy(t) {
        (this.name = t.name),
          (this.fog = t.fog),
          (this.blending = t.blending),
          (this.side = t.side),
          (this.vertexColors = t.vertexColors),
          (this.opacity = t.opacity),
          (this.format = t.format),
          (this.transparent = t.transparent),
          (this.blendSrc = t.blendSrc),
          (this.blendDst = t.blendDst),
          (this.blendEquation = t.blendEquation),
          (this.blendSrcAlpha = t.blendSrcAlpha),
          (this.blendDstAlpha = t.blendDstAlpha),
          (this.blendEquationAlpha = t.blendEquationAlpha),
          (this.depthFunc = t.depthFunc),
          (this.depthTest = t.depthTest),
          (this.depthWrite = t.depthWrite),
          (this.stencilWriteMask = t.stencilWriteMask),
          (this.stencilFunc = t.stencilFunc),
          (this.stencilRef = t.stencilRef),
          (this.stencilFuncMask = t.stencilFuncMask),
          (this.stencilFail = t.stencilFail),
          (this.stencilZFail = t.stencilZFail),
          (this.stencilZPass = t.stencilZPass),
          (this.stencilWrite = t.stencilWrite);
        const e = t.clippingPlanes;
        let n = null;
        if (null !== e) {
          const t = e.length;
          n = new Array(t);
          for (let i = 0; i !== t; ++i) n[i] = e[i].clone();
        }
        return (
          (this.clippingPlanes = n),
          (this.clipIntersection = t.clipIntersection),
          (this.clipShadows = t.clipShadows),
          (this.shadowSide = t.shadowSide),
          (this.colorWrite = t.colorWrite),
          (this.precision = t.precision),
          (this.polygonOffset = t.polygonOffset),
          (this.polygonOffsetFactor = t.polygonOffsetFactor),
          (this.polygonOffsetUnits = t.polygonOffsetUnits),
          (this.dithering = t.dithering),
          (this.alphaTest = t.alphaTest),
          (this.alphaToCoverage = t.alphaToCoverage),
          (this.premultipliedAlpha = t.premultipliedAlpha),
          (this.visible = t.visible),
          (this.toneMapped = t.toneMapped),
          (this.userData = JSON.parse(JSON.stringify(t.userData))),
          this
        );
      }
      dispose() {
        this.dispatchEvent({ type: "dispose" });
      }
      set needsUpdate(t) {
        !0 === t && this.version++;
      }
    }
    Bi.prototype.isMaterial = !0;
    const Ui = {
        aliceblue: 15792383,
        antiquewhite: 16444375,
        aqua: 65535,
        aquamarine: 8388564,
        azure: 15794175,
        beige: 16119260,
        bisque: 16770244,
        black: 0,
        blanchedalmond: 16772045,
        blue: 255,
        blueviolet: 9055202,
        brown: 10824234,
        burlywood: 14596231,
        cadetblue: 6266528,
        chartreuse: 8388352,
        chocolate: 13789470,
        coral: 16744272,
        cornflowerblue: 6591981,
        cornsilk: 16775388,
        crimson: 14423100,
        cyan: 65535,
        darkblue: 139,
        darkcyan: 35723,
        darkgoldenrod: 12092939,
        darkgray: 11119017,
        darkgreen: 25600,
        darkgrey: 11119017,
        darkkhaki: 12433259,
        darkmagenta: 9109643,
        darkolivegreen: 5597999,
        darkorange: 16747520,
        darkorchid: 10040012,
        darkred: 9109504,
        darksalmon: 15308410,
        darkseagreen: 9419919,
        darkslateblue: 4734347,
        darkslategray: 3100495,
        darkslategrey: 3100495,
        darkturquoise: 52945,
        darkviolet: 9699539,
        deeppink: 16716947,
        deepskyblue: 49151,
        dimgray: 6908265,
        dimgrey: 6908265,
        dodgerblue: 2003199,
        firebrick: 11674146,
        floralwhite: 16775920,
        forestgreen: 2263842,
        fuchsia: 16711935,
        gainsboro: 14474460,
        ghostwhite: 16316671,
        gold: 16766720,
        goldenrod: 14329120,
        gray: 8421504,
        green: 32768,
        greenyellow: 11403055,
        grey: 8421504,
        honeydew: 15794160,
        hotpink: 16738740,
        indianred: 13458524,
        indigo: 4915330,
        ivory: 16777200,
        khaki: 15787660,
        lavender: 15132410,
        lavenderblush: 16773365,
        lawngreen: 8190976,
        lemonchiffon: 16775885,
        lightblue: 11393254,
        lightcoral: 15761536,
        lightcyan: 14745599,
        lightgoldenrodyellow: 16448210,
        lightgray: 13882323,
        lightgreen: 9498256,
        lightgrey: 13882323,
        lightpink: 16758465,
        lightsalmon: 16752762,
        lightseagreen: 2142890,
        lightskyblue: 8900346,
        lightslategray: 7833753,
        lightslategrey: 7833753,
        lightsteelblue: 11584734,
        lightyellow: 16777184,
        lime: 65280,
        limegreen: 3329330,
        linen: 16445670,
        magenta: 16711935,
        maroon: 8388608,
        mediumaquamarine: 6737322,
        mediumblue: 205,
        mediumorchid: 12211667,
        mediumpurple: 9662683,
        mediumseagreen: 3978097,
        mediumslateblue: 8087790,
        mediumspringgreen: 64154,
        mediumturquoise: 4772300,
        mediumvioletred: 13047173,
        midnightblue: 1644912,
        mintcream: 16121850,
        mistyrose: 16770273,
        moccasin: 16770229,
        navajowhite: 16768685,
        navy: 128,
        oldlace: 16643558,
        olive: 8421376,
        olivedrab: 7048739,
        orange: 16753920,
        orangered: 16729344,
        orchid: 14315734,
        palegoldenrod: 15657130,
        palegreen: 10025880,
        paleturquoise: 11529966,
        palevioletred: 14381203,
        papayawhip: 16773077,
        peachpuff: 16767673,
        peru: 13468991,
        pink: 16761035,
        plum: 14524637,
        powderblue: 11591910,
        purple: 8388736,
        rebeccapurple: 6697881,
        red: 16711680,
        rosybrown: 12357519,
        royalblue: 4286945,
        saddlebrown: 9127187,
        salmon: 16416882,
        sandybrown: 16032864,
        seagreen: 3050327,
        seashell: 16774638,
        sienna: 10506797,
        silver: 12632256,
        skyblue: 8900331,
        slateblue: 6970061,
        slategray: 7372944,
        slategrey: 7372944,
        snow: 16775930,
        springgreen: 65407,
        steelblue: 4620980,
        tan: 13808780,
        teal: 32896,
        thistle: 14204888,
        tomato: 16737095,
        turquoise: 4251856,
        violet: 15631086,
        wheat: 16113331,
        white: 16777215,
        whitesmoke: 16119285,
        yellow: 16776960,
        yellowgreen: 10145074,
      },
      Fi = { h: 0, s: 0, l: 0 },
      Vi = { h: 0, s: 0, l: 0 };
    function Wi(t, e, n) {
      return (
        n < 0 && (n += 1),
        n > 1 && (n -= 1),
        n < 1 / 6
          ? t + 6 * (e - t) * n
          : n < 0.5
          ? e
          : n < 2 / 3
          ? t + 6 * (e - t) * (2 / 3 - n)
          : t
      );
    }
    function Gi(t) {
      return t < 0.04045
        ? 0.0773993808 * t
        : Math.pow(0.9478672986 * t + 0.0521327014, 2.4);
    }
    function ji(t) {
      return t < 0.0031308 ? 12.92 * t : 1.055 * Math.pow(t, 0.41666) - 0.055;
    }
    class qi {
      constructor(t, e, n) {
        return void 0 === e && void 0 === n
          ? this.set(t)
          : this.setRGB(t, e, n);
      }
      set(t) {
        return (
          t && t.isColor
            ? this.copy(t)
            : "number" == typeof t
            ? this.setHex(t)
            : "string" == typeof t && this.setStyle(t),
          this
        );
      }
      setScalar(t) {
        return (this.r = t), (this.g = t), (this.b = t), this;
      }
      setHex(t) {
        return (
          (t = Math.floor(t)),
          (this.r = ((t >> 16) & 255) / 255),
          (this.g = ((t >> 8) & 255) / 255),
          (this.b = (255 & t) / 255),
          this
        );
      }
      setRGB(t, e, n) {
        return (this.r = t), (this.g = e), (this.b = n), this;
      }
      setHSL(t, e, n) {
        if (((t = an(t, 1)), (e = on(e, 0, 1)), (n = on(n, 0, 1)), 0 === e))
          this.r = this.g = this.b = n;
        else {
          const i = n <= 0.5 ? n * (1 + e) : n + e - n * e,
            r = 2 * n - i;
          (this.r = Wi(r, i, t + 1 / 3)),
            (this.g = Wi(r, i, t)),
            (this.b = Wi(r, i, t - 1 / 3));
        }
        return this;
      }
      setStyle(t) {
        function e(e) {
          void 0 !== e &&
            parseFloat(e) < 1 &&
            console.warn(
              "THREE.Color: Alpha component of " + t + " will be ignored."
            );
        }
        let n;
        if ((n = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(t))) {
          let t;
          const i = n[1],
            r = n[2];
          switch (i) {
            case "rgb":
            case "rgba":
              if (
                (t =
                  /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                    r
                  ))
              )
                return (
                  (this.r = Math.min(255, parseInt(t[1], 10)) / 255),
                  (this.g = Math.min(255, parseInt(t[2], 10)) / 255),
                  (this.b = Math.min(255, parseInt(t[3], 10)) / 255),
                  e(t[4]),
                  this
                );
              if (
                (t =
                  /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                    r
                  ))
              )
                return (
                  (this.r = Math.min(100, parseInt(t[1], 10)) / 100),
                  (this.g = Math.min(100, parseInt(t[2], 10)) / 100),
                  (this.b = Math.min(100, parseInt(t[3], 10)) / 100),
                  e(t[4]),
                  this
                );
              break;
            case "hsl":
            case "hsla":
              if (
                (t =
                  /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                    r
                  ))
              ) {
                const n = parseFloat(t[1]) / 360,
                  i = parseInt(t[2], 10) / 100,
                  r = parseInt(t[3], 10) / 100;
                return e(t[4]), this.setHSL(n, i, r);
              }
          }
        } else if ((n = /^\#([A-Fa-f\d]+)$/.exec(t))) {
          const t = n[1],
            e = t.length;
          if (3 === e)
            return (
              (this.r = parseInt(t.charAt(0) + t.charAt(0), 16) / 255),
              (this.g = parseInt(t.charAt(1) + t.charAt(1), 16) / 255),
              (this.b = parseInt(t.charAt(2) + t.charAt(2), 16) / 255),
              this
            );
          if (6 === e)
            return (
              (this.r = parseInt(t.charAt(0) + t.charAt(1), 16) / 255),
              (this.g = parseInt(t.charAt(2) + t.charAt(3), 16) / 255),
              (this.b = parseInt(t.charAt(4) + t.charAt(5), 16) / 255),
              this
            );
        }
        return t && t.length > 0 ? this.setColorName(t) : this;
      }
      setColorName(t) {
        const e = Ui[t.toLowerCase()];
        return (
          void 0 !== e
            ? this.setHex(e)
            : console.warn("THREE.Color: Unknown color " + t),
          this
        );
      }
      clone() {
        return new this.constructor(this.r, this.g, this.b);
      }
      copy(t) {
        return (this.r = t.r), (this.g = t.g), (this.b = t.b), this;
      }
      copySRGBToLinear(t) {
        return (this.r = Gi(t.r)), (this.g = Gi(t.g)), (this.b = Gi(t.b)), this;
      }
      copyLinearToSRGB(t) {
        return (this.r = ji(t.r)), (this.g = ji(t.g)), (this.b = ji(t.b)), this;
      }
      convertSRGBToLinear() {
        return this.copySRGBToLinear(this), this;
      }
      convertLinearToSRGB() {
        return this.copyLinearToSRGB(this), this;
      }
      getHex() {
        return (
          ((255 * this.r) << 16) ^ ((255 * this.g) << 8) ^ ((255 * this.b) << 0)
        );
      }
      getHexString() {
        return ("000000" + this.getHex().toString(16)).slice(-6);
      }
      getHSL(t) {
        const e = this.r,
          n = this.g,
          i = this.b,
          r = Math.max(e, n, i),
          s = Math.min(e, n, i);
        let o, a;
        const l = (s + r) / 2;
        if (s === r) (o = 0), (a = 0);
        else {
          const t = r - s;
          switch (((a = l <= 0.5 ? t / (r + s) : t / (2 - r - s)), r)) {
            case e:
              o = (n - i) / t + (n < i ? 6 : 0);
              break;
            case n:
              o = (i - e) / t + 2;
              break;
            case i:
              o = (e - n) / t + 4;
          }
          o /= 6;
        }
        return (t.h = o), (t.s = a), (t.l = l), t;
      }
      getStyle() {
        return (
          "rgb(" +
          ((255 * this.r) | 0) +
          "," +
          ((255 * this.g) | 0) +
          "," +
          ((255 * this.b) | 0) +
          ")"
        );
      }
      offsetHSL(t, e, n) {
        return (
          this.getHSL(Fi),
          (Fi.h += t),
          (Fi.s += e),
          (Fi.l += n),
          this.setHSL(Fi.h, Fi.s, Fi.l),
          this
        );
      }
      add(t) {
        return (this.r += t.r), (this.g += t.g), (this.b += t.b), this;
      }
      addColors(t, e) {
        return (
          (this.r = t.r + e.r), (this.g = t.g + e.g), (this.b = t.b + e.b), this
        );
      }
      addScalar(t) {
        return (this.r += t), (this.g += t), (this.b += t), this;
      }
      sub(t) {
        return (
          (this.r = Math.max(0, this.r - t.r)),
          (this.g = Math.max(0, this.g - t.g)),
          (this.b = Math.max(0, this.b - t.b)),
          this
        );
      }
      multiply(t) {
        return (this.r *= t.r), (this.g *= t.g), (this.b *= t.b), this;
      }
      multiplyScalar(t) {
        return (this.r *= t), (this.g *= t), (this.b *= t), this;
      }
      lerp(t, e) {
        return (
          (this.r += (t.r - this.r) * e),
          (this.g += (t.g - this.g) * e),
          (this.b += (t.b - this.b) * e),
          this
        );
      }
      lerpColors(t, e, n) {
        return (
          (this.r = t.r + (e.r - t.r) * n),
          (this.g = t.g + (e.g - t.g) * n),
          (this.b = t.b + (e.b - t.b) * n),
          this
        );
      }
      lerpHSL(t, e) {
        this.getHSL(Fi), t.getHSL(Vi);
        const n = ln(Fi.h, Vi.h, e),
          i = ln(Fi.s, Vi.s, e),
          r = ln(Fi.l, Vi.l, e);
        return this.setHSL(n, i, r), this;
      }
      equals(t) {
        return t.r === this.r && t.g === this.g && t.b === this.b;
      }
      fromArray(t, e = 0) {
        return (this.r = t[e]), (this.g = t[e + 1]), (this.b = t[e + 2]), this;
      }
      toArray(t = [], e = 0) {
        return (t[e] = this.r), (t[e + 1] = this.g), (t[e + 2] = this.b), t;
      }
      fromBufferAttribute(t, e) {
        return (
          (this.r = t.getX(e)),
          (this.g = t.getY(e)),
          (this.b = t.getZ(e)),
          !0 === t.normalized &&
            ((this.r /= 255), (this.g /= 255), (this.b /= 255)),
          this
        );
      }
      toJSON() {
        return this.getHex();
      }
    }
    (qi.NAMES = Ui),
      (qi.prototype.isColor = !0),
      (qi.prototype.r = 1),
      (qi.prototype.g = 1),
      (qi.prototype.b = 1);
    class $i extends Bi {
      constructor(t) {
        super(),
          (this.type = "MeshBasicMaterial"),
          (this.color = new qi(16777215)),
          (this.map = null),
          (this.lightMap = null),
          (this.lightMapIntensity = 1),
          (this.aoMap = null),
          (this.aoMapIntensity = 1),
          (this.specularMap = null),
          (this.alphaMap = null),
          (this.envMap = null),
          (this.combine = Y),
          (this.reflectivity = 1),
          (this.refractionRatio = 0.98),
          (this.wireframe = !1),
          (this.wireframeLinewidth = 1),
          (this.wireframeLinecap = "round"),
          (this.wireframeLinejoin = "round"),
          this.setValues(t);
      }
      copy(t) {
        return (
          super.copy(t),
          this.color.copy(t.color),
          (this.map = t.map),
          (this.lightMap = t.lightMap),
          (this.lightMapIntensity = t.lightMapIntensity),
          (this.aoMap = t.aoMap),
          (this.aoMapIntensity = t.aoMapIntensity),
          (this.specularMap = t.specularMap),
          (this.alphaMap = t.alphaMap),
          (this.envMap = t.envMap),
          (this.combine = t.combine),
          (this.reflectivity = t.reflectivity),
          (this.refractionRatio = t.refractionRatio),
          (this.wireframe = t.wireframe),
          (this.wireframeLinewidth = t.wireframeLinewidth),
          (this.wireframeLinecap = t.wireframeLinecap),
          (this.wireframeLinejoin = t.wireframeLinejoin),
          this
        );
      }
    }
    $i.prototype.isMeshBasicMaterial = !0;
    const Xi = new Mn(),
      Ji = new hn();
    class Yi {
      constructor(t, e, n) {
        if (Array.isArray(t))
          throw new TypeError(
            "THREE.BufferAttribute: array should be a Typed Array."
          );
        (this.name = ""),
          (this.array = t),
          (this.itemSize = e),
          (this.count = void 0 !== t ? t.length / e : 0),
          (this.normalized = !0 === n),
          (this.usage = Ze),
          (this.updateRange = { offset: 0, count: -1 }),
          (this.version = 0);
      }
      onUploadCallback() {}
      set needsUpdate(t) {
        !0 === t && this.version++;
      }
      setUsage(t) {
        return (this.usage = t), this;
      }
      copy(t) {
        return (
          (this.name = t.name),
          (this.array = new t.array.constructor(t.array)),
          (this.itemSize = t.itemSize),
          (this.count = t.count),
          (this.normalized = t.normalized),
          (this.usage = t.usage),
          this
        );
      }
      copyAt(t, e, n) {
        (t *= this.itemSize), (n *= e.itemSize);
        for (let i = 0, r = this.itemSize; i < r; i++)
          this.array[t + i] = e.array[n + i];
        return this;
      }
      copyArray(t) {
        return this.array.set(t), this;
      }
      copyColorsArray(t) {
        const e = this.array;
        let n = 0;
        for (let i = 0, r = t.length; i < r; i++) {
          let r = t[i];
          void 0 === r &&
            (console.warn(
              "THREE.BufferAttribute.copyColorsArray(): color is undefined",
              i
            ),
            (r = new qi())),
            (e[n++] = r.r),
            (e[n++] = r.g),
            (e[n++] = r.b);
        }
        return this;
      }
      copyVector2sArray(t) {
        const e = this.array;
        let n = 0;
        for (let i = 0, r = t.length; i < r; i++) {
          let r = t[i];
          void 0 === r &&
            (console.warn(
              "THREE.BufferAttribute.copyVector2sArray(): vector is undefined",
              i
            ),
            (r = new hn())),
            (e[n++] = r.x),
            (e[n++] = r.y);
        }
        return this;
      }
      copyVector3sArray(t) {
        const e = this.array;
        let n = 0;
        for (let i = 0, r = t.length; i < r; i++) {
          let r = t[i];
          void 0 === r &&
            (console.warn(
              "THREE.BufferAttribute.copyVector3sArray(): vector is undefined",
              i
            ),
            (r = new Mn())),
            (e[n++] = r.x),
            (e[n++] = r.y),
            (e[n++] = r.z);
        }
        return this;
      }
      copyVector4sArray(t) {
        const e = this.array;
        let n = 0;
        for (let i = 0, r = t.length; i < r; i++) {
          let r = t[i];
          void 0 === r &&
            (console.warn(
              "THREE.BufferAttribute.copyVector4sArray(): vector is undefined",
              i
            ),
            (r = new bn())),
            (e[n++] = r.x),
            (e[n++] = r.y),
            (e[n++] = r.z),
            (e[n++] = r.w);
        }
        return this;
      }
      applyMatrix3(t) {
        if (2 === this.itemSize)
          for (let e = 0, n = this.count; e < n; e++)
            Ji.fromBufferAttribute(this, e),
              Ji.applyMatrix3(t),
              this.setXY(e, Ji.x, Ji.y);
        else if (3 === this.itemSize)
          for (let e = 0, n = this.count; e < n; e++)
            Xi.fromBufferAttribute(this, e),
              Xi.applyMatrix3(t),
              this.setXYZ(e, Xi.x, Xi.y, Xi.z);
        return this;
      }
      applyMatrix4(t) {
        for (let e = 0, n = this.count; e < n; e++)
          (Xi.x = this.getX(e)),
            (Xi.y = this.getY(e)),
            (Xi.z = this.getZ(e)),
            Xi.applyMatrix4(t),
            this.setXYZ(e, Xi.x, Xi.y, Xi.z);
        return this;
      }
      applyNormalMatrix(t) {
        for (let e = 0, n = this.count; e < n; e++)
          (Xi.x = this.getX(e)),
            (Xi.y = this.getY(e)),
            (Xi.z = this.getZ(e)),
            Xi.applyNormalMatrix(t),
            this.setXYZ(e, Xi.x, Xi.y, Xi.z);
        return this;
      }
      transformDirection(t) {
        for (let e = 0, n = this.count; e < n; e++)
          (Xi.x = this.getX(e)),
            (Xi.y = this.getY(e)),
            (Xi.z = this.getZ(e)),
            Xi.transformDirection(t),
            this.setXYZ(e, Xi.x, Xi.y, Xi.z);
        return this;
      }
      set(t, e = 0) {
        return this.array.set(t, e), this;
      }
      getX(t) {
        return this.array[t * this.itemSize];
      }
      setX(t, e) {
        return (this.array[t * this.itemSize] = e), this;
      }
      getY(t) {
        return this.array[t * this.itemSize + 1];
      }
      setY(t, e) {
        return (this.array[t * this.itemSize + 1] = e), this;
      }
      getZ(t) {
        return this.array[t * this.itemSize + 2];
      }
      setZ(t, e) {
        return (this.array[t * this.itemSize + 2] = e), this;
      }
      getW(t) {
        return this.array[t * this.itemSize + 3];
      }
      setW(t, e) {
        return (this.array[t * this.itemSize + 3] = e), this;
      }
      setXY(t, e, n) {
        return (
          (t *= this.itemSize),
          (this.array[t + 0] = e),
          (this.array[t + 1] = n),
          this
        );
      }
      setXYZ(t, e, n, i) {
        return (
          (t *= this.itemSize),
          (this.array[t + 0] = e),
          (this.array[t + 1] = n),
          (this.array[t + 2] = i),
          this
        );
      }
      setXYZW(t, e, n, i, r) {
        return (
          (t *= this.itemSize),
          (this.array[t + 0] = e),
          (this.array[t + 1] = n),
          (this.array[t + 2] = i),
          (this.array[t + 3] = r),
          this
        );
      }
      onUpload(t) {
        return (this.onUploadCallback = t), this;
      }
      clone() {
        return new this.constructor(this.array, this.itemSize).copy(this);
      }
      toJSON() {
        const t = {
          itemSize: this.itemSize,
          type: this.array.constructor.name,
          array: Array.prototype.slice.call(this.array),
          normalized: this.normalized,
        };
        return (
          "" !== this.name && (t.name = this.name),
          this.usage !== Ze && (t.usage = this.usage),
          (0 === this.updateRange.offset && -1 === this.updateRange.count) ||
            (t.updateRange = this.updateRange),
          t
        );
      }
    }
    Yi.prototype.isBufferAttribute = !0;
    class Zi extends Yi {
      constructor(t, e, n) {
        super(new Uint16Array(t), e, n);
      }
    }
    class Qi extends Yi {
      constructor(t, e, n) {
        super(new Uint32Array(t), e, n);
      }
    }
    (class extends Yi {
      constructor(t, e, n) {
        super(new Uint16Array(t), e, n);
      }
    }.prototype.isFloat16BufferAttribute = !0);
    class Ki extends Yi {
      constructor(t, e, n) {
        super(new Float32Array(t), e, n);
      }
    }
    let tr = 0;
    const er = new ei(),
      nr = new Ei(),
      ir = new Mn(),
      rr = new An(),
      sr = new An(),
      or = new Mn();
    class ar extends tn {
      constructor() {
        super(),
          Object.defineProperty(this, "id", { value: tr++ }),
          (this.uuid = sn()),
          (this.name = ""),
          (this.type = "BufferGeometry"),
          (this.index = null),
          (this.attributes = {}),
          (this.morphAttributes = {}),
          (this.morphTargetsRelative = !1),
          (this.groups = []),
          (this.boundingBox = null),
          (this.boundingSphere = null),
          (this.drawRange = { start: 0, count: 1 / 0 }),
          (this.userData = {});
      }
      getIndex() {
        return this.index;
      }
      setIndex(t) {
        return (
          Array.isArray(t)
            ? (this.index = new (pn(t) > 65535 ? Qi : Zi)(t, 1))
            : (this.index = t),
          this
        );
      }
      getAttribute(t) {
        return this.attributes[t];
      }
      setAttribute(t, e) {
        return (this.attributes[t] = e), this;
      }
      deleteAttribute(t) {
        return delete this.attributes[t], this;
      }
      hasAttribute(t) {
        return void 0 !== this.attributes[t];
      }
      addGroup(t, e, n = 0) {
        this.groups.push({ start: t, count: e, materialIndex: n });
      }
      clearGroups() {
        this.groups = [];
      }
      setDrawRange(t, e) {
        (this.drawRange.start = t), (this.drawRange.count = e);
      }
      applyMatrix4(t) {
        const e = this.attributes.position;
        void 0 !== e && (e.applyMatrix4(t), (e.needsUpdate = !0));
        const n = this.attributes.normal;
        if (void 0 !== n) {
          const e = new dn().getNormalMatrix(t);
          n.applyNormalMatrix(e), (n.needsUpdate = !0);
        }
        const i = this.attributes.tangent;
        return (
          void 0 !== i && (i.transformDirection(t), (i.needsUpdate = !0)),
          null !== this.boundingBox && this.computeBoundingBox(),
          null !== this.boundingSphere && this.computeBoundingSphere(),
          this
        );
      }
      applyQuaternion(t) {
        return er.makeRotationFromQuaternion(t), this.applyMatrix4(er), this;
      }
      rotateX(t) {
        return er.makeRotationX(t), this.applyMatrix4(er), this;
      }
      rotateY(t) {
        return er.makeRotationY(t), this.applyMatrix4(er), this;
      }
      rotateZ(t) {
        return er.makeRotationZ(t), this.applyMatrix4(er), this;
      }
      translate(t, e, n) {
        return er.makeTranslation(t, e, n), this.applyMatrix4(er), this;
      }
      scale(t, e, n) {
        return er.makeScale(t, e, n), this.applyMatrix4(er), this;
      }
      lookAt(t) {
        return (
          nr.lookAt(t), nr.updateMatrix(), this.applyMatrix4(nr.matrix), this
        );
      }
      center() {
        return (
          this.computeBoundingBox(),
          this.boundingBox.getCenter(ir).negate(),
          this.translate(ir.x, ir.y, ir.z),
          this
        );
      }
      setFromPoints(t) {
        const e = [];
        for (let n = 0, i = t.length; n < i; n++) {
          const i = t[n];
          e.push(i.x, i.y, i.z || 0);
        }
        return this.setAttribute("position", new Ki(e, 3)), this;
      }
      computeBoundingBox() {
        null === this.boundingBox && (this.boundingBox = new An());
        const t = this.attributes.position,
          e = this.morphAttributes.position;
        if (t && t.isGLBufferAttribute)
          return (
            console.error(
              'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',
              this
            ),
            void this.boundingBox.set(
              new Mn(-1 / 0, -1 / 0, -1 / 0),
              new Mn(1 / 0, 1 / 0, 1 / 0)
            )
          );
        if (void 0 !== t) {
          if ((this.boundingBox.setFromBufferAttribute(t), e))
            for (let t = 0, n = e.length; t < n; t++) {
              const n = e[t];
              rr.setFromBufferAttribute(n),
                this.morphTargetsRelative
                  ? (or.addVectors(this.boundingBox.min, rr.min),
                    this.boundingBox.expandByPoint(or),
                    or.addVectors(this.boundingBox.max, rr.max),
                    this.boundingBox.expandByPoint(or))
                  : (this.boundingBox.expandByPoint(rr.min),
                    this.boundingBox.expandByPoint(rr.max));
            }
        } else this.boundingBox.makeEmpty();
        (isNaN(this.boundingBox.min.x) ||
          isNaN(this.boundingBox.min.y) ||
          isNaN(this.boundingBox.min.z)) &&
          console.error(
            'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
            this
          );
      }
      computeBoundingSphere() {
        null === this.boundingSphere && (this.boundingSphere = new qn());
        const t = this.attributes.position,
          e = this.morphAttributes.position;
        if (t && t.isGLBufferAttribute)
          return (
            console.error(
              'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',
              this
            ),
            void this.boundingSphere.set(new Mn(), 1 / 0)
          );
        if (t) {
          const n = this.boundingSphere.center;
          if ((rr.setFromBufferAttribute(t), e))
            for (let t = 0, n = e.length; t < n; t++) {
              const n = e[t];
              sr.setFromBufferAttribute(n),
                this.morphTargetsRelative
                  ? (or.addVectors(rr.min, sr.min),
                    rr.expandByPoint(or),
                    or.addVectors(rr.max, sr.max),
                    rr.expandByPoint(or))
                  : (rr.expandByPoint(sr.min), rr.expandByPoint(sr.max));
            }
          rr.getCenter(n);
          let i = 0;
          for (let e = 0, r = t.count; e < r; e++)
            or.fromBufferAttribute(t, e),
              (i = Math.max(i, n.distanceToSquared(or)));
          if (e)
            for (let r = 0, s = e.length; r < s; r++) {
              const s = e[r],
                o = this.morphTargetsRelative;
              for (let e = 0, r = s.count; e < r; e++)
                or.fromBufferAttribute(s, e),
                  o && (ir.fromBufferAttribute(t, e), or.add(ir)),
                  (i = Math.max(i, n.distanceToSquared(or)));
            }
          (this.boundingSphere.radius = Math.sqrt(i)),
            isNaN(this.boundingSphere.radius) &&
              console.error(
                'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
                this
              );
        }
      }
      computeTangents() {
        const t = this.index,
          e = this.attributes;
        if (
          null === t ||
          void 0 === e.position ||
          void 0 === e.normal ||
          void 0 === e.uv
        )
          return void console.error(
            "THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)"
          );
        const n = t.array,
          i = e.position.array,
          r = e.normal.array,
          s = e.uv.array,
          o = i.length / 3;
        void 0 === e.tangent &&
          this.setAttribute("tangent", new Yi(new Float32Array(4 * o), 4));
        const a = e.tangent.array,
          l = [],
          c = [];
        for (let t = 0; t < o; t++) (l[t] = new Mn()), (c[t] = new Mn());
        const u = new Mn(),
          h = new Mn(),
          d = new Mn(),
          p = new hn(),
          f = new hn(),
          m = new hn(),
          g = new Mn(),
          v = new Mn();
        function y(t, e, n) {
          u.fromArray(i, 3 * t),
            h.fromArray(i, 3 * e),
            d.fromArray(i, 3 * n),
            p.fromArray(s, 2 * t),
            f.fromArray(s, 2 * e),
            m.fromArray(s, 2 * n),
            h.sub(u),
            d.sub(u),
            f.sub(p),
            m.sub(p);
          const r = 1 / (f.x * m.y - m.x * f.y);
          isFinite(r) &&
            (g
              .copy(h)
              .multiplyScalar(m.y)
              .addScaledVector(d, -f.y)
              .multiplyScalar(r),
            v
              .copy(d)
              .multiplyScalar(f.x)
              .addScaledVector(h, -m.x)
              .multiplyScalar(r),
            l[t].add(g),
            l[e].add(g),
            l[n].add(g),
            c[t].add(v),
            c[e].add(v),
            c[n].add(v));
        }
        let x = this.groups;
        0 === x.length && (x = [{ start: 0, count: n.length }]);
        for (let t = 0, e = x.length; t < e; ++t) {
          const e = x[t],
            i = e.start;
          for (let t = i, r = i + e.count; t < r; t += 3)
            y(n[t + 0], n[t + 1], n[t + 2]);
        }
        const b = new Mn(),
          _ = new Mn(),
          w = new Mn(),
          S = new Mn();
        function M(t) {
          w.fromArray(r, 3 * t), S.copy(w);
          const e = l[t];
          b.copy(e),
            b.sub(w.multiplyScalar(w.dot(e))).normalize(),
            _.crossVectors(S, e);
          const n = _.dot(c[t]) < 0 ? -1 : 1;
          (a[4 * t] = b.x),
            (a[4 * t + 1] = b.y),
            (a[4 * t + 2] = b.z),
            (a[4 * t + 3] = n);
        }
        for (let t = 0, e = x.length; t < e; ++t) {
          const e = x[t],
            i = e.start;
          for (let t = i, r = i + e.count; t < r; t += 3)
            M(n[t + 0]), M(n[t + 1]), M(n[t + 2]);
        }
      }
      computeVertexNormals() {
        const t = this.index,
          e = this.getAttribute("position");
        if (void 0 !== e) {
          let n = this.getAttribute("normal");
          if (void 0 === n)
            (n = new Yi(new Float32Array(3 * e.count), 3)),
              this.setAttribute("normal", n);
          else for (let t = 0, e = n.count; t < e; t++) n.setXYZ(t, 0, 0, 0);
          const i = new Mn(),
            r = new Mn(),
            s = new Mn(),
            o = new Mn(),
            a = new Mn(),
            l = new Mn(),
            c = new Mn(),
            u = new Mn();
          if (t)
            for (let h = 0, d = t.count; h < d; h += 3) {
              const d = t.getX(h + 0),
                p = t.getX(h + 1),
                f = t.getX(h + 2);
              i.fromBufferAttribute(e, d),
                r.fromBufferAttribute(e, p),
                s.fromBufferAttribute(e, f),
                c.subVectors(s, r),
                u.subVectors(i, r),
                c.cross(u),
                o.fromBufferAttribute(n, d),
                a.fromBufferAttribute(n, p),
                l.fromBufferAttribute(n, f),
                o.add(c),
                a.add(c),
                l.add(c),
                n.setXYZ(d, o.x, o.y, o.z),
                n.setXYZ(p, a.x, a.y, a.z),
                n.setXYZ(f, l.x, l.y, l.z);
            }
          else
            for (let t = 0, o = e.count; t < o; t += 3)
              i.fromBufferAttribute(e, t + 0),
                r.fromBufferAttribute(e, t + 1),
                s.fromBufferAttribute(e, t + 2),
                c.subVectors(s, r),
                u.subVectors(i, r),
                c.cross(u),
                n.setXYZ(t + 0, c.x, c.y, c.z),
                n.setXYZ(t + 1, c.x, c.y, c.z),
                n.setXYZ(t + 2, c.x, c.y, c.z);
          this.normalizeNormals(), (n.needsUpdate = !0);
        }
      }
      merge(t, e) {
        if (!t || !t.isBufferGeometry)
          return void console.error(
            "THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",
            t
          );
        void 0 === e &&
          ((e = 0),
          console.warn(
            "THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."
          ));
        const n = this.attributes;
        for (const i in n) {
          if (void 0 === t.attributes[i]) continue;
          const r = n[i].array,
            s = t.attributes[i],
            o = s.array,
            a = s.itemSize * e,
            l = Math.min(o.length, r.length - a);
          for (let t = 0, e = a; t < l; t++, e++) r[e] = o[t];
        }
        return this;
      }
      normalizeNormals() {
        const t = this.attributes.normal;
        for (let e = 0, n = t.count; e < n; e++)
          or.fromBufferAttribute(t, e),
            or.normalize(),
            t.setXYZ(e, or.x, or.y, or.z);
      }
      toNonIndexed() {
        function t(t, e) {
          const n = t.array,
            i = t.itemSize,
            r = t.normalized,
            s = new n.constructor(e.length * i);
          let o = 0,
            a = 0;
          for (let r = 0, l = e.length; r < l; r++) {
            o = t.isInterleavedBufferAttribute
              ? e[r] * t.data.stride + t.offset
              : e[r] * i;
            for (let t = 0; t < i; t++) s[a++] = n[o++];
          }
          return new Yi(s, i, r);
        }
        if (null === this.index)
          return (
            console.warn(
              "THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."
            ),
            this
          );
        const e = new ar(),
          n = this.index.array,
          i = this.attributes;
        for (const r in i) {
          const s = t(i[r], n);
          e.setAttribute(r, s);
        }
        const r = this.morphAttributes;
        for (const i in r) {
          const s = [],
            o = r[i];
          for (let e = 0, i = o.length; e < i; e++) {
            const i = t(o[e], n);
            s.push(i);
          }
          e.morphAttributes[i] = s;
        }
        e.morphTargetsRelative = this.morphTargetsRelative;
        const s = this.groups;
        for (let t = 0, n = s.length; t < n; t++) {
          const n = s[t];
          e.addGroup(n.start, n.count, n.materialIndex);
        }
        return e;
      }
      toJSON() {
        const t = {
          metadata: {
            version: 4.5,
            type: "BufferGeometry",
            generator: "BufferGeometry.toJSON",
          },
        };
        if (
          ((t.uuid = this.uuid),
          (t.type = this.type),
          "" !== this.name && (t.name = this.name),
          Object.keys(this.userData).length > 0 && (t.userData = this.userData),
          void 0 !== this.parameters)
        ) {
          const e = this.parameters;
          for (const n in e) void 0 !== e[n] && (t[n] = e[n]);
          return t;
        }
        t.data = { attributes: {} };
        const e = this.index;
        null !== e &&
          (t.data.index = {
            type: e.array.constructor.name,
            array: Array.prototype.slice.call(e.array),
          });
        const n = this.attributes;
        for (const e in n) {
          const i = n[e];
          t.data.attributes[e] = i.toJSON(t.data);
        }
        const i = {};
        let r = !1;
        for (const e in this.morphAttributes) {
          const n = this.morphAttributes[e],
            s = [];
          for (let e = 0, i = n.length; e < i; e++) {
            const i = n[e];
            s.push(i.toJSON(t.data));
          }
          s.length > 0 && ((i[e] = s), (r = !0));
        }
        r &&
          ((t.data.morphAttributes = i),
          (t.data.morphTargetsRelative = this.morphTargetsRelative));
        const s = this.groups;
        s.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(s)));
        const o = this.boundingSphere;
        return (
          null !== o &&
            (t.data.boundingSphere = {
              center: o.center.toArray(),
              radius: o.radius,
            }),
          t
        );
      }
      clone() {
        return new this.constructor().copy(this);
      }
      copy(t) {
        (this.index = null),
          (this.attributes = {}),
          (this.morphAttributes = {}),
          (this.groups = []),
          (this.boundingBox = null),
          (this.boundingSphere = null);
        const e = {};
        this.name = t.name;
        const n = t.index;
        null !== n && this.setIndex(n.clone(e));
        const i = t.attributes;
        for (const t in i) {
          const n = i[t];
          this.setAttribute(t, n.clone(e));
        }
        const r = t.morphAttributes;
        for (const t in r) {
          const n = [],
            i = r[t];
          for (let t = 0, r = i.length; t < r; t++) n.push(i[t].clone(e));
          this.morphAttributes[t] = n;
        }
        this.morphTargetsRelative = t.morphTargetsRelative;
        const s = t.groups;
        for (let t = 0, e = s.length; t < e; t++) {
          const e = s[t];
          this.addGroup(e.start, e.count, e.materialIndex);
        }
        const o = t.boundingBox;
        null !== o && (this.boundingBox = o.clone());
        const a = t.boundingSphere;
        return (
          null !== a && (this.boundingSphere = a.clone()),
          (this.drawRange.start = t.drawRange.start),
          (this.drawRange.count = t.drawRange.count),
          (this.userData = t.userData),
          void 0 !== t.parameters &&
            (this.parameters = Object.assign({}, t.parameters)),
          this
        );
      }
      dispose() {
        this.dispatchEvent({ type: "dispose" });
      }
    }
    ar.prototype.isBufferGeometry = !0;
    const lr = new ei(),
      cr = new ti(),
      ur = new qn(),
      hr = new Mn(),
      dr = new Mn(),
      pr = new Mn(),
      fr = new Mn(),
      mr = new Mn(),
      gr = new Mn(),
      vr = new Mn(),
      yr = new Mn(),
      xr = new Mn(),
      br = new hn(),
      _r = new hn(),
      wr = new hn(),
      Sr = new Mn(),
      Mr = new Mn();
    class Tr extends Ei {
      constructor(t = new ar(), e = new $i()) {
        super(),
          (this.type = "Mesh"),
          (this.geometry = t),
          (this.material = e),
          this.updateMorphTargets();
      }
      copy(t) {
        return (
          super.copy(t),
          void 0 !== t.morphTargetInfluences &&
            (this.morphTargetInfluences = t.morphTargetInfluences.slice()),
          void 0 !== t.morphTargetDictionary &&
            (this.morphTargetDictionary = Object.assign(
              {},
              t.morphTargetDictionary
            )),
          (this.material = t.material),
          (this.geometry = t.geometry),
          this
        );
      }
      updateMorphTargets() {
        const t = this.geometry;
        if (t.isBufferGeometry) {
          const e = t.morphAttributes,
            n = Object.keys(e);
          if (n.length > 0) {
            const t = e[n[0]];
            if (void 0 !== t) {
              (this.morphTargetInfluences = []),
                (this.morphTargetDictionary = {});
              for (let e = 0, n = t.length; e < n; e++) {
                const n = t[e].name || String(e);
                this.morphTargetInfluences.push(0),
                  (this.morphTargetDictionary[n] = e);
              }
            }
          }
        } else {
          const e = t.morphTargets;
          void 0 !== e &&
            e.length > 0 &&
            console.error(
              "THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
            );
        }
      }
      raycast(t, e) {
        const n = this.geometry,
          i = this.material,
          r = this.matrixWorld;
        if (void 0 === i) return;
        if (
          (null === n.boundingSphere && n.computeBoundingSphere(),
          ur.copy(n.boundingSphere),
          ur.applyMatrix4(r),
          !1 === t.ray.intersectsSphere(ur))
        )
          return;
        if (
          (lr.copy(r).invert(),
          cr.copy(t.ray).applyMatrix4(lr),
          null !== n.boundingBox && !1 === cr.intersectsBox(n.boundingBox))
        )
          return;
        let s;
        if (n.isBufferGeometry) {
          const r = n.index,
            o = n.attributes.position,
            a = n.morphAttributes.position,
            l = n.morphTargetsRelative,
            c = n.attributes.uv,
            u = n.attributes.uv2,
            h = n.groups,
            d = n.drawRange;
          if (null !== r)
            if (Array.isArray(i))
              for (let n = 0, p = h.length; n < p; n++) {
                const p = h[n],
                  f = i[p.materialIndex];
                for (
                  let n = Math.max(p.start, d.start),
                    i = Math.min(
                      r.count,
                      Math.min(p.start + p.count, d.start + d.count)
                    );
                  n < i;
                  n += 3
                ) {
                  const i = r.getX(n),
                    h = r.getX(n + 1),
                    d = r.getX(n + 2);
                  (s = Er(this, f, t, cr, o, a, l, c, u, i, h, d)),
                    s &&
                      ((s.faceIndex = Math.floor(n / 3)),
                      (s.face.materialIndex = p.materialIndex),
                      e.push(s));
                }
              }
            else {
              for (
                let n = Math.max(0, d.start),
                  h = Math.min(r.count, d.start + d.count);
                n < h;
                n += 3
              ) {
                const h = r.getX(n),
                  d = r.getX(n + 1),
                  p = r.getX(n + 2);
                (s = Er(this, i, t, cr, o, a, l, c, u, h, d, p)),
                  s && ((s.faceIndex = Math.floor(n / 3)), e.push(s));
              }
            }
          else if (void 0 !== o)
            if (Array.isArray(i))
              for (let n = 0, r = h.length; n < r; n++) {
                const r = h[n],
                  p = i[r.materialIndex];
                for (
                  let n = Math.max(r.start, d.start),
                    i = Math.min(
                      o.count,
                      Math.min(r.start + r.count, d.start + d.count)
                    );
                  n < i;
                  n += 3
                ) {
                  (s = Er(this, p, t, cr, o, a, l, c, u, n, n + 1, n + 2)),
                    s &&
                      ((s.faceIndex = Math.floor(n / 3)),
                      (s.face.materialIndex = r.materialIndex),
                      e.push(s));
                }
              }
            else {
              for (
                let n = Math.max(0, d.start),
                  r = Math.min(o.count, d.start + d.count);
                n < r;
                n += 3
              ) {
                (s = Er(this, i, t, cr, o, a, l, c, u, n, n + 1, n + 2)),
                  s && ((s.faceIndex = Math.floor(n / 3)), e.push(s));
              }
            }
        } else
          n.isGeometry &&
            console.error(
              "THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
            );
      }
    }
    function Er(t, e, n, i, r, s, o, a, l, c, u, h) {
      hr.fromBufferAttribute(r, c),
        dr.fromBufferAttribute(r, u),
        pr.fromBufferAttribute(r, h);
      const d = t.morphTargetInfluences;
      if (s && d) {
        vr.set(0, 0, 0), yr.set(0, 0, 0), xr.set(0, 0, 0);
        for (let t = 0, e = s.length; t < e; t++) {
          const e = d[t],
            n = s[t];
          0 !== e &&
            (fr.fromBufferAttribute(n, c),
            mr.fromBufferAttribute(n, u),
            gr.fromBufferAttribute(n, h),
            o
              ? (vr.addScaledVector(fr, e),
                yr.addScaledVector(mr, e),
                xr.addScaledVector(gr, e))
              : (vr.addScaledVector(fr.sub(hr), e),
                yr.addScaledVector(mr.sub(dr), e),
                xr.addScaledVector(gr.sub(pr), e)));
        }
        hr.add(vr), dr.add(yr), pr.add(xr);
      }
      t.isSkinnedMesh &&
        (t.boneTransform(c, hr),
        t.boneTransform(u, dr),
        t.boneTransform(h, pr));
      const p = (function (t, e, n, i, r, s, o, a) {
        let l;
        if (
          ((l =
            e.side === g
              ? i.intersectTriangle(o, s, r, !0, a)
              : i.intersectTriangle(r, s, o, e.side !== v, a)),
          null === l)
        )
          return null;
        Mr.copy(a), Mr.applyMatrix4(t.matrixWorld);
        const c = n.ray.origin.distanceTo(Mr);
        return c < n.near || c > n.far
          ? null
          : { distance: c, point: Mr.clone(), object: t };
      })(t, e, n, i, hr, dr, pr, Sr);
      if (p) {
        a &&
          (br.fromBufferAttribute(a, c),
          _r.fromBufferAttribute(a, u),
          wr.fromBufferAttribute(a, h),
          (p.uv = zi.getUV(Sr, hr, dr, pr, br, _r, wr, new hn()))),
          l &&
            (br.fromBufferAttribute(l, c),
            _r.fromBufferAttribute(l, u),
            wr.fromBufferAttribute(l, h),
            (p.uv2 = zi.getUV(Sr, hr, dr, pr, br, _r, wr, new hn())));
        const t = { a: c, b: u, c: h, normal: new Mn(), materialIndex: 0 };
        zi.getNormal(hr, dr, pr, t.normal), (p.face = t);
      }
      return p;
    }
    Tr.prototype.isMesh = !0;
    class Ar extends ar {
      constructor(t = 1, e = 1, n = 1, i = 1, r = 1, s = 1) {
        super(),
          (this.type = "BoxGeometry"),
          (this.parameters = {
            width: t,
            height: e,
            depth: n,
            widthSegments: i,
            heightSegments: r,
            depthSegments: s,
          });
        const o = this;
        (i = Math.floor(i)), (r = Math.floor(r)), (s = Math.floor(s));
        const a = [],
          l = [],
          c = [],
          u = [];
        let h = 0,
          d = 0;
        function p(t, e, n, i, r, s, p, f, m, g, v) {
          const y = s / m,
            x = p / g,
            b = s / 2,
            _ = p / 2,
            w = f / 2,
            S = m + 1,
            M = g + 1;
          let T = 0,
            E = 0;
          const A = new Mn();
          for (let s = 0; s < M; s++) {
            const o = s * x - _;
            for (let a = 0; a < S; a++) {
              const h = a * y - b;
              (A[t] = h * i),
                (A[e] = o * r),
                (A[n] = w),
                l.push(A.x, A.y, A.z),
                (A[t] = 0),
                (A[e] = 0),
                (A[n] = f > 0 ? 1 : -1),
                c.push(A.x, A.y, A.z),
                u.push(a / m),
                u.push(1 - s / g),
                (T += 1);
            }
          }
          for (let t = 0; t < g; t++)
            for (let e = 0; e < m; e++) {
              const n = h + e + S * t,
                i = h + e + S * (t + 1),
                r = h + (e + 1) + S * (t + 1),
                s = h + (e + 1) + S * t;
              a.push(n, i, s), a.push(i, r, s), (E += 6);
            }
          o.addGroup(d, E, v), (d += E), (h += T);
        }
        p("z", "y", "x", -1, -1, n, e, t, s, r, 0),
          p("z", "y", "x", 1, -1, n, e, -t, s, r, 1),
          p("x", "z", "y", 1, 1, t, n, e, i, s, 2),
          p("x", "z", "y", 1, -1, t, n, -e, i, s, 3),
          p("x", "y", "z", 1, -1, t, e, n, i, r, 4),
          p("x", "y", "z", -1, -1, t, e, -n, i, r, 5),
          this.setIndex(a),
          this.setAttribute("position", new Ki(l, 3)),
          this.setAttribute("normal", new Ki(c, 3)),
          this.setAttribute("uv", new Ki(u, 2));
      }
      static fromJSON(t) {
        return new Ar(
          t.width,
          t.height,
          t.depth,
          t.widthSegments,
          t.heightSegments,
          t.depthSegments
        );
      }
    }
    function Cr(t) {
      const e = {};
      for (const n in t) {
        e[n] = {};
        for (const i in t[n]) {
          const r = t[n][i];
          r &&
          (r.isColor ||
            r.isMatrix3 ||
            r.isMatrix4 ||
            r.isVector2 ||
            r.isVector3 ||
            r.isVector4 ||
            r.isTexture ||
            r.isQuaternion)
            ? (e[n][i] = r.clone())
            : Array.isArray(r)
            ? (e[n][i] = r.slice())
            : (e[n][i] = r);
        }
      }
      return e;
    }
    function Lr(t) {
      const e = {};
      for (let n = 0; n < t.length; n++) {
        const i = Cr(t[n]);
        for (const t in i) e[t] = i[t];
      }
      return e;
    }
    const Rr = { clone: Cr, merge: Lr };
    var Pr =
        "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
      Dr = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";
    class kr extends Bi {
      constructor(t) {
        super(),
          (this.type = "ShaderMaterial"),
          (this.defines = {}),
          (this.uniforms = {}),
          (this.vertexShader = Pr),
          (this.fragmentShader = Dr),
          (this.linewidth = 1),
          (this.wireframe = !1),
          (this.wireframeLinewidth = 1),
          (this.fog = !1),
          (this.lights = !1),
          (this.clipping = !1),
          (this.extensions = {
            derivatives: !1,
            fragDepth: !1,
            drawBuffers: !1,
            shaderTextureLOD: !1,
          }),
          (this.defaultAttributeValues = {
            color: [1, 1, 1],
            uv: [0, 0],
            uv2: [0, 0],
          }),
          (this.index0AttributeName = void 0),
          (this.uniformsNeedUpdate = !1),
          (this.glslVersion = null),
          void 0 !== t &&
            (void 0 !== t.attributes &&
              console.error(
                "THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."
              ),
            this.setValues(t));
      }
      copy(t) {
        return (
          super.copy(t),
          (this.fragmentShader = t.fragmentShader),
          (this.vertexShader = t.vertexShader),
          (this.uniforms = Cr(t.uniforms)),
          (this.defines = Object.assign({}, t.defines)),
          (this.wireframe = t.wireframe),
          (this.wireframeLinewidth = t.wireframeLinewidth),
          (this.lights = t.lights),
          (this.clipping = t.clipping),
          (this.extensions = Object.assign({}, t.extensions)),
          (this.glslVersion = t.glslVersion),
          this
        );
      }
      toJSON(t) {
        const e = super.toJSON(t);
        (e.glslVersion = this.glslVersion), (e.uniforms = {});
        for (const n in this.uniforms) {
          const i = this.uniforms[n].value;
          i && i.isTexture
            ? (e.uniforms[n] = { type: "t", value: i.toJSON(t).uuid })
            : i && i.isColor
            ? (e.uniforms[n] = { type: "c", value: i.getHex() })
            : i && i.isVector2
            ? (e.uniforms[n] = { type: "v2", value: i.toArray() })
            : i && i.isVector3
            ? (e.uniforms[n] = { type: "v3", value: i.toArray() })
            : i && i.isVector4
            ? (e.uniforms[n] = { type: "v4", value: i.toArray() })
            : i && i.isMatrix3
            ? (e.uniforms[n] = { type: "m3", value: i.toArray() })
            : i && i.isMatrix4
            ? (e.uniforms[n] = { type: "m4", value: i.toArray() })
            : (e.uniforms[n] = { value: i });
        }
        Object.keys(this.defines).length > 0 && (e.defines = this.defines),
          (e.vertexShader = this.vertexShader),
          (e.fragmentShader = this.fragmentShader);
        const n = {};
        for (const t in this.extensions)
          !0 === this.extensions[t] && (n[t] = !0);
        return Object.keys(n).length > 0 && (e.extensions = n), e;
      }
    }
    kr.prototype.isShaderMaterial = !0;
    class Ir extends Ei {
      constructor() {
        super(),
          (this.type = "Camera"),
          (this.matrixWorldInverse = new ei()),
          (this.projectionMatrix = new ei()),
          (this.projectionMatrixInverse = new ei());
      }
      copy(t, e) {
        return (
          super.copy(t, e),
          this.matrixWorldInverse.copy(t.matrixWorldInverse),
          this.projectionMatrix.copy(t.projectionMatrix),
          this.projectionMatrixInverse.copy(t.projectionMatrixInverse),
          this
        );
      }
      getWorldDirection(t) {
        this.updateWorldMatrix(!0, !1);
        const e = this.matrixWorld.elements;
        return t.set(-e[8], -e[9], -e[10]).normalize();
      }
      updateMatrixWorld(t) {
        super.updateMatrixWorld(t),
          this.matrixWorldInverse.copy(this.matrixWorld).invert();
      }
      updateWorldMatrix(t, e) {
        super.updateWorldMatrix(t, e),
          this.matrixWorldInverse.copy(this.matrixWorld).invert();
      }
      clone() {
        return new this.constructor().copy(this);
      }
    }
    Ir.prototype.isCamera = !0;
    class Nr extends Ir {
      constructor(t = 50, e = 1, n = 0.1, i = 2e3) {
        super(),
          (this.type = "PerspectiveCamera"),
          (this.fov = t),
          (this.zoom = 1),
          (this.near = n),
          (this.far = i),
          (this.focus = 10),
          (this.aspect = e),
          (this.view = null),
          (this.filmGauge = 35),
          (this.filmOffset = 0),
          this.updateProjectionMatrix();
      }
      copy(t, e) {
        return (
          super.copy(t, e),
          (this.fov = t.fov),
          (this.zoom = t.zoom),
          (this.near = t.near),
          (this.far = t.far),
          (this.focus = t.focus),
          (this.aspect = t.aspect),
          (this.view = null === t.view ? null : Object.assign({}, t.view)),
          (this.filmGauge = t.filmGauge),
          (this.filmOffset = t.filmOffset),
          this
        );
      }
      setFocalLength(t) {
        const e = (0.5 * this.getFilmHeight()) / t;
        (this.fov = 2 * rn * Math.atan(e)), this.updateProjectionMatrix();
      }
      getFocalLength() {
        const t = Math.tan(0.5 * nn * this.fov);
        return (0.5 * this.getFilmHeight()) / t;
      }
      getEffectiveFOV() {
        return 2 * rn * Math.atan(Math.tan(0.5 * nn * this.fov) / this.zoom);
      }
      getFilmWidth() {
        return this.filmGauge * Math.min(this.aspect, 1);
      }
      getFilmHeight() {
        return this.filmGauge / Math.max(this.aspect, 1);
      }
      setViewOffset(t, e, n, i, r, s) {
        (this.aspect = t / e),
          null === this.view &&
            (this.view = {
              enabled: !0,
              fullWidth: 1,
              fullHeight: 1,
              offsetX: 0,
              offsetY: 0,
              width: 1,
              height: 1,
            }),
          (this.view.enabled = !0),
          (this.view.fullWidth = t),
          (this.view.fullHeight = e),
          (this.view.offsetX = n),
          (this.view.offsetY = i),
          (this.view.width = r),
          (this.view.height = s),
          this.updateProjectionMatrix();
      }
      clearViewOffset() {
        null !== this.view && (this.view.enabled = !1),
          this.updateProjectionMatrix();
      }
      updateProjectionMatrix() {
        const t = this.near;
        let e = (t * Math.tan(0.5 * nn * this.fov)) / this.zoom,
          n = 2 * e,
          i = this.aspect * n,
          r = -0.5 * i;
        const s = this.view;
        if (null !== this.view && this.view.enabled) {
          const t = s.fullWidth,
            o = s.fullHeight;
          (r += (s.offsetX * i) / t),
            (e -= (s.offsetY * n) / o),
            (i *= s.width / t),
            (n *= s.height / o);
        }
        const o = this.filmOffset;
        0 !== o && (r += (t * o) / this.getFilmWidth()),
          this.projectionMatrix.makePerspective(
            r,
            r + i,
            e,
            e - n,
            t,
            this.far
          ),
          this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
      }
      toJSON(t) {
        const e = super.toJSON(t);
        return (
          (e.object.fov = this.fov),
          (e.object.zoom = this.zoom),
          (e.object.near = this.near),
          (e.object.far = this.far),
          (e.object.focus = this.focus),
          (e.object.aspect = this.aspect),
          null !== this.view && (e.object.view = Object.assign({}, this.view)),
          (e.object.filmGauge = this.filmGauge),
          (e.object.filmOffset = this.filmOffset),
          e
        );
      }
    }
    Nr.prototype.isPerspectiveCamera = !0;
    const Or = 90,
      zr = 1;
    class Hr extends Ei {
      constructor(t, e, n) {
        if (
          (super(),
          (this.type = "CubeCamera"),
          !0 !== n.isWebGLCubeRenderTarget)
        )
          return void console.error(
            "THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter."
          );
        this.renderTarget = n;
        const i = new Nr(Or, zr, t, e);
        (i.layers = this.layers),
          i.up.set(0, -1, 0),
          i.lookAt(new Mn(1, 0, 0)),
          this.add(i);
        const r = new Nr(Or, zr, t, e);
        (r.layers = this.layers),
          r.up.set(0, -1, 0),
          r.lookAt(new Mn(-1, 0, 0)),
          this.add(r);
        const s = new Nr(Or, zr, t, e);
        (s.layers = this.layers),
          s.up.set(0, 0, 1),
          s.lookAt(new Mn(0, 1, 0)),
          this.add(s);
        const o = new Nr(Or, zr, t, e);
        (o.layers = this.layers),
          o.up.set(0, 0, -1),
          o.lookAt(new Mn(0, -1, 0)),
          this.add(o);
        const a = new Nr(Or, zr, t, e);
        (a.layers = this.layers),
          a.up.set(0, -1, 0),
          a.lookAt(new Mn(0, 0, 1)),
          this.add(a);
        const l = new Nr(Or, zr, t, e);
        (l.layers = this.layers),
          l.up.set(0, -1, 0),
          l.lookAt(new Mn(0, 0, -1)),
          this.add(l);
      }
      update(t, e) {
        null === this.parent && this.updateMatrixWorld();
        const n = this.renderTarget,
          [i, r, s, o, a, l] = this.children,
          c = t.xr.enabled,
          u = t.getRenderTarget();
        t.xr.enabled = !1;
        const h = n.texture.generateMipmaps;
        (n.texture.generateMipmaps = !1),
          t.setRenderTarget(n, 0),
          t.render(e, i),
          t.setRenderTarget(n, 1),
          t.render(e, r),
          t.setRenderTarget(n, 2),
          t.render(e, s),
          t.setRenderTarget(n, 3),
          t.render(e, o),
          t.setRenderTarget(n, 4),
          t.render(e, a),
          (n.texture.generateMipmaps = h),
          t.setRenderTarget(n, 5),
          t.render(e, l),
          t.setRenderTarget(u),
          (t.xr.enabled = c);
      }
    }
    class Br extends yn {
      constructor(t, e, n, i, r, s, o, a, l, c) {
        super(
          (t = void 0 !== t ? t : []),
          (e = void 0 !== e ? e : ot),
          n,
          i,
          r,
          s,
          o,
          a,
          l,
          c
        ),
          (this.flipY = !1);
      }
      get images() {
        return this.image;
      }
      set images(t) {
        this.image = t;
      }
    }
    Br.prototype.isCubeTexture = !0;
    class Ur extends _n {
      constructor(t, e, n) {
        Number.isInteger(e) &&
          (console.warn(
            "THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"
          ),
          (e = n)),
          super(t, t, e),
          (e = e || {}),
          (this.texture = new Br(
            void 0,
            e.mapping,
            e.wrapS,
            e.wrapT,
            e.magFilter,
            e.minFilter,
            e.format,
            e.type,
            e.anisotropy,
            e.encoding
          )),
          (this.texture.isRenderTargetTexture = !0),
          (this.texture.generateMipmaps =
            void 0 !== e.generateMipmaps && e.generateMipmaps),
          (this.texture.minFilter = void 0 !== e.minFilter ? e.minFilter : yt),
          (this.texture._needsFlipEnvMap = !1);
      }
      fromEquirectangularTexture(t, e) {
        (this.texture.type = e.type),
          (this.texture.format = Nt),
          (this.texture.encoding = e.encoding),
          (this.texture.generateMipmaps = e.generateMipmaps),
          (this.texture.minFilter = e.minFilter),
          (this.texture.magFilter = e.magFilter);
        const n = {
            uniforms: { tEquirect: { value: null } },
            vertexShader:
              "\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",
            fragmentShader:
              "\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t",
          },
          i = new Ar(5, 5, 5),
          r = new kr({
            name: "CubemapFromEquirect",
            uniforms: Cr(n.uniforms),
            vertexShader: n.vertexShader,
            fragmentShader: n.fragmentShader,
            side: g,
            blending: x,
          });
        r.uniforms.tEquirect.value = e;
        const s = new Tr(i, r),
          o = e.minFilter;
        return (
          e.minFilter === bt && (e.minFilter = yt),
          new Hr(1, 10, this).update(t, s),
          (e.minFilter = o),
          s.geometry.dispose(),
          s.material.dispose(),
          this
        );
      }
      clear(t, e, n, i) {
        const r = t.getRenderTarget();
        for (let r = 0; r < 6; r++)
          t.setRenderTarget(this, r), t.clear(e, n, i);
        t.setRenderTarget(r);
      }
    }
    Ur.prototype.isWebGLCubeRenderTarget = !0;
    const Fr = new Mn(),
      Vr = new Mn(),
      Wr = new dn();
    class Gr {
      constructor(t = new Mn(1, 0, 0), e = 0) {
        (this.normal = t), (this.constant = e);
      }
      set(t, e) {
        return this.normal.copy(t), (this.constant = e), this;
      }
      setComponents(t, e, n, i) {
        return this.normal.set(t, e, n), (this.constant = i), this;
      }
      setFromNormalAndCoplanarPoint(t, e) {
        return this.normal.copy(t), (this.constant = -e.dot(this.normal)), this;
      }
      setFromCoplanarPoints(t, e, n) {
        const i = Fr.subVectors(n, e).cross(Vr.subVectors(t, e)).normalize();
        return this.setFromNormalAndCoplanarPoint(i, t), this;
      }
      copy(t) {
        return this.normal.copy(t.normal), (this.constant = t.constant), this;
      }
      normalize() {
        const t = 1 / this.normal.length();
        return this.normal.multiplyScalar(t), (this.constant *= t), this;
      }
      negate() {
        return (this.constant *= -1), this.normal.negate(), this;
      }
      distanceToPoint(t) {
        return this.normal.dot(t) + this.constant;
      }
      distanceToSphere(t) {
        return this.distanceToPoint(t.center) - t.radius;
      }
      projectPoint(t, e) {
        return e
          .copy(this.normal)
          .multiplyScalar(-this.distanceToPoint(t))
          .add(t);
      }
      intersectLine(t, e) {
        const n = t.delta(Fr),
          i = this.normal.dot(n);
        if (0 === i)
          return 0 === this.distanceToPoint(t.start) ? e.copy(t.start) : null;
        const r = -(t.start.dot(this.normal) + this.constant) / i;
        return r < 0 || r > 1 ? null : e.copy(n).multiplyScalar(r).add(t.start);
      }
      intersectsLine(t) {
        const e = this.distanceToPoint(t.start),
          n = this.distanceToPoint(t.end);
        return (e < 0 && n > 0) || (n < 0 && e > 0);
      }
      intersectsBox(t) {
        return t.intersectsPlane(this);
      }
      intersectsSphere(t) {
        return t.intersectsPlane(this);
      }
      coplanarPoint(t) {
        return t.copy(this.normal).multiplyScalar(-this.constant);
      }
      applyMatrix4(t, e) {
        const n = e || Wr.getNormalMatrix(t),
          i = this.coplanarPoint(Fr).applyMatrix4(t),
          r = this.normal.applyMatrix3(n).normalize();
        return (this.constant = -i.dot(r)), this;
      }
      translate(t) {
        return (this.constant -= t.dot(this.normal)), this;
      }
      equals(t) {
        return t.normal.equals(this.normal) && t.constant === this.constant;
      }
      clone() {
        return new this.constructor().copy(this);
      }
    }
    Gr.prototype.isPlane = !0;
    const jr = new qn(),
      qr = new Mn();
    class $r {
      constructor(
        t = new Gr(),
        e = new Gr(),
        n = new Gr(),
        i = new Gr(),
        r = new Gr(),
        s = new Gr()
      ) {
        this.planes = [t, e, n, i, r, s];
      }
      set(t, e, n, i, r, s) {
        const o = this.planes;
        return (
          o[0].copy(t),
          o[1].copy(e),
          o[2].copy(n),
          o[3].copy(i),
          o[4].copy(r),
          o[5].copy(s),
          this
        );
      }
      copy(t) {
        const e = this.planes;
        for (let n = 0; n < 6; n++) e[n].copy(t.planes[n]);
        return this;
      }
      setFromProjectionMatrix(t) {
        const e = this.planes,
          n = t.elements,
          i = n[0],
          r = n[1],
          s = n[2],
          o = n[3],
          a = n[4],
          l = n[5],
          c = n[6],
          u = n[7],
          h = n[8],
          d = n[9],
          p = n[10],
          f = n[11],
          m = n[12],
          g = n[13],
          v = n[14],
          y = n[15];
        return (
          e[0].setComponents(o - i, u - a, f - h, y - m).normalize(),
          e[1].setComponents(o + i, u + a, f + h, y + m).normalize(),
          e[2].setComponents(o + r, u + l, f + d, y + g).normalize(),
          e[3].setComponents(o - r, u - l, f - d, y - g).normalize(),
          e[4].setComponents(o - s, u - c, f - p, y - v).normalize(),
          e[5].setComponents(o + s, u + c, f + p, y + v).normalize(),
          this
        );
      }
      intersectsObject(t) {
        const e = t.geometry;
        return (
          null === e.boundingSphere && e.computeBoundingSphere(),
          jr.copy(e.boundingSphere).applyMatrix4(t.matrixWorld),
          this.intersectsSphere(jr)
        );
      }
      intersectsSprite(t) {
        return (
          jr.center.set(0, 0, 0),
          (jr.radius = 0.7071067811865476),
          jr.applyMatrix4(t.matrixWorld),
          this.intersectsSphere(jr)
        );
      }
      intersectsSphere(t) {
        const e = this.planes,
          n = t.center,
          i = -t.radius;
        for (let t = 0; t < 6; t++) {
          if (e[t].distanceToPoint(n) < i) return !1;
        }
        return !0;
      }
      intersectsBox(t) {
        const e = this.planes;
        for (let n = 0; n < 6; n++) {
          const i = e[n];
          if (
            ((qr.x = i.normal.x > 0 ? t.max.x : t.min.x),
            (qr.y = i.normal.y > 0 ? t.max.y : t.min.y),
            (qr.z = i.normal.z > 0 ? t.max.z : t.min.z),
            i.distanceToPoint(qr) < 0)
          )
            return !1;
        }
        return !0;
      }
      containsPoint(t) {
        const e = this.planes;
        for (let n = 0; n < 6; n++) if (e[n].distanceToPoint(t) < 0) return !1;
        return !0;
      }
      clone() {
        return new this.constructor().copy(this);
      }
    }
    function Xr() {
      let t = null,
        e = !1,
        n = null,
        i = null;
      function r(e, s) {
        n(e, s), (i = t.requestAnimationFrame(r));
      }
      return {
        start: function () {
          !0 !== e &&
            null !== n &&
            ((i = t.requestAnimationFrame(r)), (e = !0));
        },
        stop: function () {
          t.cancelAnimationFrame(i), (e = !1);
        },
        setAnimationLoop: function (t) {
          n = t;
        },
        setContext: function (e) {
          t = e;
        },
      };
    }
    function Jr(t, e) {
      const n = e.isWebGL2,
        i = new WeakMap();
      return {
        get: function (t) {
          return t.isInterleavedBufferAttribute && (t = t.data), i.get(t);
        },
        remove: function (e) {
          e.isInterleavedBufferAttribute && (e = e.data);
          const n = i.get(e);
          n && (t.deleteBuffer(n.buffer), i.delete(e));
        },
        update: function (e, r) {
          if (e.isGLBufferAttribute) {
            const t = i.get(e);
            return void (
              (!t || t.version < e.version) &&
              i.set(e, {
                buffer: e.buffer,
                type: e.type,
                bytesPerElement: e.elementSize,
                version: e.version,
              })
            );
          }
          e.isInterleavedBufferAttribute && (e = e.data);
          const s = i.get(e);
          void 0 === s
            ? i.set(
                e,
                (function (e, i) {
                  const r = e.array,
                    s = e.usage,
                    o = t.createBuffer();
                  t.bindBuffer(i, o),
                    t.bufferData(i, r, s),
                    e.onUploadCallback();
                  let a = 5126;
                  return (
                    r instanceof Float32Array
                      ? (a = 5126)
                      : r instanceof Float64Array
                      ? console.warn(
                          "THREE.WebGLAttributes: Unsupported data buffer format: Float64Array."
                        )
                      : r instanceof Uint16Array
                      ? e.isFloat16BufferAttribute
                        ? n
                          ? (a = 5131)
                          : console.warn(
                              "THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2."
                            )
                        : (a = 5123)
                      : r instanceof Int16Array
                      ? (a = 5122)
                      : r instanceof Uint32Array
                      ? (a = 5125)
                      : r instanceof Int32Array
                      ? (a = 5124)
                      : r instanceof Int8Array
                      ? (a = 5120)
                      : r instanceof Uint8Array
                      ? (a = 5121)
                      : r instanceof Uint8ClampedArray && (a = 5121),
                    {
                      buffer: o,
                      type: a,
                      bytesPerElement: r.BYTES_PER_ELEMENT,
                      version: e.version,
                    }
                  );
                })(e, r)
              )
            : s.version < e.version &&
              (!(function (e, i, r) {
                const s = i.array,
                  o = i.updateRange;
                t.bindBuffer(r, e),
                  -1 === o.count
                    ? t.bufferSubData(r, 0, s)
                    : (n
                        ? t.bufferSubData(
                            r,
                            o.offset * s.BYTES_PER_ELEMENT,
                            s,
                            o.offset,
                            o.count
                          )
                        : t.bufferSubData(
                            r,
                            o.offset * s.BYTES_PER_ELEMENT,
                            s.subarray(o.offset, o.offset + o.count)
                          ),
                      (o.count = -1));
              })(s.buffer, e, r),
              (s.version = e.version));
        },
      };
    }
    class Yr extends ar {
      constructor(t = 1, e = 1, n = 1, i = 1) {
        super(),
          (this.type = "PlaneGeometry"),
          (this.parameters = {
            width: t,
            height: e,
            widthSegments: n,
            heightSegments: i,
          });
        const r = t / 2,
          s = e / 2,
          o = Math.floor(n),
          a = Math.floor(i),
          l = o + 1,
          c = a + 1,
          u = t / o,
          h = e / a,
          d = [],
          p = [],
          f = [],
          m = [];
        for (let t = 0; t < c; t++) {
          const e = t * h - s;
          for (let n = 0; n < l; n++) {
            const i = n * u - r;
            p.push(i, -e, 0), f.push(0, 0, 1), m.push(n / o), m.push(1 - t / a);
          }
        }
        for (let t = 0; t < a; t++)
          for (let e = 0; e < o; e++) {
            const n = e + l * t,
              i = e + l * (t + 1),
              r = e + 1 + l * (t + 1),
              s = e + 1 + l * t;
            d.push(n, i, s), d.push(i, r, s);
          }
        this.setIndex(d),
          this.setAttribute("position", new Ki(p, 3)),
          this.setAttribute("normal", new Ki(f, 3)),
          this.setAttribute("uv", new Ki(m, 2));
      }
      static fromJSON(t) {
        return new Yr(t.width, t.height, t.widthSegments, t.heightSegments);
      }
    }
    const Zr = {
        alphamap_fragment:
          "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",
        alphamap_pars_fragment:
          "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
        alphatest_fragment:
          "#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif",
        alphatest_pars_fragment:
          "#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif",
        aomap_fragment:
          "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif",
        aomap_pars_fragment:
          "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
        begin_vertex: "vec3 transformed = vec3( position );",
        beginnormal_vertex:
          "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
        bsdfs:
          "vec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif",
        bumpmap_pars_fragment:
          "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
        clipping_planes_fragment:
          "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
        clipping_planes_pars_fragment:
          "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
        clipping_planes_pars_vertex:
          "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",
        clipping_planes_vertex:
          "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",
        color_fragment:
          "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif",
        color_pars_fragment:
          "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif",
        color_pars_vertex:
          "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif",
        color_vertex:
          "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif",
        common:
          "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}",
        cube_uv_reflection_fragment:
          "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_maxMipLevel 8.0\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_maxTileSize 256.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tfloat texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 ) + 0.5;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tif ( mipInt < cubeUV_maxMipLevel ) {\n\t\t\tuv.y += 2.0 * cubeUV_maxTileSize;\n\t\t}\n\t\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\n\t\tuv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n\t\tuv *= texelSize;\n\t\treturn texture2D( envMap, uv ).rgb;\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",
        defaultnormal_vertex:
          "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
        displacementmap_pars_vertex:
          "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
        displacementmap_vertex:
          "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif",
        emissivemap_fragment:
          "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
        emissivemap_pars_fragment:
          "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
        encodings_fragment:
          "gl_FragColor = linearToOutputTexel( gl_FragColor );",
        encodings_pars_fragment:
          "vec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}",
        envmap_fragment:
          "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
        envmap_common_pars_fragment:
          "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",
        envmap_pars_fragment:
          "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
        envmap_pars_vertex:
          "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
        envmap_physical_pars_fragment:
          "#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 reflectVec;\n\t\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\t\treflectVec = reflect( - viewDir, normal );\n\t\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\t#else\n\t\t\t\treflectVec = refract( - viewDir, normal, refractionRatio );\n\t\t\t#endif\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n#endif",
        envmap_vertex:
          "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
        fog_vertex: "#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif",
        fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif",
        fog_fragment:
          "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
        fog_pars_fragment:
          "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
        gradientmap_pars_fragment:
          "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}",
        lightmap_fragment:
          "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tlightMapIrradiance *= PI;\n\t#endif\n\treflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif",
        lightmap_pars_fragment:
          "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
        lights_lambert_vertex:
          "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointLightInfo( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotLightInfo( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalLightInfo( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif",
        lights_pars_begin:
          "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#else\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif",
        lights_toon_fragment:
          "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",
        lights_toon_pars_fragment:
          "varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)",
        lights_phong_fragment:
          "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
        lights_phong_pars_fragment:
          "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",
        lights_physical_fragment:
          "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\t#ifdef SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULARINTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n\t\t#endif\n\t\t#ifdef USE_SPECULARCOLORMAP\n\t\t\tspecularColorFactor *= specularColorMapTexelToLinear( texture2D( specularColorMap, vUv ) ).rgb;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tmaterial.sheenColor *= sheenColorMapTexelToLinear( texture2D( sheenColorMap, vUv ) ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;\n\t#endif\n#endif",
        lights_physical_pars_fragment:
          "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec3 sheenSpecular = vec3( 0.0 );\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\tvec3 FssEss = specularColor * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tcomputeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
        lights_fragment_begin:
          "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
        lights_fragment_maps:
          "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometry.normal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif",
        lights_fragment_end:
          "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",
        logdepthbuf_fragment:
          "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
        logdepthbuf_pars_fragment:
          "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
        logdepthbuf_pars_vertex:
          "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
        logdepthbuf_vertex:
          "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",
        map_fragment:
          "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif",
        map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
        map_particle_fragment:
          "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",
        map_particle_pars_fragment:
          "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
        metalnessmap_fragment:
          "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
        metalnessmap_pars_fragment:
          "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
        morphnormal_vertex:
          "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] > 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1, 2 ) * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif",
        morphtarget_pars_vertex:
          "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform vec2 morphTargetsTextureSize;\n\t\tvec3 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset, const in int stride ) {\n\t\t\tfloat texelIndex = float( vertexIndex * stride + offset );\n\t\t\tfloat y = floor( texelIndex / morphTargetsTextureSize.x );\n\t\t\tfloat x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tvec3 morphUV = vec3( ( x + 0.5 ) / morphTargetsTextureSize.x, y / morphTargetsTextureSize.y, morphTargetIndex );\n\t\t\treturn texture( morphTargetsTexture, morphUV ).xyz;\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif",
        morphtarget_vertex:
          "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\t#ifndef USE_MORPHNORMALS\n\t\t\t\tif ( morphTargetInfluences[ i ] > 0.0 ) transformed += getMorph( gl_VertexID, i, 0, 1 ) * morphTargetInfluences[ i ];\n\t\t\t#else\n\t\t\t\tif ( morphTargetInfluences[ i ] > 0.0 ) transformed += getMorph( gl_VertexID, i, 0, 2 ) * morphTargetInfluences[ i ];\n\t\t\t#endif\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif",
        normal_fragment_begin:
          "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;",
        normal_fragment_maps:
          "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",
        normal_pars_fragment:
          "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
        normal_pars_vertex:
          "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
        normal_vertex:
          "#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif",
        normalmap_pars_fragment:
          "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif",
        clearcoat_normal_fragment_begin:
          "#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif",
        clearcoat_normal_fragment_maps:
          "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif",
        clearcoat_pars_fragment:
          "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif",
        output_fragment:
          "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );",
        packing:
          "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",
        premultiplied_alpha_fragment:
          "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
        project_vertex:
          "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
        dithering_fragment:
          "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
        dithering_pars_fragment:
          "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
        roughnessmap_fragment:
          "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
        roughnessmap_pars_fragment:
          "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
        shadowmap_pars_fragment:
          "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
        shadowmap_pars_vertex:
          "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",
        shadowmap_vertex:
          "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif",
        shadowmask_pars_fragment:
          "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",
        skinbase_vertex:
          "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
        skinning_pars_vertex:
          "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif",
        skinning_vertex:
          "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
        skinnormal_vertex:
          "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
        specularmap_fragment:
          "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
        specularmap_pars_fragment:
          "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
        tonemapping_fragment:
          "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
        tonemapping_pars_fragment:
          "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",
        transmission_fragment:
          "#ifdef USE_TRANSMISSION\n\tfloat transmissionAlpha = 1.0;\n\tfloat transmissionFactor = transmission;\n\tfloat thicknessFactor = thickness;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\ttransmissionFactor *= texture2D( transmissionMap, vUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tthicknessFactor *= texture2D( thicknessMap, vUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmission = getIBLVolumeRefraction(\n\t\tn, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n\t\tattenuationColor, attenuationDistance );\n\ttotalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );\n\ttransmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );\n#endif",
        transmission_pars_fragment:
          "#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tvec3 getVolumeTransmissionRay( vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( float roughness, float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( vec2 fragCoord, float roughness, float ior ) {\n\t\tfloat framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\treturn texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#else\n\t\t\treturn texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#endif\n\t}\n\tvec3 applyVolumeAttenuation( vec3 radiance, float transmissionDistance, vec3 attenuationColor, float attenuationDistance ) {\n\t\tif ( attenuationDistance == 0.0 ) {\n\t\t\treturn radiance;\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance * radiance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( vec3 n, vec3 v, float roughness, vec3 diffuseColor, vec3 specularColor, float specularF90,\n\t\tvec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness,\n\t\tvec3 attenuationColor, float attenuationDistance ) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\tvec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n\t}\n#endif",
        uv_pars_fragment:
          "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif",
        uv_pars_vertex:
          "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif",
        uv_vertex:
          "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
        uv2_pars_fragment:
          "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
        uv2_pars_vertex:
          "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif",
        uv2_vertex:
          "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif",
        worldpos_vertex:
          "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",
        background_vert:
          "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
        background_frag:
          "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
        cube_vert:
          "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
        cube_frag:
          "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
        depth_vert:
          "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",
        depth_frag:
          "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",
        distanceRGBA_vert:
          "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
        distanceRGBA_frag:
          "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
        equirect_vert:
          "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
        equirect_frag:
          "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
        linedashed_vert:
          "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
        linedashed_frag:
          "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
        meshbasic_vert:
          "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
        meshbasic_frag:
          "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        meshlambert_vert:
          "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
        meshlambert_frag:
          "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        meshmatcap_vert:
          "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
        meshmatcap_frag:
          "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        meshnormal_vert:
          "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
        meshnormal_frag:
          "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}",
        meshphong_vert:
          "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
        meshphong_frag:
          "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        meshphysical_vert:
          "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}",
        meshphysical_frag:
          "#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULARINTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n\t#ifdef USE_SPECULARCOLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;\n\t#endif\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        meshtoon_vert:
          "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
        meshtoon_frag:
          "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        points_vert:
          "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
        points_frag:
          "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
        shadow_vert:
          "#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
        shadow_frag:
          "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
        sprite_vert:
          "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
        sprite_frag:
          "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
      },
      Qr = {
        common: {
          diffuse: { value: new qi(16777215) },
          opacity: { value: 1 },
          map: { value: null },
          uvTransform: { value: new dn() },
          uv2Transform: { value: new dn() },
          alphaMap: { value: null },
          alphaTest: { value: 0 },
        },
        specularmap: { specularMap: { value: null } },
        envmap: {
          envMap: { value: null },
          flipEnvMap: { value: -1 },
          reflectivity: { value: 1 },
          ior: { value: 1.5 },
          refractionRatio: { value: 0.98 },
        },
        aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 } },
        lightmap: {
          lightMap: { value: null },
          lightMapIntensity: { value: 1 },
        },
        emissivemap: { emissiveMap: { value: null } },
        bumpmap: { bumpMap: { value: null }, bumpScale: { value: 1 } },
        normalmap: {
          normalMap: { value: null },
          normalScale: { value: new hn(1, 1) },
        },
        displacementmap: {
          displacementMap: { value: null },
          displacementScale: { value: 1 },
          displacementBias: { value: 0 },
        },
        roughnessmap: { roughnessMap: { value: null } },
        metalnessmap: { metalnessMap: { value: null } },
        gradientmap: { gradientMap: { value: null } },
        fog: {
          fogDensity: { value: 25e-5 },
          fogNear: { value: 1 },
          fogFar: { value: 2e3 },
          fogColor: { value: new qi(16777215) },
        },
        lights: {
          ambientLightColor: { value: [] },
          lightProbe: { value: [] },
          directionalLights: {
            value: [],
            properties: { direction: {}, color: {} },
          },
          directionalLightShadows: {
            value: [],
            properties: {
              shadowBias: {},
              shadowNormalBias: {},
              shadowRadius: {},
              shadowMapSize: {},
            },
          },
          directionalShadowMap: { value: [] },
          directionalShadowMatrix: { value: [] },
          spotLights: {
            value: [],
            properties: {
              color: {},
              position: {},
              direction: {},
              distance: {},
              coneCos: {},
              penumbraCos: {},
              decay: {},
            },
          },
          spotLightShadows: {
            value: [],
            properties: {
              shadowBias: {},
              shadowNormalBias: {},
              shadowRadius: {},
              shadowMapSize: {},
            },
          },
          spotShadowMap: { value: [] },
          spotShadowMatrix: { value: [] },
          pointLights: {
            value: [],
            properties: { color: {}, position: {}, decay: {}, distance: {} },
          },
          pointLightShadows: {
            value: [],
            properties: {
              shadowBias: {},
              shadowNormalBias: {},
              shadowRadius: {},
              shadowMapSize: {},
              shadowCameraNear: {},
              shadowCameraFar: {},
            },
          },
          pointShadowMap: { value: [] },
          pointShadowMatrix: { value: [] },
          hemisphereLights: {
            value: [],
            properties: { direction: {}, skyColor: {}, groundColor: {} },
          },
          rectAreaLights: {
            value: [],
            properties: { color: {}, position: {}, width: {}, height: {} },
          },
          ltc_1: { value: null },
          ltc_2: { value: null },
        },
        points: {
          diffuse: { value: new qi(16777215) },
          opacity: { value: 1 },
          size: { value: 1 },
          scale: { value: 1 },
          map: { value: null },
          alphaMap: { value: null },
          alphaTest: { value: 0 },
          uvTransform: { value: new dn() },
        },
        sprite: {
          diffuse: { value: new qi(16777215) },
          opacity: { value: 1 },
          center: { value: new hn(0.5, 0.5) },
          rotation: { value: 0 },
          map: { value: null },
          alphaMap: { value: null },
          alphaTest: { value: 0 },
          uvTransform: { value: new dn() },
        },
      },
      Kr = {
        basic: {
          uniforms: Lr([
            Qr.common,
            Qr.specularmap,
            Qr.envmap,
            Qr.aomap,
            Qr.lightmap,
            Qr.fog,
          ]),
          vertexShader: Zr.meshbasic_vert,
          fragmentShader: Zr.meshbasic_frag,
        },
        lambert: {
          uniforms: Lr([
            Qr.common,
            Qr.specularmap,
            Qr.envmap,
            Qr.aomap,
            Qr.lightmap,
            Qr.emissivemap,
            Qr.fog,
            Qr.lights,
            { emissive: { value: new qi(0) } },
          ]),
          vertexShader: Zr.meshlambert_vert,
          fragmentShader: Zr.meshlambert_frag,
        },
        phong: {
          uniforms: Lr([
            Qr.common,
            Qr.specularmap,
            Qr.envmap,
            Qr.aomap,
            Qr.lightmap,
            Qr.emissivemap,
            Qr.bumpmap,
            Qr.normalmap,
            Qr.displacementmap,
            Qr.fog,
            Qr.lights,
            {
              emissive: { value: new qi(0) },
              specular: { value: new qi(1118481) },
              shininess: { value: 30 },
            },
          ]),
          vertexShader: Zr.meshphong_vert,
          fragmentShader: Zr.meshphong_frag,
        },
        standard: {
          uniforms: Lr([
            Qr.common,
            Qr.envmap,
            Qr.aomap,
            Qr.lightmap,
            Qr.emissivemap,
            Qr.bumpmap,
            Qr.normalmap,
            Qr.displacementmap,
            Qr.roughnessmap,
            Qr.metalnessmap,
            Qr.fog,
            Qr.lights,
            {
              emissive: { value: new qi(0) },
              roughness: { value: 1 },
              metalness: { value: 0 },
              envMapIntensity: { value: 1 },
            },
          ]),
          vertexShader: Zr.meshphysical_vert,
          fragmentShader: Zr.meshphysical_frag,
        },
        toon: {
          uniforms: Lr([
            Qr.common,
            Qr.aomap,
            Qr.lightmap,
            Qr.emissivemap,
            Qr.bumpmap,
            Qr.normalmap,
            Qr.displacementmap,
            Qr.gradientmap,
            Qr.fog,
            Qr.lights,
            { emissive: { value: new qi(0) } },
          ]),
          vertexShader: Zr.meshtoon_vert,
          fragmentShader: Zr.meshtoon_frag,
        },
        matcap: {
          uniforms: Lr([
            Qr.common,
            Qr.bumpmap,
            Qr.normalmap,
            Qr.displacementmap,
            Qr.fog,
            { matcap: { value: null } },
          ]),
          vertexShader: Zr.meshmatcap_vert,
          fragmentShader: Zr.meshmatcap_frag,
        },
        points: {
          uniforms: Lr([Qr.points, Qr.fog]),
          vertexShader: Zr.points_vert,
          fragmentShader: Zr.points_frag,
        },
        dashed: {
          uniforms: Lr([
            Qr.common,
            Qr.fog,
            {
              scale: { value: 1 },
              dashSize: { value: 1 },
              totalSize: { value: 2 },
            },
          ]),
          vertexShader: Zr.linedashed_vert,
          fragmentShader: Zr.linedashed_frag,
        },
        depth: {
          uniforms: Lr([Qr.common, Qr.displacementmap]),
          vertexShader: Zr.depth_vert,
          fragmentShader: Zr.depth_frag,
        },
        normal: {
          uniforms: Lr([
            Qr.common,
            Qr.bumpmap,
            Qr.normalmap,
            Qr.displacementmap,
            { opacity: { value: 1 } },
          ]),
          vertexShader: Zr.meshnormal_vert,
          fragmentShader: Zr.meshnormal_frag,
        },
        sprite: {
          uniforms: Lr([Qr.sprite, Qr.fog]),
          vertexShader: Zr.sprite_vert,
          fragmentShader: Zr.sprite_frag,
        },
        background: {
          uniforms: { uvTransform: { value: new dn() }, t2D: { value: null } },
          vertexShader: Zr.background_vert,
          fragmentShader: Zr.background_frag,
        },
        cube: {
          uniforms: Lr([Qr.envmap, { opacity: { value: 1 } }]),
          vertexShader: Zr.cube_vert,
          fragmentShader: Zr.cube_frag,
        },
        equirect: {
          uniforms: { tEquirect: { value: null } },
          vertexShader: Zr.equirect_vert,
          fragmentShader: Zr.equirect_frag,
        },
        distanceRGBA: {
          uniforms: Lr([
            Qr.common,
            Qr.displacementmap,
            {
              referencePosition: { value: new Mn() },
              nearDistance: { value: 1 },
              farDistance: { value: 1e3 },
            },
          ]),
          vertexShader: Zr.distanceRGBA_vert,
          fragmentShader: Zr.distanceRGBA_frag,
        },
        shadow: {
          uniforms: Lr([
            Qr.lights,
            Qr.fog,
            { color: { value: new qi(0) }, opacity: { value: 1 } },
          ]),
          vertexShader: Zr.shadow_vert,
          fragmentShader: Zr.shadow_frag,
        },
      };
    function ts(t, e, n, i, r) {
      const s = new qi(0);
      let o,
        a,
        l = 0,
        c = null,
        u = 0,
        h = null;
      function d(t, e) {
        n.buffers.color.setClear(t.r, t.g, t.b, e, r);
      }
      return {
        getClearColor: function () {
          return s;
        },
        setClearColor: function (t, e = 1) {
          s.set(t), (l = e), d(s, l);
        },
        getClearAlpha: function () {
          return l;
        },
        setClearAlpha: function (t) {
          (l = t), d(s, l);
        },
        render: function (n, r) {
          let p = !1,
            f = !0 === r.isScene ? r.background : null;
          f && f.isTexture && (f = e.get(f));
          const v = t.xr,
            y = v.getSession && v.getSession();
          y && "additive" === y.environmentBlendMode && (f = null),
            null === f ? d(s, l) : f && f.isColor && (d(f, 1), (p = !0)),
            (t.autoClear || p) &&
              t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil),
            f && (f.isCubeTexture || f.mapping === ut)
              ? (void 0 === a &&
                  ((a = new Tr(
                    new Ar(1, 1, 1),
                    new kr({
                      name: "BackgroundCubeMaterial",
                      uniforms: Cr(Kr.cube.uniforms),
                      vertexShader: Kr.cube.vertexShader,
                      fragmentShader: Kr.cube.fragmentShader,
                      side: g,
                      depthTest: !1,
                      depthWrite: !1,
                      fog: !1,
                    })
                  )),
                  a.geometry.deleteAttribute("normal"),
                  a.geometry.deleteAttribute("uv"),
                  (a.onBeforeRender = function (t, e, n) {
                    this.matrixWorld.copyPosition(n.matrixWorld);
                  }),
                  Object.defineProperty(a.material, "envMap", {
                    get: function () {
                      return this.uniforms.envMap.value;
                    },
                  }),
                  i.update(a)),
                (a.material.uniforms.envMap.value = f),
                (a.material.uniforms.flipEnvMap.value =
                  f.isCubeTexture && !1 === f.isRenderTargetTexture ? -1 : 1),
                (c === f && u === f.version && h === t.toneMapping) ||
                  ((a.material.needsUpdate = !0),
                  (c = f),
                  (u = f.version),
                  (h = t.toneMapping)),
                n.unshift(a, a.geometry, a.material, 0, 0, null))
              : f &&
                f.isTexture &&
                (void 0 === o &&
                  ((o = new Tr(
                    new Yr(2, 2),
                    new kr({
                      name: "BackgroundMaterial",
                      uniforms: Cr(Kr.background.uniforms),
                      vertexShader: Kr.background.vertexShader,
                      fragmentShader: Kr.background.fragmentShader,
                      side: m,
                      depthTest: !1,
                      depthWrite: !1,
                      fog: !1,
                    })
                  )),
                  o.geometry.deleteAttribute("normal"),
                  Object.defineProperty(o.material, "map", {
                    get: function () {
                      return this.uniforms.t2D.value;
                    },
                  }),
                  i.update(o)),
                (o.material.uniforms.t2D.value = f),
                !0 === f.matrixAutoUpdate && f.updateMatrix(),
                o.material.uniforms.uvTransform.value.copy(f.matrix),
                (c === f && u === f.version && h === t.toneMapping) ||
                  ((o.material.needsUpdate = !0),
                  (c = f),
                  (u = f.version),
                  (h = t.toneMapping)),
                n.unshift(o, o.geometry, o.material, 0, 0, null));
        },
      };
    }
    function es(t, e, n, i) {
      const r = t.getParameter(34921),
        s = i.isWebGL2 ? null : e.get("OES_vertex_array_object"),
        o = i.isWebGL2 || null !== s,
        a = {},
        l = d(null);
      let c = l;
      function u(e) {
        return i.isWebGL2 ? t.bindVertexArray(e) : s.bindVertexArrayOES(e);
      }
      function h(e) {
        return i.isWebGL2 ? t.deleteVertexArray(e) : s.deleteVertexArrayOES(e);
      }
      function d(t) {
        const e = [],
          n = [],
          i = [];
        for (let t = 0; t < r; t++) (e[t] = 0), (n[t] = 0), (i[t] = 0);
        return {
          geometry: null,
          program: null,
          wireframe: !1,
          newAttributes: e,
          enabledAttributes: n,
          attributeDivisors: i,
          object: t,
          attributes: {},
          index: null,
        };
      }
      function p() {
        const t = c.newAttributes;
        for (let e = 0, n = t.length; e < n; e++) t[e] = 0;
      }
      function f(t) {
        m(t, 0);
      }
      function m(n, r) {
        const s = c.newAttributes,
          o = c.enabledAttributes,
          a = c.attributeDivisors;
        if (
          ((s[n] = 1),
          0 === o[n] && (t.enableVertexAttribArray(n), (o[n] = 1)),
          a[n] !== r)
        ) {
          (i.isWebGL2 ? t : e.get("ANGLE_instanced_arrays"))[
            i.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"
          ](n, r),
            (a[n] = r);
        }
      }
      function g() {
        const e = c.newAttributes,
          n = c.enabledAttributes;
        for (let i = 0, r = n.length; i < r; i++)
          n[i] !== e[i] && (t.disableVertexAttribArray(i), (n[i] = 0));
      }
      function v(e, n, r, s, o, a) {
        !0 !== i.isWebGL2 || (5124 !== r && 5125 !== r)
          ? t.vertexAttribPointer(e, n, r, s, o, a)
          : t.vertexAttribIPointer(e, n, r, o, a);
      }
      function y() {
        x(), c !== l && ((c = l), u(c.object));
      }
      function x() {
        (l.geometry = null), (l.program = null), (l.wireframe = !1);
      }
      return {
        setup: function (r, l, h, y, x) {
          let b = !1;
          if (o) {
            const e = (function (e, n, r) {
              const o = !0 === r.wireframe;
              let l = a[e.id];
              void 0 === l && ((l = {}), (a[e.id] = l));
              let c = l[n.id];
              void 0 === c && ((c = {}), (l[n.id] = c));
              let u = c[o];
              void 0 === u &&
                ((u = d(
                  i.isWebGL2 ? t.createVertexArray() : s.createVertexArrayOES()
                )),
                (c[o] = u));
              return u;
            })(y, h, l);
            c !== e && ((c = e), u(c.object)),
              (b = (function (t, e) {
                const n = c.attributes,
                  i = t.attributes;
                let r = 0;
                for (const t in i) {
                  const e = n[t],
                    s = i[t];
                  if (void 0 === e) return !0;
                  if (e.attribute !== s) return !0;
                  if (e.data !== s.data) return !0;
                  r++;
                }
                return c.attributesNum !== r || c.index !== e;
              })(y, x)),
              b &&
                (function (t, e) {
                  const n = {},
                    i = t.attributes;
                  let r = 0;
                  for (const t in i) {
                    const e = i[t],
                      s = {};
                    (s.attribute = e),
                      e.data && (s.data = e.data),
                      (n[t] = s),
                      r++;
                  }
                  (c.attributes = n), (c.attributesNum = r), (c.index = e);
                })(y, x);
          } else {
            const t = !0 === l.wireframe;
            (c.geometry === y.id && c.program === h.id && c.wireframe === t) ||
              ((c.geometry = y.id),
              (c.program = h.id),
              (c.wireframe = t),
              (b = !0));
          }
          !0 === r.isInstancedMesh && (b = !0),
            null !== x && n.update(x, 34963),
            b &&
              (!(function (r, s, o, a) {
                if (
                  !1 === i.isWebGL2 &&
                  (r.isInstancedMesh || a.isInstancedBufferGeometry) &&
                  null === e.get("ANGLE_instanced_arrays")
                )
                  return;
                p();
                const l = a.attributes,
                  c = o.getAttributes(),
                  u = s.defaultAttributeValues;
                for (const e in c) {
                  const i = c[e];
                  if (i.location >= 0) {
                    let s = l[e];
                    if (
                      (void 0 === s &&
                        ("instanceMatrix" === e &&
                          r.instanceMatrix &&
                          (s = r.instanceMatrix),
                        "instanceColor" === e &&
                          r.instanceColor &&
                          (s = r.instanceColor)),
                      void 0 !== s)
                    ) {
                      const e = s.normalized,
                        o = s.itemSize,
                        l = n.get(s);
                      if (void 0 === l) continue;
                      const c = l.buffer,
                        u = l.type,
                        h = l.bytesPerElement;
                      if (s.isInterleavedBufferAttribute) {
                        const n = s.data,
                          l = n.stride,
                          d = s.offset;
                        if (n && n.isInstancedInterleavedBuffer) {
                          for (let t = 0; t < i.locationSize; t++)
                            m(i.location + t, n.meshPerAttribute);
                          !0 !== r.isInstancedMesh &&
                            void 0 === a._maxInstanceCount &&
                            (a._maxInstanceCount =
                              n.meshPerAttribute * n.count);
                        } else
                          for (let t = 0; t < i.locationSize; t++)
                            f(i.location + t);
                        t.bindBuffer(34962, c);
                        for (let t = 0; t < i.locationSize; t++)
                          v(
                            i.location + t,
                            o / i.locationSize,
                            u,
                            e,
                            l * h,
                            (d + (o / i.locationSize) * t) * h
                          );
                      } else {
                        if (s.isInstancedBufferAttribute) {
                          for (let t = 0; t < i.locationSize; t++)
                            m(i.location + t, s.meshPerAttribute);
                          !0 !== r.isInstancedMesh &&
                            void 0 === a._maxInstanceCount &&
                            (a._maxInstanceCount =
                              s.meshPerAttribute * s.count);
                        } else
                          for (let t = 0; t < i.locationSize; t++)
                            f(i.location + t);
                        t.bindBuffer(34962, c);
                        for (let t = 0; t < i.locationSize; t++)
                          v(
                            i.location + t,
                            o / i.locationSize,
                            u,
                            e,
                            o * h,
                            (o / i.locationSize) * t * h
                          );
                      }
                    } else if (void 0 !== u) {
                      const n = u[e];
                      if (void 0 !== n)
                        switch (n.length) {
                          case 2:
                            t.vertexAttrib2fv(i.location, n);
                            break;
                          case 3:
                            t.vertexAttrib3fv(i.location, n);
                            break;
                          case 4:
                            t.vertexAttrib4fv(i.location, n);
                            break;
                          default:
                            t.vertexAttrib1fv(i.location, n);
                        }
                    }
                  }
                }
                g();
              })(r, l, h, y),
              null !== x && t.bindBuffer(34963, n.get(x).buffer));
        },
        reset: y,
        resetDefaultState: x,
        dispose: function () {
          y();
          for (const t in a) {
            const e = a[t];
            for (const t in e) {
              const n = e[t];
              for (const t in n) h(n[t].object), delete n[t];
              delete e[t];
            }
            delete a[t];
          }
        },
        releaseStatesOfGeometry: function (t) {
          if (void 0 === a[t.id]) return;
          const e = a[t.id];
          for (const t in e) {
            const n = e[t];
            for (const t in n) h(n[t].object), delete n[t];
            delete e[t];
          }
          delete a[t.id];
        },
        releaseStatesOfProgram: function (t) {
          for (const e in a) {
            const n = a[e];
            if (void 0 === n[t.id]) continue;
            const i = n[t.id];
            for (const t in i) h(i[t].object), delete i[t];
            delete n[t.id];
          }
        },
        initAttributes: p,
        enableAttribute: f,
        disableUnusedAttributes: g,
      };
    }
    function ns(t, e, n, i) {
      const r = i.isWebGL2;
      let s;
      (this.setMode = function (t) {
        s = t;
      }),
        (this.render = function (e, i) {
          t.drawArrays(s, e, i), n.update(i, s, 1);
        }),
        (this.renderInstances = function (i, o, a) {
          if (0 === a) return;
          let l, c;
          if (r) (l = t), (c = "drawArraysInstanced");
          else if (
            ((l = e.get("ANGLE_instanced_arrays")),
            (c = "drawArraysInstancedANGLE"),
            null === l)
          )
            return void console.error(
              "THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
            );
          l[c](s, i, o, a), n.update(o, s, a);
        });
    }
    function is(t, e, n) {
      let i;
      function r(e) {
        if ("highp" === e) {
          if (
            t.getShaderPrecisionFormat(35633, 36338).precision > 0 &&
            t.getShaderPrecisionFormat(35632, 36338).precision > 0
          )
            return "highp";
          e = "mediump";
        }
        return "mediump" === e &&
          t.getShaderPrecisionFormat(35633, 36337).precision > 0 &&
          t.getShaderPrecisionFormat(35632, 36337).precision > 0
          ? "mediump"
          : "lowp";
      }
      const s =
        ("undefined" != typeof WebGL2RenderingContext &&
          t instanceof WebGL2RenderingContext) ||
        ("undefined" != typeof WebGL2ComputeRenderingContext &&
          t instanceof WebGL2ComputeRenderingContext);
      let o = void 0 !== n.precision ? n.precision : "highp";
      const a = r(o);
      a !== o &&
        (console.warn(
          "THREE.WebGLRenderer:",
          o,
          "not supported, using",
          a,
          "instead."
        ),
        (o = a));
      const l = s || e.has("WEBGL_draw_buffers"),
        c = !0 === n.logarithmicDepthBuffer,
        u = t.getParameter(34930),
        h = t.getParameter(35660),
        d = t.getParameter(3379),
        p = t.getParameter(34076),
        f = t.getParameter(34921),
        m = t.getParameter(36347),
        g = t.getParameter(36348),
        v = t.getParameter(36349),
        y = h > 0,
        x = s || e.has("OES_texture_float");
      return {
        isWebGL2: s,
        drawBuffers: l,
        getMaxAnisotropy: function () {
          if (void 0 !== i) return i;
          if (!0 === e.has("EXT_texture_filter_anisotropic")) {
            const n = e.get("EXT_texture_filter_anisotropic");
            i = t.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
          } else i = 0;
          return i;
        },
        getMaxPrecision: r,
        precision: o,
        logarithmicDepthBuffer: c,
        maxTextures: u,
        maxVertexTextures: h,
        maxTextureSize: d,
        maxCubemapSize: p,
        maxAttributes: f,
        maxVertexUniforms: m,
        maxVaryings: g,
        maxFragmentUniforms: v,
        vertexTextures: y,
        floatFragmentTextures: x,
        floatVertexTextures: y && x,
        maxSamples: s ? t.getParameter(36183) : 0,
      };
    }
    function rs(t) {
      const e = this;
      let n = null,
        i = 0,
        r = !1,
        s = !1;
      const o = new Gr(),
        a = new dn(),
        l = { value: null, needsUpdate: !1 };
      function c() {
        l.value !== n && ((l.value = n), (l.needsUpdate = i > 0)),
          (e.numPlanes = i),
          (e.numIntersection = 0);
      }
      function u(t, n, i, r) {
        const s = null !== t ? t.length : 0;
        let c = null;
        if (0 !== s) {
          if (((c = l.value), !0 !== r || null === c)) {
            const e = i + 4 * s,
              r = n.matrixWorldInverse;
            a.getNormalMatrix(r),
              (null === c || c.length < e) && (c = new Float32Array(e));
            for (let e = 0, n = i; e !== s; ++e, n += 4)
              o.copy(t[e]).applyMatrix4(r, a),
                o.normal.toArray(c, n),
                (c[n + 3] = o.constant);
          }
          (l.value = c), (l.needsUpdate = !0);
        }
        return (e.numPlanes = s), (e.numIntersection = 0), c;
      }
      (this.uniform = l),
        (this.numPlanes = 0),
        (this.numIntersection = 0),
        (this.init = function (t, e, s) {
          const o = 0 !== t.length || e || 0 !== i || r;
          return (r = e), (n = u(t, s, 0)), (i = t.length), o;
        }),
        (this.beginShadows = function () {
          (s = !0), u(null);
        }),
        (this.endShadows = function () {
          (s = !1), c();
        }),
        (this.setState = function (e, o, a) {
          const h = e.clippingPlanes,
            d = e.clipIntersection,
            p = e.clipShadows,
            f = t.get(e);
          if (!r || null === h || 0 === h.length || (s && !p))
            s ? u(null) : c();
          else {
            const t = s ? 0 : i,
              e = 4 * t;
            let r = f.clippingState || null;
            (l.value = r), (r = u(h, o, e, a));
            for (let t = 0; t !== e; ++t) r[t] = n[t];
            (f.clippingState = r),
              (this.numIntersection = d ? this.numPlanes : 0),
              (this.numPlanes += t);
          }
        });
    }
    function ss(t) {
      let e = new WeakMap();
      function n(t, e) {
        return e === lt ? (t.mapping = ot) : e === ct && (t.mapping = at), t;
      }
      function i(t) {
        const n = t.target;
        n.removeEventListener("dispose", i);
        const r = e.get(n);
        void 0 !== r && (e.delete(n), r.dispose());
      }
      return {
        get: function (r) {
          if (r && r.isTexture && !1 === r.isRenderTargetTexture) {
            const s = r.mapping;
            if (s === lt || s === ct) {
              if (e.has(r)) {
                return n(e.get(r).texture, r.mapping);
              }
              {
                const s = r.image;
                if (s && s.height > 0) {
                  const o = t.getRenderTarget(),
                    a = new Ur(s.height / 2);
                  return (
                    a.fromEquirectangularTexture(t, r),
                    e.set(r, a),
                    t.setRenderTarget(o),
                    r.addEventListener("dispose", i),
                    n(a.texture, r.mapping)
                  );
                }
                return null;
              }
            }
          }
          return r;
        },
        dispose: function () {
          e = new WeakMap();
        },
      };
    }
    Kr.physical = {
      uniforms: Lr([
        Kr.standard.uniforms,
        {
          clearcoat: { value: 0 },
          clearcoatMap: { value: null },
          clearcoatRoughness: { value: 0 },
          clearcoatRoughnessMap: { value: null },
          clearcoatNormalScale: { value: new hn(1, 1) },
          clearcoatNormalMap: { value: null },
          sheen: { value: 0 },
          sheenColor: { value: new qi(0) },
          sheenColorMap: { value: null },
          sheenRoughness: { value: 0 },
          sheenRoughnessMap: { value: null },
          transmission: { value: 0 },
          transmissionMap: { value: null },
          transmissionSamplerSize: { value: new hn() },
          transmissionSamplerMap: { value: null },
          thickness: { value: 0 },
          thicknessMap: { value: null },
          attenuationDistance: { value: 0 },
          attenuationColor: { value: new qi(0) },
          specularIntensity: { value: 0 },
          specularIntensityMap: { value: null },
          specularColor: { value: new qi(1, 1, 1) },
          specularColorMap: { value: null },
        },
      ]),
      vertexShader: Zr.meshphysical_vert,
      fragmentShader: Zr.meshphysical_frag,
    };
    class os extends Ir {
      constructor(t = -1, e = 1, n = 1, i = -1, r = 0.1, s = 2e3) {
        super(),
          (this.type = "OrthographicCamera"),
          (this.zoom = 1),
          (this.view = null),
          (this.left = t),
          (this.right = e),
          (this.top = n),
          (this.bottom = i),
          (this.near = r),
          (this.far = s),
          this.updateProjectionMatrix();
      }
      copy(t, e) {
        return (
          super.copy(t, e),
          (this.left = t.left),
          (this.right = t.right),
          (this.top = t.top),
          (this.bottom = t.bottom),
          (this.near = t.near),
          (this.far = t.far),
          (this.zoom = t.zoom),
          (this.view = null === t.view ? null : Object.assign({}, t.view)),
          this
        );
      }
      setViewOffset(t, e, n, i, r, s) {
        null === this.view &&
          (this.view = {
            enabled: !0,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1,
          }),
          (this.view.enabled = !0),
          (this.view.fullWidth = t),
          (this.view.fullHeight = e),
          (this.view.offsetX = n),
          (this.view.offsetY = i),
          (this.view.width = r),
          (this.view.height = s),
          this.updateProjectionMatrix();
      }
      clearViewOffset() {
        null !== this.view && (this.view.enabled = !1),
          this.updateProjectionMatrix();
      }
      updateProjectionMatrix() {
        const t = (this.right - this.left) / (2 * this.zoom),
          e = (this.top - this.bottom) / (2 * this.zoom),
          n = (this.right + this.left) / 2,
          i = (this.top + this.bottom) / 2;
        let r = n - t,
          s = n + t,
          o = i + e,
          a = i - e;
        if (null !== this.view && this.view.enabled) {
          const t = (this.right - this.left) / this.view.fullWidth / this.zoom,
            e = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
          (r += t * this.view.offsetX),
            (s = r + t * this.view.width),
            (o -= e * this.view.offsetY),
            (a = o - e * this.view.height);
        }
        this.projectionMatrix.makeOrthographic(r, s, o, a, this.near, this.far),
          this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
      }
      toJSON(t) {
        const e = super.toJSON(t);
        return (
          (e.object.zoom = this.zoom),
          (e.object.left = this.left),
          (e.object.right = this.right),
          (e.object.top = this.top),
          (e.object.bottom = this.bottom),
          (e.object.near = this.near),
          (e.object.far = this.far),
          null !== this.view && (e.object.view = Object.assign({}, this.view)),
          e
        );
      }
    }
    os.prototype.isOrthographicCamera = !0;
    class as extends kr {
      constructor(t) {
        super(t), (this.type = "RawShaderMaterial");
      }
    }
    as.prototype.isRawShaderMaterial = !0;
    const ls = 4,
      cs = 8,
      us = Math.pow(2, cs),
      hs = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582],
      ds = cs - ls + 1 + hs.length,
      ps = 20,
      fs = { [We]: 0, [Ge]: 1 },
      ms = new os(),
      { _lodPlanes: gs, _sizeLods: vs, _sigmas: ys } = Ts(),
      xs = new qi();
    let bs = null;
    const _s = (1 + Math.sqrt(5)) / 2,
      ws = 1 / _s,
      Ss = [
        new Mn(1, 1, 1),
        new Mn(-1, 1, 1),
        new Mn(1, 1, -1),
        new Mn(-1, 1, -1),
        new Mn(0, _s, ws),
        new Mn(0, _s, -ws),
        new Mn(ws, 0, _s),
        new Mn(-ws, 0, _s),
        new Mn(_s, ws, 0),
        new Mn(-_s, ws, 0),
      ];
    class Ms {
      constructor(t) {
        (this._renderer = t),
          (this._pingPongRenderTarget = null),
          (this._blurMaterial = (function (t) {
            const e = new Float32Array(t),
              n = new Mn(0, 1, 0);
            return new as({
              name: "SphericalGaussianBlur",
              defines: { n: t },
              uniforms: {
                envMap: { value: null },
                samples: { value: 1 },
                weights: { value: e },
                latitudinal: { value: !1 },
                dTheta: { value: 0 },
                mipInt: { value: 0 },
                poleAxis: { value: n },
              },
              vertexShader: Rs(),
              fragmentShader: `\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t${Ps()}\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t`,
              blending: x,
              depthTest: !1,
              depthWrite: !1,
            });
          })(ps)),
          (this._equirectShader = null),
          (this._cubemapShader = null),
          this._compileMaterial(this._blurMaterial);
      }
      fromScene(t, e = 0, n = 0.1, i = 100) {
        bs = this._renderer.getRenderTarget();
        const r = this._allocateTargets();
        return (
          this._sceneToCubeUV(t, n, i, r),
          e > 0 && this._blur(r, 0, 0, e),
          this._applyPMREM(r),
          this._cleanup(r),
          r
        );
      }
      fromEquirectangular(t) {
        return this._fromTexture(t);
      }
      fromCubemap(t) {
        return this._fromTexture(t);
      }
      compileCubemapShader() {
        null === this._cubemapShader &&
          ((this._cubemapShader = Ls()),
          this._compileMaterial(this._cubemapShader));
      }
      compileEquirectangularShader() {
        null === this._equirectShader &&
          ((this._equirectShader = Cs()),
          this._compileMaterial(this._equirectShader));
      }
      dispose() {
        this._blurMaterial.dispose(),
          null !== this._cubemapShader && this._cubemapShader.dispose(),
          null !== this._equirectShader && this._equirectShader.dispose();
        for (let t = 0; t < gs.length; t++) gs[t].dispose();
      }
      _cleanup(t) {
        this._pingPongRenderTarget.dispose(),
          this._renderer.setRenderTarget(bs),
          (t.scissorTest = !1),
          As(t, 0, 0, t.width, t.height);
      }
      _fromTexture(t) {
        bs = this._renderer.getRenderTarget();
        const e = this._allocateTargets(t);
        return (
          this._textureToCubeUV(t, e), this._applyPMREM(e), this._cleanup(e), e
        );
      }
      _allocateTargets(t) {
        const e = {
            magFilter: yt,
            minFilter: yt,
            generateMipmaps: !1,
            type: Ct,
            format: Nt,
            encoding: We,
            depthBuffer: !1,
          },
          n = Es(e);
        return (n.depthBuffer = !t), (this._pingPongRenderTarget = Es(e)), n;
      }
      _compileMaterial(t) {
        const e = new Tr(gs[0], t);
        this._renderer.compile(e, ms);
      }
      _sceneToCubeUV(t, e, n, i) {
        const r = new Nr(90, 1, e, n),
          s = [1, -1, 1, 1, 1, 1],
          o = [1, 1, 1, -1, -1, -1],
          a = this._renderer,
          l = a.autoClear,
          c = a.toneMapping;
        a.getClearColor(xs), (a.toneMapping = K), (a.autoClear = !1);
        const u = new $i({
            name: "PMREM.Background",
            side: g,
            depthWrite: !1,
            depthTest: !1,
          }),
          h = new Tr(new Ar(), u);
        let d = !1;
        const p = t.background;
        p
          ? p.isColor && (u.color.copy(p), (t.background = null), (d = !0))
          : (u.color.copy(xs), (d = !0));
        for (let e = 0; e < 6; e++) {
          const n = e % 3;
          0 == n
            ? (r.up.set(0, s[e], 0), r.lookAt(o[e], 0, 0))
            : 1 == n
            ? (r.up.set(0, 0, s[e]), r.lookAt(0, o[e], 0))
            : (r.up.set(0, s[e], 0), r.lookAt(0, 0, o[e])),
            As(i, n * us, e > 2 ? us : 0, us, us),
            a.setRenderTarget(i),
            d && a.render(h, r),
            a.render(t, r);
        }
        h.geometry.dispose(),
          h.material.dispose(),
          (a.toneMapping = c),
          (a.autoClear = l),
          (t.background = p);
      }
      _setEncoding(t, e) {
        !0 === this._renderer.capabilities.isWebGL2 &&
        e.format === Nt &&
        e.type === _t &&
        e.encoding === Ge
          ? (t.value = fs[We])
          : (t.value = fs[e.encoding]);
      }
      _textureToCubeUV(t, e) {
        const n = this._renderer,
          i = t.mapping === ot || t.mapping === at;
        i
          ? null == this._cubemapShader && (this._cubemapShader = Ls())
          : null == this._equirectShader && (this._equirectShader = Cs());
        const r = i ? this._cubemapShader : this._equirectShader,
          s = new Tr(gs[0], r),
          o = r.uniforms;
        (o.envMap.value = t),
          i || o.texelSize.value.set(1 / t.image.width, 1 / t.image.height),
          this._setEncoding(o.inputEncoding, t),
          As(e, 0, 0, 3 * us, 2 * us),
          n.setRenderTarget(e),
          n.render(s, ms);
      }
      _applyPMREM(t) {
        const e = this._renderer,
          n = e.autoClear;
        e.autoClear = !1;
        for (let e = 1; e < ds; e++) {
          const n = Math.sqrt(ys[e] * ys[e] - ys[e - 1] * ys[e - 1]),
            i = Ss[(e - 1) % Ss.length];
          this._blur(t, e - 1, e, n, i);
        }
        e.autoClear = n;
      }
      _blur(t, e, n, i, r) {
        const s = this._pingPongRenderTarget;
        this._halfBlur(t, s, e, n, i, "latitudinal", r),
          this._halfBlur(s, t, n, n, i, "longitudinal", r);
      }
      _halfBlur(t, e, n, i, r, s, o) {
        const a = this._renderer,
          l = this._blurMaterial;
        "latitudinal" !== s &&
          "longitudinal" !== s &&
          console.error(
            "blur direction must be either latitudinal or longitudinal!"
          );
        const c = new Tr(gs[i], l),
          u = l.uniforms,
          h = vs[n] - 1,
          d = isFinite(r) ? Math.PI / (2 * h) : (2 * Math.PI) / (2 * ps - 1),
          p = r / d,
          f = isFinite(r) ? 1 + Math.floor(3 * p) : ps;
        f > ps &&
          console.warn(
            `sigmaRadians, ${r}, is too large and will clip, as it requested ${f} samples when the maximum is set to ${ps}`
          );
        const m = [];
        let g = 0;
        for (let t = 0; t < ps; ++t) {
          const e = t / p,
            n = Math.exp((-e * e) / 2);
          m.push(n), 0 == t ? (g += n) : t < f && (g += 2 * n);
        }
        for (let t = 0; t < m.length; t++) m[t] = m[t] / g;
        (u.envMap.value = t.texture),
          (u.samples.value = f),
          (u.weights.value = m),
          (u.latitudinal.value = "latitudinal" === s),
          o && (u.poleAxis.value = o),
          (u.dTheta.value = d),
          (u.mipInt.value = cs - n);
        const v = vs[i];
        As(
          e,
          3 * Math.max(0, us - 2 * v),
          (0 === i ? 0 : 2 * us) + 2 * v * (i > cs - ls ? i - cs + ls : 0),
          3 * v,
          2 * v
        ),
          a.setRenderTarget(e),
          a.render(c, ms);
      }
    }
    function Ts() {
      const t = [],
        e = [],
        n = [];
      let i = cs;
      for (let r = 0; r < ds; r++) {
        const s = Math.pow(2, i);
        e.push(s);
        let o = 1 / s;
        r > cs - ls ? (o = hs[r - cs + ls - 1]) : 0 == r && (o = 0), n.push(o);
        const a = 1 / (s - 1),
          l = -a / 2,
          c = 1 + a / 2,
          u = [l, l, c, l, c, c, l, l, c, c, l, c],
          h = 6,
          d = 6,
          p = 3,
          f = 2,
          m = 1,
          g = new Float32Array(p * d * h),
          v = new Float32Array(f * d * h),
          y = new Float32Array(m * d * h);
        for (let t = 0; t < h; t++) {
          const e = ((t % 3) * 2) / 3 - 1,
            n = t > 2 ? 0 : -1,
            i = [
              e,
              n,
              0,
              e + 2 / 3,
              n,
              0,
              e + 2 / 3,
              n + 1,
              0,
              e,
              n,
              0,
              e + 2 / 3,
              n + 1,
              0,
              e,
              n + 1,
              0,
            ];
          g.set(i, p * d * t), v.set(u, f * d * t);
          const r = [t, t, t, t, t, t];
          y.set(r, m * d * t);
        }
        const x = new ar();
        x.setAttribute("position", new Yi(g, p)),
          x.setAttribute("uv", new Yi(v, f)),
          x.setAttribute("faceIndex", new Yi(y, m)),
          t.push(x),
          i > ls && i--;
      }
      return { _lodPlanes: t, _sizeLods: e, _sigmas: n };
    }
    function Es(t) {
      const e = new _n(3 * us, 3 * us, t);
      return (
        (e.texture.mapping = ut),
        (e.texture.name = "PMREM.cubeUv"),
        (e.scissorTest = !0),
        e
      );
    }
    function As(t, e, n, i, r) {
      t.viewport.set(e, n, i, r), t.scissor.set(e, n, i, r);
    }
    function Cs() {
      const t = new hn(1, 1);
      return new as({
        name: "EquirectangularToCubeUV",
        uniforms: {
          envMap: { value: null },
          texelSize: { value: t },
          inputEncoding: { value: fs[We] },
        },
        vertexShader: Rs(),
        fragmentShader: `\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform vec2 texelSize;\n\n\t\t\t${Ps()}\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tvec2 f = fract( uv / texelSize - 0.5 );\n\t\t\t\tuv -= f * texelSize;\n\t\t\t\tvec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x += texelSize.x;\n\t\t\t\tvec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.y += texelSize.y;\n\t\t\t\tvec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x -= texelSize.x;\n\t\t\t\tvec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\n\t\t\t\tvec3 tm = mix( tl, tr, f.x );\n\t\t\t\tvec3 bm = mix( bl, br, f.x );\n\t\t\t\tgl_FragColor.rgb = mix( tm, bm, f.y );\n\n\t\t\t}\n\t\t`,
        blending: x,
        depthTest: !1,
        depthWrite: !1,
      });
    }
    function Ls() {
      return new as({
        name: "CubemapToCubeUV",
        uniforms: { envMap: { value: null }, inputEncoding: { value: fs[We] } },
        vertexShader: Rs(),
        fragmentShader: `\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\t${Ps()}\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) );\n\n\t\t\t}\n\t\t`,
        blending: x,
        depthTest: !1,
        depthWrite: !1,
      });
    }
    function Rs() {
      return "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t";
    }
    function Ps() {
      return "\n\n\t\tuniform int inputEncoding;\n\n\t\t#include <encodings_pars_fragment>\n\n\t\tvec4 inputTexelToLinear( vec4 value ) {\n\n\t\t\tif ( inputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else {\n\n\t\t\t\treturn sRGBToLinear( value );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 envMapTexelToLinear( vec4 color ) {\n\n\t\t\treturn inputTexelToLinear( color );\n\n\t\t}\n\t";
    }
    function Ds(t) {
      let e = new WeakMap(),
        n = null;
      function i(t) {
        const n = t.target;
        n.removeEventListener("dispose", i);
        const r = e.get(n);
        void 0 !== r && (e.delete(n), r.dispose());
      }
      return {
        get: function (r) {
          if (r && r.isTexture && !1 === r.isRenderTargetTexture) {
            const s = r.mapping,
              o = s === lt || s === ct,
              a = s === ot || s === at;
            if (o || a) {
              if (e.has(r)) return e.get(r).texture;
              {
                const s = r.image;
                if (
                  (o && s && s.height > 0) ||
                  (a &&
                    s &&
                    (function (t) {
                      let e = 0;
                      for (let n = 0; n < 6; n++) void 0 !== t[n] && e++;
                      return 6 === e;
                    })(s))
                ) {
                  const s = t.getRenderTarget();
                  null === n && (n = new Ms(t));
                  const a = o ? n.fromEquirectangular(r) : n.fromCubemap(r);
                  return (
                    e.set(r, a),
                    t.setRenderTarget(s),
                    r.addEventListener("dispose", i),
                    a.texture
                  );
                }
                return null;
              }
            }
          }
          return r;
        },
        dispose: function () {
          (e = new WeakMap()), null !== n && (n.dispose(), (n = null));
        },
      };
    }
    function ks(t) {
      const e = {};
      function n(n) {
        if (void 0 !== e[n]) return e[n];
        let i;
        switch (n) {
          case "WEBGL_depth_texture":
            i =
              t.getExtension("WEBGL_depth_texture") ||
              t.getExtension("MOZ_WEBGL_depth_texture") ||
              t.getExtension("WEBKIT_WEBGL_depth_texture");
            break;
          case "EXT_texture_filter_anisotropic":
            i =
              t.getExtension("EXT_texture_filter_anisotropic") ||
              t.getExtension("MOZ_EXT_texture_filter_anisotropic") ||
              t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
            break;
          case "WEBGL_compressed_texture_s3tc":
            i =
              t.getExtension("WEBGL_compressed_texture_s3tc") ||
              t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") ||
              t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
            break;
          case "WEBGL_compressed_texture_pvrtc":
            i =
              t.getExtension("WEBGL_compressed_texture_pvrtc") ||
              t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
            break;
          default:
            i = t.getExtension(n);
        }
        return (e[n] = i), i;
      }
      return {
        has: function (t) {
          return null !== n(t);
        },
        init: function (t) {
          t.isWebGL2
            ? n("EXT_color_buffer_float")
            : (n("WEBGL_depth_texture"),
              n("OES_texture_float"),
              n("OES_texture_half_float"),
              n("OES_texture_half_float_linear"),
              n("OES_standard_derivatives"),
              n("OES_element_index_uint"),
              n("OES_vertex_array_object"),
              n("ANGLE_instanced_arrays")),
            n("OES_texture_float_linear"),
            n("EXT_color_buffer_half_float"),
            n("WEBGL_multisampled_render_to_texture");
        },
        get: function (t) {
          const e = n(t);
          return (
            null === e &&
              console.warn(
                "THREE.WebGLRenderer: " + t + " extension not supported."
              ),
            e
          );
        },
      };
    }
    function Is(t, e, n, i) {
      const r = {},
        s = new WeakMap();
      function o(t) {
        const a = t.target;
        null !== a.index && e.remove(a.index);
        for (const t in a.attributes) e.remove(a.attributes[t]);
        a.removeEventListener("dispose", o), delete r[a.id];
        const l = s.get(a);
        l && (e.remove(l), s.delete(a)),
          i.releaseStatesOfGeometry(a),
          !0 === a.isInstancedBufferGeometry && delete a._maxInstanceCount,
          n.memory.geometries--;
      }
      function a(t) {
        const n = [],
          i = t.index,
          r = t.attributes.position;
        let o = 0;
        if (null !== i) {
          const t = i.array;
          o = i.version;
          for (let e = 0, i = t.length; e < i; e += 3) {
            const i = t[e + 0],
              r = t[e + 1],
              s = t[e + 2];
            n.push(i, r, r, s, s, i);
          }
        } else {
          const t = r.array;
          o = r.version;
          for (let e = 0, i = t.length / 3 - 1; e < i; e += 3) {
            const t = e + 0,
              i = e + 1,
              r = e + 2;
            n.push(t, i, i, r, r, t);
          }
        }
        const a = new (pn(n) > 65535 ? Qi : Zi)(n, 1);
        a.version = o;
        const l = s.get(t);
        l && e.remove(l), s.set(t, a);
      }
      return {
        get: function (t, e) {
          return !0 === r[e.id]
            ? e
            : (e.addEventListener("dispose", o),
              (r[e.id] = !0),
              n.memory.geometries++,
              e);
        },
        update: function (t) {
          const n = t.attributes;
          for (const t in n) e.update(n[t], 34962);
          const i = t.morphAttributes;
          for (const t in i) {
            const n = i[t];
            for (let t = 0, i = n.length; t < i; t++) e.update(n[t], 34962);
          }
        },
        getWireframeAttribute: function (t) {
          const e = s.get(t);
          if (e) {
            const n = t.index;
            null !== n && e.version < n.version && a(t);
          } else a(t);
          return s.get(t);
        },
      };
    }
    function Ns(t, e, n, i) {
      const r = i.isWebGL2;
      let s, o, a;
      (this.setMode = function (t) {
        s = t;
      }),
        (this.setIndex = function (t) {
          (o = t.type), (a = t.bytesPerElement);
        }),
        (this.render = function (e, i) {
          t.drawElements(s, i, o, e * a), n.update(i, s, 1);
        }),
        (this.renderInstances = function (i, l, c) {
          if (0 === c) return;
          let u, h;
          if (r) (u = t), (h = "drawElementsInstanced");
          else if (
            ((u = e.get("ANGLE_instanced_arrays")),
            (h = "drawElementsInstancedANGLE"),
            null === u)
          )
            return void console.error(
              "THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
            );
          u[h](s, l, o, i * a, c), n.update(l, s, c);
        });
    }
    function Os(t) {
      const e = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
      return {
        memory: { geometries: 0, textures: 0 },
        render: e,
        programs: null,
        autoReset: !0,
        reset: function () {
          e.frame++,
            (e.calls = 0),
            (e.triangles = 0),
            (e.points = 0),
            (e.lines = 0);
        },
        update: function (t, n, i) {
          switch ((e.calls++, n)) {
            case 4:
              e.triangles += i * (t / 3);
              break;
            case 1:
              e.lines += i * (t / 2);
              break;
            case 3:
              e.lines += i * (t - 1);
              break;
            case 2:
              e.lines += i * t;
              break;
            case 0:
              e.points += i * t;
              break;
            default:
              console.error("THREE.WebGLInfo: Unknown draw mode:", n);
          }
        },
      };
    }
    class zs extends yn {
      constructor(t = null, e = 1, n = 1, i = 1) {
        super(null),
          (this.image = { data: t, width: e, height: n, depth: i }),
          (this.magFilter = mt),
          (this.minFilter = mt),
          (this.wrapR = pt),
          (this.generateMipmaps = !1),
          (this.flipY = !1),
          (this.unpackAlignment = 1);
      }
    }
    function Hs(t, e) {
      return t[0] - e[0];
    }
    function Bs(t, e) {
      return Math.abs(e[1]) - Math.abs(t[1]);
    }
    function Us(t, e) {
      let n = 1;
      const i = e.isInterleavedBufferAttribute ? e.data.array : e.array;
      i instanceof Int8Array
        ? (n = 127)
        : i instanceof Int16Array
        ? (n = 32767)
        : i instanceof Int32Array
        ? (n = 2147483647)
        : console.error(
            "THREE.WebGLMorphtargets: Unsupported morph attribute data type: ",
            i
          ),
        t.divideScalar(n);
    }
    function Fs(t, e, n) {
      const i = {},
        r = new Float32Array(8),
        s = new WeakMap(),
        o = new Mn(),
        a = [];
      for (let t = 0; t < 8; t++) a[t] = [t, 0];
      return {
        update: function (l, c, u, h) {
          const d = l.morphTargetInfluences;
          if (!0 === e.isWebGL2) {
            const i = c.morphAttributes.position.length;
            let r = s.get(c);
            if (void 0 === r || r.count !== i) {
              void 0 !== r && r.texture.dispose();
              const t = void 0 !== c.morphAttributes.normal,
                n = c.morphAttributes.position,
                a = c.morphAttributes.normal || [],
                l = !0 === t ? 2 : 1;
              let u = c.attributes.position.count * l,
                h = 1;
              u > e.maxTextureSize &&
                ((h = Math.ceil(u / e.maxTextureSize)), (u = e.maxTextureSize));
              const d = new Float32Array(u * h * 4 * i),
                p = new zs(d, u, h, i);
              (p.format = Nt), (p.type = At), (p.needsUpdate = !0);
              const f = 4 * l;
              for (let e = 0; e < i; e++) {
                const i = n[e],
                  r = a[e],
                  s = u * h * 4 * e;
                for (let e = 0; e < i.count; e++) {
                  o.fromBufferAttribute(i, e), !0 === i.normalized && Us(o, i);
                  const n = e * f;
                  (d[s + n + 0] = o.x),
                    (d[s + n + 1] = o.y),
                    (d[s + n + 2] = o.z),
                    (d[s + n + 3] = 0),
                    !0 === t &&
                      (o.fromBufferAttribute(r, e),
                      !0 === r.normalized && Us(o, r),
                      (d[s + n + 4] = o.x),
                      (d[s + n + 5] = o.y),
                      (d[s + n + 6] = o.z),
                      (d[s + n + 7] = 0));
                }
              }
              (r = { count: i, texture: p, size: new hn(u, h) }), s.set(c, r);
            }
            let a = 0;
            for (let t = 0; t < d.length; t++) a += d[t];
            const l = c.morphTargetsRelative ? 1 : 1 - a;
            h.getUniforms().setValue(t, "morphTargetBaseInfluence", l),
              h.getUniforms().setValue(t, "morphTargetInfluences", d),
              h.getUniforms().setValue(t, "morphTargetsTexture", r.texture, n),
              h.getUniforms().setValue(t, "morphTargetsTextureSize", r.size);
          } else {
            const e = void 0 === d ? 0 : d.length;
            let n = i[c.id];
            if (void 0 === n || n.length !== e) {
              n = [];
              for (let t = 0; t < e; t++) n[t] = [t, 0];
              i[c.id] = n;
            }
            for (let t = 0; t < e; t++) {
              const e = n[t];
              (e[0] = t), (e[1] = d[t]);
            }
            n.sort(Bs);
            for (let t = 0; t < 8; t++)
              t < e && n[t][1]
                ? ((a[t][0] = n[t][0]), (a[t][1] = n[t][1]))
                : ((a[t][0] = Number.MAX_SAFE_INTEGER), (a[t][1] = 0));
            a.sort(Hs);
            const s = c.morphAttributes.position,
              o = c.morphAttributes.normal;
            let l = 0;
            for (let t = 0; t < 8; t++) {
              const e = a[t],
                n = e[0],
                i = e[1];
              n !== Number.MAX_SAFE_INTEGER && i
                ? (s &&
                    c.getAttribute("morphTarget" + t) !== s[n] &&
                    c.setAttribute("morphTarget" + t, s[n]),
                  o &&
                    c.getAttribute("morphNormal" + t) !== o[n] &&
                    c.setAttribute("morphNormal" + t, o[n]),
                  (r[t] = i),
                  (l += i))
                : (s &&
                    !0 === c.hasAttribute("morphTarget" + t) &&
                    c.deleteAttribute("morphTarget" + t),
                  o &&
                    !0 === c.hasAttribute("morphNormal" + t) &&
                    c.deleteAttribute("morphNormal" + t),
                  (r[t] = 0));
            }
            const u = c.morphTargetsRelative ? 1 : 1 - l;
            h.getUniforms().setValue(t, "morphTargetBaseInfluence", u),
              h.getUniforms().setValue(t, "morphTargetInfluences", r);
          }
        },
      };
    }
    function Vs(t, e, n, i) {
      let r = new WeakMap();
      function s(t) {
        const e = t.target;
        e.removeEventListener("dispose", s),
          n.remove(e.instanceMatrix),
          null !== e.instanceColor && n.remove(e.instanceColor);
      }
      return {
        update: function (t) {
          const o = i.render.frame,
            a = t.geometry,
            l = e.get(t, a);
          return (
            r.get(l) !== o && (e.update(l), r.set(l, o)),
            t.isInstancedMesh &&
              (!1 === t.hasEventListener("dispose", s) &&
                t.addEventListener("dispose", s),
              n.update(t.instanceMatrix, 34962),
              null !== t.instanceColor && n.update(t.instanceColor, 34962)),
            l
          );
        },
        dispose: function () {
          r = new WeakMap();
        },
      };
    }
    zs.prototype.isDataTexture2DArray = !0;
    class Ws extends yn {
      constructor(t = null, e = 1, n = 1, i = 1) {
        super(null),
          (this.image = { data: t, width: e, height: n, depth: i }),
          (this.magFilter = mt),
          (this.minFilter = mt),
          (this.wrapR = pt),
          (this.generateMipmaps = !1),
          (this.flipY = !1),
          (this.unpackAlignment = 1);
      }
    }
    Ws.prototype.isDataTexture3D = !0;
    const Gs = new yn(),
      js = new zs(),
      qs = new Ws(),
      $s = new Br(),
      Xs = [],
      Js = [],
      Ys = new Float32Array(16),
      Zs = new Float32Array(9),
      Qs = new Float32Array(4);
    function Ks(t, e, n) {
      const i = t[0];
      if (i <= 0 || i > 0) return t;
      const r = e * n;
      let s = Xs[r];
      if ((void 0 === s && ((s = new Float32Array(r)), (Xs[r] = s)), 0 !== e)) {
        i.toArray(s, 0);
        for (let i = 1, r = 0; i !== e; ++i) (r += n), t[i].toArray(s, r);
      }
      return s;
    }
    function to(t, e) {
      if (t.length !== e.length) return !1;
      for (let n = 0, i = t.length; n < i; n++) if (t[n] !== e[n]) return !1;
      return !0;
    }
    function eo(t, e) {
      for (let n = 0, i = e.length; n < i; n++) t[n] = e[n];
    }
    function no(t, e) {
      let n = Js[e];
      void 0 === n && ((n = new Int32Array(e)), (Js[e] = n));
      for (let i = 0; i !== e; ++i) n[i] = t.allocateTextureUnit();
      return n;
    }
    function io(t, e) {
      const n = this.cache;
      n[0] !== e && (t.uniform1f(this.addr, e), (n[0] = e));
    }
    function ro(t, e) {
      const n = this.cache;
      if (void 0 !== e.x)
        (n[0] === e.x && n[1] === e.y) ||
          (t.uniform2f(this.addr, e.x, e.y), (n[0] = e.x), (n[1] = e.y));
      else {
        if (to(n, e)) return;
        t.uniform2fv(this.addr, e), eo(n, e);
      }
    }
    function so(t, e) {
      const n = this.cache;
      if (void 0 !== e.x)
        (n[0] === e.x && n[1] === e.y && n[2] === e.z) ||
          (t.uniform3f(this.addr, e.x, e.y, e.z),
          (n[0] = e.x),
          (n[1] = e.y),
          (n[2] = e.z));
      else if (void 0 !== e.r)
        (n[0] === e.r && n[1] === e.g && n[2] === e.b) ||
          (t.uniform3f(this.addr, e.r, e.g, e.b),
          (n[0] = e.r),
          (n[1] = e.g),
          (n[2] = e.b));
      else {
        if (to(n, e)) return;
        t.uniform3fv(this.addr, e), eo(n, e);
      }
    }
    function oo(t, e) {
      const n = this.cache;
      if (void 0 !== e.x)
        (n[0] === e.x && n[1] === e.y && n[2] === e.z && n[3] === e.w) ||
          (t.uniform4f(this.addr, e.x, e.y, e.z, e.w),
          (n[0] = e.x),
          (n[1] = e.y),
          (n[2] = e.z),
          (n[3] = e.w));
      else {
        if (to(n, e)) return;
        t.uniform4fv(this.addr, e), eo(n, e);
      }
    }
    function ao(t, e) {
      const n = this.cache,
        i = e.elements;
      if (void 0 === i) {
        if (to(n, e)) return;
        t.uniformMatrix2fv(this.addr, !1, e), eo(n, e);
      } else {
        if (to(n, i)) return;
        Qs.set(i), t.uniformMatrix2fv(this.addr, !1, Qs), eo(n, i);
      }
    }
    function lo(t, e) {
      const n = this.cache,
        i = e.elements;
      if (void 0 === i) {
        if (to(n, e)) return;
        t.uniformMatrix3fv(this.addr, !1, e), eo(n, e);
      } else {
        if (to(n, i)) return;
        Zs.set(i), t.uniformMatrix3fv(this.addr, !1, Zs), eo(n, i);
      }
    }
    function co(t, e) {
      const n = this.cache,
        i = e.elements;
      if (void 0 === i) {
        if (to(n, e)) return;
        t.uniformMatrix4fv(this.addr, !1, e), eo(n, e);
      } else {
        if (to(n, i)) return;
        Ys.set(i), t.uniformMatrix4fv(this.addr, !1, Ys), eo(n, i);
      }
    }
    function uo(t, e) {
      const n = this.cache;
      n[0] !== e && (t.uniform1i(this.addr, e), (n[0] = e));
    }
    function ho(t, e) {
      const n = this.cache;
      to(n, e) || (t.uniform2iv(this.addr, e), eo(n, e));
    }
    function po(t, e) {
      const n = this.cache;
      to(n, e) || (t.uniform3iv(this.addr, e), eo(n, e));
    }
    function fo(t, e) {
      const n = this.cache;
      to(n, e) || (t.uniform4iv(this.addr, e), eo(n, e));
    }
    function mo(t, e) {
      const n = this.cache;
      n[0] !== e && (t.uniform1ui(this.addr, e), (n[0] = e));
    }
    function go(t, e) {
      const n = this.cache;
      to(n, e) || (t.uniform2uiv(this.addr, e), eo(n, e));
    }
    function vo(t, e) {
      const n = this.cache;
      to(n, e) || (t.uniform3uiv(this.addr, e), eo(n, e));
    }
    function yo(t, e) {
      const n = this.cache;
      to(n, e) || (t.uniform4uiv(this.addr, e), eo(n, e));
    }
    function xo(t, e, n) {
      const i = this.cache,
        r = n.allocateTextureUnit();
      i[0] !== r && (t.uniform1i(this.addr, r), (i[0] = r)),
        n.safeSetTexture2D(e || Gs, r);
    }
    function bo(t, e, n) {
      const i = this.cache,
        r = n.allocateTextureUnit();
      i[0] !== r && (t.uniform1i(this.addr, r), (i[0] = r)),
        n.setTexture3D(e || qs, r);
    }
    function _o(t, e, n) {
      const i = this.cache,
        r = n.allocateTextureUnit();
      i[0] !== r && (t.uniform1i(this.addr, r), (i[0] = r)),
        n.safeSetTextureCube(e || $s, r);
    }
    function wo(t, e, n) {
      const i = this.cache,
        r = n.allocateTextureUnit();
      i[0] !== r && (t.uniform1i(this.addr, r), (i[0] = r)),
        n.setTexture2DArray(e || js, r);
    }
    function So(t, e) {
      t.uniform1fv(this.addr, e);
    }
    function Mo(t, e) {
      const n = Ks(e, this.size, 2);
      t.uniform2fv(this.addr, n);
    }
    function To(t, e) {
      const n = Ks(e, this.size, 3);
      t.uniform3fv(this.addr, n);
    }
    function Eo(t, e) {
      const n = Ks(e, this.size, 4);
      t.uniform4fv(this.addr, n);
    }
    function Ao(t, e) {
      const n = Ks(e, this.size, 4);
      t.uniformMatrix2fv(this.addr, !1, n);
    }
    function Co(t, e) {
      const n = Ks(e, this.size, 9);
      t.uniformMatrix3fv(this.addr, !1, n);
    }
    function Lo(t, e) {
      const n = Ks(e, this.size, 16);
      t.uniformMatrix4fv(this.addr, !1, n);
    }
    function Ro(t, e) {
      t.uniform1iv(this.addr, e);
    }
    function Po(t, e) {
      t.uniform2iv(this.addr, e);
    }
    function Do(t, e) {
      t.uniform3iv(this.addr, e);
    }
    function ko(t, e) {
      t.uniform4iv(this.addr, e);
    }
    function Io(t, e) {
      t.uniform1uiv(this.addr, e);
    }
    function No(t, e) {
      t.uniform2uiv(this.addr, e);
    }
    function Oo(t, e) {
      t.uniform3uiv(this.addr, e);
    }
    function zo(t, e) {
      t.uniform4uiv(this.addr, e);
    }
    function Ho(t, e, n) {
      const i = e.length,
        r = no(n, i);
      t.uniform1iv(this.addr, r);
      for (let t = 0; t !== i; ++t) n.safeSetTexture2D(e[t] || Gs, r[t]);
    }
    function Bo(t, e, n) {
      const i = e.length,
        r = no(n, i);
      t.uniform1iv(this.addr, r);
      for (let t = 0; t !== i; ++t) n.setTexture3D(e[t] || qs, r[t]);
    }
    function Uo(t, e, n) {
      const i = e.length,
        r = no(n, i);
      t.uniform1iv(this.addr, r);
      for (let t = 0; t !== i; ++t) n.safeSetTextureCube(e[t] || $s, r[t]);
    }
    function Fo(t, e, n) {
      const i = e.length,
        r = no(n, i);
      t.uniform1iv(this.addr, r);
      for (let t = 0; t !== i; ++t) n.setTexture2DArray(e[t] || js, r[t]);
    }
    function Vo(t, e, n) {
      (this.id = t),
        (this.addr = n),
        (this.cache = []),
        (this.setValue = (function (t) {
          switch (t) {
            case 5126:
              return io;
            case 35664:
              return ro;
            case 35665:
              return so;
            case 35666:
              return oo;
            case 35674:
              return ao;
            case 35675:
              return lo;
            case 35676:
              return co;
            case 5124:
            case 35670:
              return uo;
            case 35667:
            case 35671:
              return ho;
            case 35668:
            case 35672:
              return po;
            case 35669:
            case 35673:
              return fo;
            case 5125:
              return mo;
            case 36294:
              return go;
            case 36295:
              return vo;
            case 36296:
              return yo;
            case 35678:
            case 36198:
            case 36298:
            case 36306:
            case 35682:
              return xo;
            case 35679:
            case 36299:
            case 36307:
              return bo;
            case 35680:
            case 36300:
            case 36308:
            case 36293:
              return _o;
            case 36289:
            case 36303:
            case 36311:
            case 36292:
              return wo;
          }
        })(e.type));
    }
    function Wo(t, e, n) {
      (this.id = t),
        (this.addr = n),
        (this.cache = []),
        (this.size = e.size),
        (this.setValue = (function (t) {
          switch (t) {
            case 5126:
              return So;
            case 35664:
              return Mo;
            case 35665:
              return To;
            case 35666:
              return Eo;
            case 35674:
              return Ao;
            case 35675:
              return Co;
            case 35676:
              return Lo;
            case 5124:
            case 35670:
              return Ro;
            case 35667:
            case 35671:
              return Po;
            case 35668:
            case 35672:
              return Do;
            case 35669:
            case 35673:
              return ko;
            case 5125:
              return Io;
            case 36294:
              return No;
            case 36295:
              return Oo;
            case 36296:
              return zo;
            case 35678:
            case 36198:
            case 36298:
            case 36306:
            case 35682:
              return Ho;
            case 35679:
            case 36299:
            case 36307:
              return Bo;
            case 35680:
            case 36300:
            case 36308:
            case 36293:
              return Uo;
            case 36289:
            case 36303:
            case 36311:
            case 36292:
              return Fo;
          }
        })(e.type));
    }
    function Go(t) {
      (this.id = t), (this.seq = []), (this.map = {});
    }
    (Wo.prototype.updateCache = function (t) {
      const e = this.cache;
      t instanceof Float32Array &&
        e.length !== t.length &&
        (this.cache = new Float32Array(t.length)),
        eo(e, t);
    }),
      (Go.prototype.setValue = function (t, e, n) {
        const i = this.seq;
        for (let r = 0, s = i.length; r !== s; ++r) {
          const s = i[r];
          s.setValue(t, e[s.id], n);
        }
      });
    const jo = /(\w+)(\])?(\[|\.)?/g;
    function qo(t, e) {
      t.seq.push(e), (t.map[e.id] = e);
    }
    function $o(t, e, n) {
      const i = t.name,
        r = i.length;
      for (jo.lastIndex = 0; ; ) {
        const s = jo.exec(i),
          o = jo.lastIndex;
        let a = s[1];
        const l = "]" === s[2],
          c = s[3];
        if ((l && (a |= 0), void 0 === c || ("[" === c && o + 2 === r))) {
          qo(n, void 0 === c ? new Vo(a, t, e) : new Wo(a, t, e));
          break;
        }
        {
          let t = n.map[a];
          void 0 === t && ((t = new Go(a)), qo(n, t)), (n = t);
        }
      }
    }
    function Xo(t, e) {
      (this.seq = []), (this.map = {});
      const n = t.getProgramParameter(e, 35718);
      for (let i = 0; i < n; ++i) {
        const n = t.getActiveUniform(e, i);
        $o(n, t.getUniformLocation(e, n.name), this);
      }
    }
    function Jo(t, e, n) {
      const i = t.createShader(e);
      return t.shaderSource(i, n), t.compileShader(i), i;
    }
    (Xo.prototype.setValue = function (t, e, n, i) {
      const r = this.map[e];
      void 0 !== r && r.setValue(t, n, i);
    }),
      (Xo.prototype.setOptional = function (t, e, n) {
        const i = e[n];
        void 0 !== i && this.setValue(t, n, i);
      }),
      (Xo.upload = function (t, e, n, i) {
        for (let r = 0, s = e.length; r !== s; ++r) {
          const s = e[r],
            o = n[s.id];
          !1 !== o.needsUpdate && s.setValue(t, o.value, i);
        }
      }),
      (Xo.seqWithValue = function (t, e) {
        const n = [];
        for (let i = 0, r = t.length; i !== r; ++i) {
          const r = t[i];
          r.id in e && n.push(r);
        }
        return n;
      });
    let Yo = 0;
    function Zo(t) {
      switch (t) {
        case We:
          return ["Linear", "( value )"];
        case Ge:
          return ["sRGB", "( value )"];
        default:
          return (
            console.warn("THREE.WebGLProgram: Unsupported encoding:", t),
            ["Linear", "( value )"]
          );
      }
    }
    function Qo(t, e, n) {
      const i = t.getShaderParameter(e, 35713),
        r = t.getShaderInfoLog(e).trim();
      return i && "" === r
        ? ""
        : n.toUpperCase() +
            "\n\n" +
            r +
            "\n\n" +
            (function (t) {
              const e = t.split("\n");
              for (let t = 0; t < e.length; t++) e[t] = t + 1 + ": " + e[t];
              return e.join("\n");
            })(t.getShaderSource(e));
    }
    function Ko(t, e) {
      const n = Zo(e);
      return (
        "vec4 " +
        t +
        "( vec4 value ) { return " +
        n[0] +
        "ToLinear" +
        n[1] +
        "; }"
      );
    }
    function ta(t, e) {
      const n = Zo(e);
      return (
        "vec4 " + t + "( vec4 value ) { return LinearTo" + n[0] + n[1] + "; }"
      );
    }
    function ea(t, e) {
      let n;
      switch (e) {
        case tt:
          n = "Linear";
          break;
        case et:
          n = "Reinhard";
          break;
        case nt:
          n = "OptimizedCineon";
          break;
        case it:
          n = "ACESFilmic";
          break;
        case rt:
          n = "Custom";
          break;
        default:
          console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e),
            (n = "Linear");
      }
      return (
        "vec3 " + t + "( vec3 color ) { return " + n + "ToneMapping( color ); }"
      );
    }
    function na(t) {
      return "" !== t;
    }
    function ia(t, e) {
      return t
        .replace(/NUM_DIR_LIGHTS/g, e.numDirLights)
        .replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights)
        .replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights)
        .replace(/NUM_POINT_LIGHTS/g, e.numPointLights)
        .replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights)
        .replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows)
        .replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows)
        .replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
    }
    function ra(t, e) {
      return t
        .replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes)
        .replace(
          /UNION_CLIPPING_PLANES/g,
          e.numClippingPlanes - e.numClipIntersection
        );
    }
    const sa = /^[ \t]*#include +<([\w\d./]+)>/gm;
    function oa(t) {
      return t.replace(sa, aa);
    }
    function aa(t, e) {
      const n = Zr[e];
      if (void 0 === n) throw new Error("Can not resolve #include <" + e + ">");
      return oa(n);
    }
    const la =
        /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,
      ca =
        /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
    function ua(t) {
      return t.replace(ca, da).replace(la, ha);
    }
    function ha(t, e, n, i) {
      return (
        console.warn(
          "WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."
        ),
        da(t, e, n, i)
      );
    }
    function da(t, e, n, i) {
      let r = "";
      for (let t = parseInt(e); t < parseInt(n); t++)
        r += i
          .replace(/\[\s*i\s*\]/g, "[ " + t + " ]")
          .replace(/UNROLLED_LOOP_INDEX/g, t);
      return r;
    }
    function pa(t) {
      let e =
        "precision " +
        t.precision +
        " float;\nprecision " +
        t.precision +
        " int;";
      return (
        "highp" === t.precision
          ? (e += "\n#define HIGH_PRECISION")
          : "mediump" === t.precision
          ? (e += "\n#define MEDIUM_PRECISION")
          : "lowp" === t.precision && (e += "\n#define LOW_PRECISION"),
        e
      );
    }
    function fa(t, e, n, i) {
      const r = t.getContext(),
        s = n.defines;
      let o = n.vertexShader,
        a = n.fragmentShader;
      const l = (function (t) {
          let e = "SHADOWMAP_TYPE_BASIC";
          return (
            t.shadowMapType === d
              ? (e = "SHADOWMAP_TYPE_PCF")
              : t.shadowMapType === p
              ? (e = "SHADOWMAP_TYPE_PCF_SOFT")
              : t.shadowMapType === f && (e = "SHADOWMAP_TYPE_VSM"),
            e
          );
        })(n),
        c = (function (t) {
          let e = "ENVMAP_TYPE_CUBE";
          if (t.envMap)
            switch (t.envMapMode) {
              case ot:
              case at:
                e = "ENVMAP_TYPE_CUBE";
                break;
              case ut:
              case ht:
                e = "ENVMAP_TYPE_CUBE_UV";
            }
          return e;
        })(n),
        u = (function (t) {
          let e = "ENVMAP_MODE_REFLECTION";
          if (t.envMap)
            switch (t.envMapMode) {
              case at:
              case ht:
                e = "ENVMAP_MODE_REFRACTION";
            }
          return e;
        })(n),
        h = (function (t) {
          let e = "ENVMAP_BLENDING_NONE";
          if (t.envMap)
            switch (t.combine) {
              case Y:
                e = "ENVMAP_BLENDING_MULTIPLY";
                break;
              case Z:
                e = "ENVMAP_BLENDING_MIX";
                break;
              case Q:
                e = "ENVMAP_BLENDING_ADD";
            }
          return e;
        })(n),
        m = n.isWebGL2
          ? ""
          : (function (t) {
              return [
                t.extensionDerivatives ||
                t.envMapCubeUV ||
                t.bumpMap ||
                t.tangentSpaceNormalMap ||
                t.clearcoatNormalMap ||
                t.flatShading ||
                "physical" === t.shaderID
                  ? "#extension GL_OES_standard_derivatives : enable"
                  : "",
                (t.extensionFragDepth || t.logarithmicDepthBuffer) &&
                t.rendererExtensionFragDepth
                  ? "#extension GL_EXT_frag_depth : enable"
                  : "",
                t.extensionDrawBuffers && t.rendererExtensionDrawBuffers
                  ? "#extension GL_EXT_draw_buffers : require"
                  : "",
                (t.extensionShaderTextureLOD || t.envMap || t.transmission) &&
                t.rendererExtensionShaderTextureLod
                  ? "#extension GL_EXT_shader_texture_lod : enable"
                  : "",
              ]
                .filter(na)
                .join("\n");
            })(n),
        g = (function (t) {
          const e = [];
          for (const n in t) {
            const i = t[n];
            !1 !== i && e.push("#define " + n + " " + i);
          }
          return e.join("\n");
        })(s),
        v = r.createProgram();
      let y,
        x,
        b = n.glslVersion ? "#version " + n.glslVersion + "\n" : "";
      n.isRawShaderMaterial
        ? ((y = [g].filter(na).join("\n")),
          y.length > 0 && (y += "\n"),
          (x = [m, g].filter(na).join("\n")),
          x.length > 0 && (x += "\n"))
        : ((y = [
            pa(n),
            "#define SHADER_NAME " + n.shaderName,
            g,
            n.instancing ? "#define USE_INSTANCING" : "",
            n.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
            n.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "",
            "#define MAX_BONES " + n.maxBones,
            n.useFog && n.fog ? "#define USE_FOG" : "",
            n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "",
            n.map ? "#define USE_MAP" : "",
            n.envMap ? "#define USE_ENVMAP" : "",
            n.envMap ? "#define " + u : "",
            n.lightMap ? "#define USE_LIGHTMAP" : "",
            n.aoMap ? "#define USE_AOMAP" : "",
            n.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
            n.bumpMap ? "#define USE_BUMPMAP" : "",
            n.normalMap ? "#define USE_NORMALMAP" : "",
            n.normalMap && n.objectSpaceNormalMap
              ? "#define OBJECTSPACE_NORMALMAP"
              : "",
            n.normalMap && n.tangentSpaceNormalMap
              ? "#define TANGENTSPACE_NORMALMAP"
              : "",
            n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
            n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
            n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
            n.displacementMap && n.supportsVertexTextures
              ? "#define USE_DISPLACEMENTMAP"
              : "",
            n.specularMap ? "#define USE_SPECULARMAP" : "",
            n.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "",
            n.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "",
            n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
            n.metalnessMap ? "#define USE_METALNESSMAP" : "",
            n.alphaMap ? "#define USE_ALPHAMAP" : "",
            n.transmission ? "#define USE_TRANSMISSION" : "",
            n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
            n.thicknessMap ? "#define USE_THICKNESSMAP" : "",
            n.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "",
            n.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "",
            n.vertexTangents ? "#define USE_TANGENT" : "",
            n.vertexColors ? "#define USE_COLOR" : "",
            n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
            n.vertexUvs ? "#define USE_UV" : "",
            n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
            n.flatShading ? "#define FLAT_SHADED" : "",
            n.skinning ? "#define USE_SKINNING" : "",
            n.useVertexTexture ? "#define BONE_TEXTURE" : "",
            n.morphTargets ? "#define USE_MORPHTARGETS" : "",
            n.morphNormals && !1 === n.flatShading
              ? "#define USE_MORPHNORMALS"
              : "",
            n.morphTargets && n.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "",
            n.morphTargets && n.isWebGL2
              ? "#define MORPHTARGETS_COUNT " + n.morphTargetsCount
              : "",
            n.doubleSided ? "#define DOUBLE_SIDED" : "",
            n.flipSided ? "#define FLIP_SIDED" : "",
            n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
            n.shadowMapEnabled ? "#define " + l : "",
            n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
            n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
            n.logarithmicDepthBuffer && n.rendererExtensionFragDepth
              ? "#define USE_LOGDEPTHBUF_EXT"
              : "",
            "uniform mat4 modelMatrix;",
            "uniform mat4 modelViewMatrix;",
            "uniform mat4 projectionMatrix;",
            "uniform mat4 viewMatrix;",
            "uniform mat3 normalMatrix;",
            "uniform vec3 cameraPosition;",
            "uniform bool isOrthographic;",
            "#ifdef USE_INSTANCING",
            "\tattribute mat4 instanceMatrix;",
            "#endif",
            "#ifdef USE_INSTANCING_COLOR",
            "\tattribute vec3 instanceColor;",
            "#endif",
            "attribute vec3 position;",
            "attribute vec3 normal;",
            "attribute vec2 uv;",
            "#ifdef USE_TANGENT",
            "\tattribute vec4 tangent;",
            "#endif",
            "#if defined( USE_COLOR_ALPHA )",
            "\tattribute vec4 color;",
            "#elif defined( USE_COLOR )",
            "\tattribute vec3 color;",
            "#endif",
            "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )",
            "\tattribute vec3 morphTarget0;",
            "\tattribute vec3 morphTarget1;",
            "\tattribute vec3 morphTarget2;",
            "\tattribute vec3 morphTarget3;",
            "\t#ifdef USE_MORPHNORMALS",
            "\t\tattribute vec3 morphNormal0;",
            "\t\tattribute vec3 morphNormal1;",
            "\t\tattribute vec3 morphNormal2;",
            "\t\tattribute vec3 morphNormal3;",
            "\t#else",
            "\t\tattribute vec3 morphTarget4;",
            "\t\tattribute vec3 morphTarget5;",
            "\t\tattribute vec3 morphTarget6;",
            "\t\tattribute vec3 morphTarget7;",
            "\t#endif",
            "#endif",
            "#ifdef USE_SKINNING",
            "\tattribute vec4 skinIndex;",
            "\tattribute vec4 skinWeight;",
            "#endif",
            "\n",
          ]
            .filter(na)
            .join("\n")),
          (x = [
            m,
            pa(n),
            "#define SHADER_NAME " + n.shaderName,
            g,
            n.useFog && n.fog ? "#define USE_FOG" : "",
            n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "",
            n.map ? "#define USE_MAP" : "",
            n.matcap ? "#define USE_MATCAP" : "",
            n.envMap ? "#define USE_ENVMAP" : "",
            n.envMap ? "#define " + c : "",
            n.envMap ? "#define " + u : "",
            n.envMap ? "#define " + h : "",
            n.lightMap ? "#define USE_LIGHTMAP" : "",
            n.aoMap ? "#define USE_AOMAP" : "",
            n.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
            n.bumpMap ? "#define USE_BUMPMAP" : "",
            n.normalMap ? "#define USE_NORMALMAP" : "",
            n.normalMap && n.objectSpaceNormalMap
              ? "#define OBJECTSPACE_NORMALMAP"
              : "",
            n.normalMap && n.tangentSpaceNormalMap
              ? "#define TANGENTSPACE_NORMALMAP"
              : "",
            n.clearcoat ? "#define USE_CLEARCOAT" : "",
            n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
            n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
            n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
            n.specularMap ? "#define USE_SPECULARMAP" : "",
            n.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "",
            n.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "",
            n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
            n.metalnessMap ? "#define USE_METALNESSMAP" : "",
            n.alphaMap ? "#define USE_ALPHAMAP" : "",
            n.alphaTest ? "#define USE_ALPHATEST" : "",
            n.sheen ? "#define USE_SHEEN" : "",
            n.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "",
            n.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "",
            n.transmission ? "#define USE_TRANSMISSION" : "",
            n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
            n.thicknessMap ? "#define USE_THICKNESSMAP" : "",
            n.vertexTangents ? "#define USE_TANGENT" : "",
            n.vertexColors || n.instancingColor ? "#define USE_COLOR" : "",
            n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
            n.vertexUvs ? "#define USE_UV" : "",
            n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
            n.gradientMap ? "#define USE_GRADIENTMAP" : "",
            n.flatShading ? "#define FLAT_SHADED" : "",
            n.doubleSided ? "#define DOUBLE_SIDED" : "",
            n.flipSided ? "#define FLIP_SIDED" : "",
            n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
            n.shadowMapEnabled ? "#define " + l : "",
            n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
            n.physicallyCorrectLights
              ? "#define PHYSICALLY_CORRECT_LIGHTS"
              : "",
            n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
            n.logarithmicDepthBuffer && n.rendererExtensionFragDepth
              ? "#define USE_LOGDEPTHBUF_EXT"
              : "",
            (n.extensionShaderTextureLOD || n.envMap) &&
            n.rendererExtensionShaderTextureLod
              ? "#define TEXTURE_LOD_EXT"
              : "",
            "uniform mat4 viewMatrix;",
            "uniform vec3 cameraPosition;",
            "uniform bool isOrthographic;",
            n.toneMapping !== K ? "#define TONE_MAPPING" : "",
            n.toneMapping !== K ? Zr.tonemapping_pars_fragment : "",
            n.toneMapping !== K ? ea("toneMapping", n.toneMapping) : "",
            n.dithering ? "#define DITHERING" : "",
            n.format === It ? "#define OPAQUE" : "",
            Zr.encodings_pars_fragment,
            n.map ? Ko("mapTexelToLinear", n.mapEncoding) : "",
            n.matcap ? Ko("matcapTexelToLinear", n.matcapEncoding) : "",
            n.envMap ? Ko("envMapTexelToLinear", n.envMapEncoding) : "",
            n.emissiveMap
              ? Ko("emissiveMapTexelToLinear", n.emissiveMapEncoding)
              : "",
            n.specularColorMap
              ? Ko("specularColorMapTexelToLinear", n.specularColorMapEncoding)
              : "",
            n.sheenColorMap
              ? Ko("sheenColorMapTexelToLinear", n.sheenColorMapEncoding)
              : "",
            n.lightMap ? Ko("lightMapTexelToLinear", n.lightMapEncoding) : "",
            ta("linearToOutputTexel", n.outputEncoding),
            n.depthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "",
            "\n",
          ]
            .filter(na)
            .join("\n"))),
        (o = oa(o)),
        (o = ia(o, n)),
        (o = ra(o, n)),
        (a = oa(a)),
        (a = ia(a, n)),
        (a = ra(a, n)),
        (o = ua(o)),
        (a = ua(a)),
        n.isWebGL2 &&
          !0 !== n.isRawShaderMaterial &&
          ((b = "#version 300 es\n"),
          (y =
            [
              "precision mediump sampler2DArray;",
              "#define attribute in",
              "#define varying out",
              "#define texture2D texture",
            ].join("\n") +
            "\n" +
            y),
          (x =
            [
              "#define varying in",
              n.glslVersion === Ke
                ? ""
                : "layout(location = 0) out highp vec4 pc_fragColor;",
              n.glslVersion === Ke ? "" : "#define gl_FragColor pc_fragColor",
              "#define gl_FragDepthEXT gl_FragDepth",
              "#define texture2D texture",
              "#define textureCube texture",
              "#define texture2DProj textureProj",
              "#define texture2DLodEXT textureLod",
              "#define texture2DProjLodEXT textureProjLod",
              "#define textureCubeLodEXT textureLod",
              "#define texture2DGradEXT textureGrad",
              "#define texture2DProjGradEXT textureProjGrad",
              "#define textureCubeGradEXT textureGrad",
            ].join("\n") +
            "\n" +
            x));
      const _ = b + x + a,
        w = Jo(r, 35633, b + y + o),
        S = Jo(r, 35632, _);
      if (
        (r.attachShader(v, w),
        r.attachShader(v, S),
        void 0 !== n.index0AttributeName
          ? r.bindAttribLocation(v, 0, n.index0AttributeName)
          : !0 === n.morphTargets && r.bindAttribLocation(v, 0, "position"),
        r.linkProgram(v),
        t.debug.checkShaderErrors)
      ) {
        const t = r.getProgramInfoLog(v).trim(),
          e = r.getShaderInfoLog(w).trim(),
          n = r.getShaderInfoLog(S).trim();
        let i = !0,
          s = !0;
        if (!1 === r.getProgramParameter(v, 35714)) {
          i = !1;
          const e = Qo(r, w, "vertex"),
            n = Qo(r, S, "fragment");
          console.error(
            "THREE.WebGLProgram: Shader Error " +
              r.getError() +
              " - VALIDATE_STATUS " +
              r.getProgramParameter(v, 35715) +
              "\n\nProgram Info Log: " +
              t +
              "\n" +
              e +
              "\n" +
              n
          );
        } else
          "" !== t
            ? console.warn("THREE.WebGLProgram: Program Info Log:", t)
            : ("" !== e && "" !== n) || (s = !1);
        s &&
          (this.diagnostics = {
            runnable: i,
            programLog: t,
            vertexShader: { log: e, prefix: y },
            fragmentShader: { log: n, prefix: x },
          });
      }
      let M, T;
      return (
        r.deleteShader(w),
        r.deleteShader(S),
        (this.getUniforms = function () {
          return void 0 === M && (M = new Xo(r, v)), M;
        }),
        (this.getAttributes = function () {
          return (
            void 0 === T &&
              (T = (function (t, e) {
                const n = {},
                  i = t.getProgramParameter(e, 35721);
                for (let r = 0; r < i; r++) {
                  const i = t.getActiveAttrib(e, r),
                    s = i.name;
                  let o = 1;
                  35674 === i.type && (o = 2),
                    35675 === i.type && (o = 3),
                    35676 === i.type && (o = 4),
                    (n[s] = {
                      type: i.type,
                      location: t.getAttribLocation(e, s),
                      locationSize: o,
                    });
                }
                return n;
              })(r, v)),
            T
          );
        }),
        (this.destroy = function () {
          i.releaseStatesOfProgram(this),
            r.deleteProgram(v),
            (this.program = void 0);
        }),
        (this.name = n.shaderName),
        (this.id = Yo++),
        (this.cacheKey = e),
        (this.usedTimes = 1),
        (this.program = v),
        (this.vertexShader = w),
        (this.fragmentShader = S),
        this
      );
    }
    let ma = 0;
    class ga {
      constructor() {
        (this.shaderCache = new Map()), (this.materialCache = new Map());
      }
      update(t) {
        const e = t.vertexShader,
          n = t.fragmentShader,
          i = this._getShaderStage(e),
          r = this._getShaderStage(n),
          s = this._getShaderCacheForMaterial(t);
        return (
          !1 === s.has(i) && (s.add(i), i.usedTimes++),
          !1 === s.has(r) && (s.add(r), r.usedTimes++),
          this
        );
      }
      remove(t) {
        const e = this.materialCache.get(t);
        for (const t of e)
          t.usedTimes--, 0 === t.usedTimes && this.shaderCache.delete(t);
        return this.materialCache.delete(t), this;
      }
      getVertexShaderID(t) {
        return this._getShaderStage(t.vertexShader).id;
      }
      getFragmentShaderID(t) {
        return this._getShaderStage(t.fragmentShader).id;
      }
      dispose() {
        this.shaderCache.clear(), this.materialCache.clear();
      }
      _getShaderCacheForMaterial(t) {
        const e = this.materialCache;
        return !1 === e.has(t) && e.set(t, new Set()), e.get(t);
      }
      _getShaderStage(t) {
        const e = this.shaderCache;
        if (!1 === e.has(t)) {
          const n = new va();
          e.set(t, n);
        }
        return e.get(t);
      }
    }
    class va {
      constructor() {
        (this.id = ma++), (this.usedTimes = 0);
      }
    }
    function ya(t, e, n, i, r, s, o) {
      const a = new di(),
        l = new ga(),
        c = [],
        u = r.isWebGL2,
        h = r.logarithmicDepthBuffer,
        d = r.floatVertexTextures,
        p = r.maxVertexUniforms,
        f = r.vertexTextures;
      let m = r.precision;
      const y = {
        MeshDepthMaterial: "depth",
        MeshDistanceMaterial: "distanceRGBA",
        MeshNormalMaterial: "normal",
        MeshBasicMaterial: "basic",
        MeshLambertMaterial: "lambert",
        MeshPhongMaterial: "phong",
        MeshToonMaterial: "toon",
        MeshStandardMaterial: "physical",
        MeshPhysicalMaterial: "physical",
        MeshMatcapMaterial: "matcap",
        LineBasicMaterial: "basic",
        LineDashedMaterial: "dashed",
        PointsMaterial: "points",
        ShadowMaterial: "shadow",
        SpriteMaterial: "sprite",
      };
      function x(t) {
        let e;
        return (
          t && t.isTexture
            ? (e = t.encoding)
            : t && t.isWebGLRenderTarget
            ? (console.warn(
                "THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."
              ),
              (e = t.texture.encoding))
            : (e = We),
          u &&
            t &&
            t.isTexture &&
            t.format === Nt &&
            t.type === _t &&
            t.encoding === Ge &&
            (e = We),
          e
        );
      }
      return {
        getParameters: function (s, a, c, b, _) {
          const w = b.fog,
            S = s.isMeshStandardMaterial ? b.environment : null,
            M = (s.isMeshStandardMaterial ? n : e).get(s.envMap || S),
            T = y[s.type],
            E = _.isSkinnedMesh
              ? (function (t) {
                  const e = t.skeleton.bones;
                  if (d) return 1024;
                  {
                    const t = p,
                      n = Math.floor((t - 20) / 4),
                      i = Math.min(n, e.length);
                    return i < e.length
                      ? (console.warn(
                          "THREE.WebGLRenderer: Skeleton has " +
                            e.length +
                            " bones. This GPU supports " +
                            i +
                            "."
                        ),
                        0)
                      : i;
                  }
                })(_)
              : 0;
          let A, C, L, R;
          if (
            (null !== s.precision &&
              ((m = r.getMaxPrecision(s.precision)),
              m !== s.precision &&
                console.warn(
                  "THREE.WebGLProgram.getParameters:",
                  s.precision,
                  "not supported, using",
                  m,
                  "instead."
                )),
            T)
          ) {
            const t = Kr[T];
            (A = t.vertexShader), (C = t.fragmentShader);
          } else
            (A = s.vertexShader),
              (C = s.fragmentShader),
              l.update(s),
              (L = l.getVertexShaderID(s)),
              (R = l.getFragmentShaderID(s));
          const P = t.getRenderTarget(),
            D = s.alphaTest > 0,
            k = s.clearcoat > 0;
          return {
            isWebGL2: u,
            shaderID: T,
            shaderName: s.type,
            vertexShader: A,
            fragmentShader: C,
            defines: s.defines,
            customVertexShaderID: L,
            customFragmentShaderID: R,
            isRawShaderMaterial: !0 === s.isRawShaderMaterial,
            glslVersion: s.glslVersion,
            precision: m,
            instancing: !0 === _.isInstancedMesh,
            instancingColor:
              !0 === _.isInstancedMesh && null !== _.instanceColor,
            supportsVertexTextures: f,
            outputEncoding: null !== P ? x(P.texture) : t.outputEncoding,
            map: !!s.map,
            mapEncoding: x(s.map),
            matcap: !!s.matcap,
            matcapEncoding: x(s.matcap),
            envMap: !!M,
            envMapMode: M && M.mapping,
            envMapEncoding: x(M),
            envMapCubeUV: !!M && (M.mapping === ut || M.mapping === ht),
            lightMap: !!s.lightMap,
            lightMapEncoding: x(s.lightMap),
            aoMap: !!s.aoMap,
            emissiveMap: !!s.emissiveMap,
            emissiveMapEncoding: x(s.emissiveMap),
            bumpMap: !!s.bumpMap,
            normalMap: !!s.normalMap,
            objectSpaceNormalMap: s.normalMapType === Xe,
            tangentSpaceNormalMap: s.normalMapType === $e,
            clearcoat: k,
            clearcoatMap: k && !!s.clearcoatMap,
            clearcoatRoughnessMap: k && !!s.clearcoatRoughnessMap,
            clearcoatNormalMap: k && !!s.clearcoatNormalMap,
            displacementMap: !!s.displacementMap,
            roughnessMap: !!s.roughnessMap,
            metalnessMap: !!s.metalnessMap,
            specularMap: !!s.specularMap,
            specularIntensityMap: !!s.specularIntensityMap,
            specularColorMap: !!s.specularColorMap,
            specularColorMapEncoding: x(s.specularColorMap),
            alphaMap: !!s.alphaMap,
            alphaTest: D,
            gradientMap: !!s.gradientMap,
            sheen: s.sheen > 0,
            sheenColorMap: !!s.sheenColorMap,
            sheenColorMapEncoding: x(s.sheenColorMap),
            sheenRoughnessMap: !!s.sheenRoughnessMap,
            transmission: s.transmission > 0,
            transmissionMap: !!s.transmissionMap,
            thicknessMap: !!s.thicknessMap,
            combine: s.combine,
            vertexTangents:
              !!s.normalMap && !!_.geometry && !!_.geometry.attributes.tangent,
            vertexColors: s.vertexColors,
            vertexAlphas:
              !0 === s.vertexColors &&
              !!_.geometry &&
              !!_.geometry.attributes.color &&
              4 === _.geometry.attributes.color.itemSize,
            vertexUvs: !!(
              s.map ||
              s.bumpMap ||
              s.normalMap ||
              s.specularMap ||
              s.alphaMap ||
              s.emissiveMap ||
              s.roughnessMap ||
              s.metalnessMap ||
              s.clearcoatMap ||
              s.clearcoatRoughnessMap ||
              s.clearcoatNormalMap ||
              s.displacementMap ||
              s.transmissionMap ||
              s.thicknessMap ||
              s.specularIntensityMap ||
              s.specularColorMap ||
              s.sheenColorMap ||
              s.sheenRoughnessMap
            ),
            uvsVertexOnly: !(
              s.map ||
              s.bumpMap ||
              s.normalMap ||
              s.specularMap ||
              s.alphaMap ||
              s.emissiveMap ||
              s.roughnessMap ||
              s.metalnessMap ||
              s.clearcoatNormalMap ||
              s.transmission > 0 ||
              s.transmissionMap ||
              s.thicknessMap ||
              s.specularIntensityMap ||
              s.specularColorMap ||
              s.sheen > 0 ||
              s.sheenColorMap ||
              s.sheenRoughnessMap ||
              !s.displacementMap
            ),
            fog: !!w,
            useFog: s.fog,
            fogExp2: w && w.isFogExp2,
            flatShading: !!s.flatShading,
            sizeAttenuation: s.sizeAttenuation,
            logarithmicDepthBuffer: h,
            skinning: !0 === _.isSkinnedMesh && E > 0,
            maxBones: E,
            useVertexTexture: d,
            morphTargets: !!_.geometry && !!_.geometry.morphAttributes.position,
            morphNormals: !!_.geometry && !!_.geometry.morphAttributes.normal,
            morphTargetsCount:
              _.geometry && _.geometry.morphAttributes.position
                ? _.geometry.morphAttributes.position.length
                : 0,
            numDirLights: a.directional.length,
            numPointLights: a.point.length,
            numSpotLights: a.spot.length,
            numRectAreaLights: a.rectArea.length,
            numHemiLights: a.hemi.length,
            numDirLightShadows: a.directionalShadowMap.length,
            numPointLightShadows: a.pointShadowMap.length,
            numSpotLightShadows: a.spotShadowMap.length,
            numClippingPlanes: o.numPlanes,
            numClipIntersection: o.numIntersection,
            format: s.format,
            dithering: s.dithering,
            shadowMapEnabled: t.shadowMap.enabled && c.length > 0,
            shadowMapType: t.shadowMap.type,
            toneMapping: s.toneMapped ? t.toneMapping : K,
            physicallyCorrectLights: t.physicallyCorrectLights,
            premultipliedAlpha: s.premultipliedAlpha,
            doubleSided: s.side === v,
            flipSided: s.side === g,
            depthPacking: void 0 !== s.depthPacking && s.depthPacking,
            index0AttributeName: s.index0AttributeName,
            extensionDerivatives: s.extensions && s.extensions.derivatives,
            extensionFragDepth: s.extensions && s.extensions.fragDepth,
            extensionDrawBuffers: s.extensions && s.extensions.drawBuffers,
            extensionShaderTextureLOD:
              s.extensions && s.extensions.shaderTextureLOD,
            rendererExtensionFragDepth: u || i.has("EXT_frag_depth"),
            rendererExtensionDrawBuffers: u || i.has("WEBGL_draw_buffers"),
            rendererExtensionShaderTextureLod:
              u || i.has("EXT_shader_texture_lod"),
            customProgramCacheKey: s.customProgramCacheKey(),
          };
        },
        getProgramCacheKey: function (e) {
          const n = [];
          if (
            (e.shaderID
              ? n.push(e.shaderID)
              : (n.push(e.customVertexShaderID),
                n.push(e.customFragmentShaderID)),
            void 0 !== e.defines)
          )
            for (const t in e.defines) n.push(t), n.push(e.defines[t]);
          return (
            !1 === e.isRawShaderMaterial &&
              (!(function (t, e) {
                t.push(e.precision),
                  t.push(e.outputEncoding),
                  t.push(e.mapEncoding),
                  t.push(e.matcapEncoding),
                  t.push(e.envMapMode),
                  t.push(e.envMapEncoding),
                  t.push(e.lightMapEncoding),
                  t.push(e.emissiveMapEncoding),
                  t.push(e.combine),
                  t.push(e.vertexUvs),
                  t.push(e.fogExp2),
                  t.push(e.sizeAttenuation),
                  t.push(e.maxBones),
                  t.push(e.morphTargetsCount),
                  t.push(e.numDirLights),
                  t.push(e.numPointLights),
                  t.push(e.numSpotLights),
                  t.push(e.numHemiLights),
                  t.push(e.numRectAreaLights),
                  t.push(e.numDirLightShadows),
                  t.push(e.numPointLightShadows),
                  t.push(e.numSpotLightShadows),
                  t.push(e.shadowMapType),
                  t.push(e.toneMapping),
                  t.push(e.numClippingPlanes),
                  t.push(e.numClipIntersection),
                  t.push(e.format),
                  t.push(e.specularColorMapEncoding),
                  t.push(e.sheenColorMapEncoding);
              })(n, e),
              (function (t, e) {
                a.disableAll(), e.isWebGL2 && a.enable(0);
                e.supportsVertexTextures && a.enable(1);
                e.instancing && a.enable(2);
                e.instancingColor && a.enable(3);
                e.map && a.enable(4);
                e.matcap && a.enable(5);
                e.envMap && a.enable(6);
                e.envMapCubeUV && a.enable(7);
                e.lightMap && a.enable(8);
                e.aoMap && a.enable(9);
                e.emissiveMap && a.enable(10);
                e.bumpMap && a.enable(11);
                e.normalMap && a.enable(12);
                e.objectSpaceNormalMap && a.enable(13);
                e.tangentSpaceNormalMap && a.enable(14);
                e.clearcoat && a.enable(15);
                e.clearcoatMap && a.enable(16);
                e.clearcoatRoughnessMap && a.enable(17);
                e.clearcoatNormalMap && a.enable(18);
                e.displacementMap && a.enable(19);
                e.specularMap && a.enable(20);
                e.roughnessMap && a.enable(21);
                e.metalnessMap && a.enable(22);
                e.gradientMap && a.enable(23);
                e.alphaMap && a.enable(24);
                e.alphaTest && a.enable(25);
                e.vertexColors && a.enable(26);
                e.vertexAlphas && a.enable(27);
                e.vertexUvs && a.enable(28);
                e.vertexTangents && a.enable(29);
                e.uvsVertexOnly && a.enable(30);
                e.fog && a.enable(31);
                t.push(a.mask), a.disableAll(), e.useFog && a.enable(0);
                e.flatShading && a.enable(1);
                e.logarithmicDepthBuffer && a.enable(2);
                e.skinning && a.enable(3);
                e.useVertexTexture && a.enable(4);
                e.morphTargets && a.enable(5);
                e.morphNormals && a.enable(6);
                e.premultipliedAlpha && a.enable(7);
                e.shadowMapEnabled && a.enable(8);
                e.physicallyCorrectLights && a.enable(9);
                e.doubleSided && a.enable(10);
                e.flipSided && a.enable(11);
                e.depthPacking && a.enable(12);
                e.dithering && a.enable(13);
                e.specularIntensityMap && a.enable(14);
                e.specularColorMap && a.enable(15);
                e.transmission && a.enable(16);
                e.transmissionMap && a.enable(17);
                e.thicknessMap && a.enable(18);
                e.sheen && a.enable(19);
                e.sheenColorMap && a.enable(20);
                e.sheenRoughnessMap && a.enable(21);
                t.push(a.mask);
              })(n, e),
              n.push(t.outputEncoding)),
            n.push(e.customProgramCacheKey),
            n.join()
          );
        },
        getUniforms: function (t) {
          const e = y[t.type];
          let n;
          if (e) {
            const t = Kr[e];
            n = Rr.clone(t.uniforms);
          } else n = t.uniforms;
          return n;
        },
        acquireProgram: function (e, n) {
          let i;
          for (let t = 0, e = c.length; t < e; t++) {
            const e = c[t];
            if (e.cacheKey === n) {
              (i = e), ++i.usedTimes;
              break;
            }
          }
          return void 0 === i && ((i = new fa(t, n, e, s)), c.push(i)), i;
        },
        releaseProgram: function (t) {
          if (0 == --t.usedTimes) {
            const e = c.indexOf(t);
            (c[e] = c[c.length - 1]), c.pop(), t.destroy();
          }
        },
        releaseShaderCache: function (t) {
          l.remove(t);
        },
        programs: c,
        dispose: function () {
          l.dispose();
        },
      };
    }
    function xa() {
      let t = new WeakMap();
      return {
        get: function (e) {
          let n = t.get(e);
          return void 0 === n && ((n = {}), t.set(e, n)), n;
        },
        remove: function (e) {
          t.delete(e);
        },
        update: function (e, n, i) {
          t.get(e)[n] = i;
        },
        dispose: function () {
          t = new WeakMap();
        },
      };
    }
    function ba(t, e) {
      return t.groupOrder !== e.groupOrder
        ? t.groupOrder - e.groupOrder
        : t.renderOrder !== e.renderOrder
        ? t.renderOrder - e.renderOrder
        : t.material.id !== e.material.id
        ? t.material.id - e.material.id
        : t.z !== e.z
        ? t.z - e.z
        : t.id - e.id;
    }
    function _a(t, e) {
      return t.groupOrder !== e.groupOrder
        ? t.groupOrder - e.groupOrder
        : t.renderOrder !== e.renderOrder
        ? t.renderOrder - e.renderOrder
        : t.z !== e.z
        ? e.z - t.z
        : t.id - e.id;
    }
    function wa() {
      const t = [];
      let e = 0;
      const n = [],
        i = [],
        r = [];
      function s(n, i, r, s, o, a) {
        let l = t[e];
        return (
          void 0 === l
            ? ((l = {
                id: n.id,
                object: n,
                geometry: i,
                material: r,
                groupOrder: s,
                renderOrder: n.renderOrder,
                z: o,
                group: a,
              }),
              (t[e] = l))
            : ((l.id = n.id),
              (l.object = n),
              (l.geometry = i),
              (l.material = r),
              (l.groupOrder = s),
              (l.renderOrder = n.renderOrder),
              (l.z = o),
              (l.group = a)),
          e++,
          l
        );
      }
      return {
        opaque: n,
        transmissive: i,
        transparent: r,
        init: function () {
          (e = 0), (n.length = 0), (i.length = 0), (r.length = 0);
        },
        push: function (t, e, o, a, l, c) {
          const u = s(t, e, o, a, l, c);
          o.transmission > 0
            ? i.push(u)
            : !0 === o.transparent
            ? r.push(u)
            : n.push(u);
        },
        unshift: function (t, e, o, a, l, c) {
          const u = s(t, e, o, a, l, c);
          o.transmission > 0
            ? i.unshift(u)
            : !0 === o.transparent
            ? r.unshift(u)
            : n.unshift(u);
        },
        finish: function () {
          for (let n = e, i = t.length; n < i; n++) {
            const e = t[n];
            if (null === e.id) break;
            (e.id = null),
              (e.object = null),
              (e.geometry = null),
              (e.material = null),
              (e.group = null);
          }
        },
        sort: function (t, e) {
          n.length > 1 && n.sort(t || ba),
            i.length > 1 && i.sort(e || _a),
            r.length > 1 && r.sort(e || _a);
        },
      };
    }
    function Sa() {
      let t = new WeakMap();
      return {
        get: function (e, n) {
          let i;
          return (
            !1 === t.has(e)
              ? ((i = new wa()), t.set(e, [i]))
              : n >= t.get(e).length
              ? ((i = new wa()), t.get(e).push(i))
              : (i = t.get(e)[n]),
            i
          );
        },
        dispose: function () {
          t = new WeakMap();
        },
      };
    }
    function Ma() {
      const t = {};
      return {
        get: function (e) {
          if (void 0 !== t[e.id]) return t[e.id];
          let n;
          switch (e.type) {
            case "DirectionalLight":
              n = { direction: new Mn(), color: new qi() };
              break;
            case "SpotLight":
              n = {
                position: new Mn(),
                direction: new Mn(),
                color: new qi(),
                distance: 0,
                coneCos: 0,
                penumbraCos: 0,
                decay: 0,
              };
              break;
            case "PointLight":
              n = {
                position: new Mn(),
                color: new qi(),
                distance: 0,
                decay: 0,
              };
              break;
            case "HemisphereLight":
              n = {
                direction: new Mn(),
                skyColor: new qi(),
                groundColor: new qi(),
              };
              break;
            case "RectAreaLight":
              n = {
                color: new qi(),
                position: new Mn(),
                halfWidth: new Mn(),
                halfHeight: new Mn(),
              };
          }
          return (t[e.id] = n), n;
        },
      };
    }
    let Ta = 0;
    function Ea(t, e) {
      return (e.castShadow ? 1 : 0) - (t.castShadow ? 1 : 0);
    }
    function Aa(t, e) {
      const n = new Ma(),
        i = (function () {
          const t = {};
          return {
            get: function (e) {
              if (void 0 !== t[e.id]) return t[e.id];
              let n;
              switch (e.type) {
                case "DirectionalLight":
                case "SpotLight":
                  n = {
                    shadowBias: 0,
                    shadowNormalBias: 0,
                    shadowRadius: 1,
                    shadowMapSize: new hn(),
                  };
                  break;
                case "PointLight":
                  n = {
                    shadowBias: 0,
                    shadowNormalBias: 0,
                    shadowRadius: 1,
                    shadowMapSize: new hn(),
                    shadowCameraNear: 1,
                    shadowCameraFar: 1e3,
                  };
              }
              return (t[e.id] = n), n;
            },
          };
        })(),
        r = {
          version: 0,
          hash: {
            directionalLength: -1,
            pointLength: -1,
            spotLength: -1,
            rectAreaLength: -1,
            hemiLength: -1,
            numDirectionalShadows: -1,
            numPointShadows: -1,
            numSpotShadows: -1,
          },
          ambient: [0, 0, 0],
          probe: [],
          directional: [],
          directionalShadow: [],
          directionalShadowMap: [],
          directionalShadowMatrix: [],
          spot: [],
          spotShadow: [],
          spotShadowMap: [],
          spotShadowMatrix: [],
          rectArea: [],
          rectAreaLTC1: null,
          rectAreaLTC2: null,
          point: [],
          pointShadow: [],
          pointShadowMap: [],
          pointShadowMatrix: [],
          hemi: [],
        };
      for (let t = 0; t < 9; t++) r.probe.push(new Mn());
      const s = new Mn(),
        o = new ei(),
        a = new ei();
      return {
        setup: function (s, o) {
          let a = 0,
            l = 0,
            c = 0;
          for (let t = 0; t < 9; t++) r.probe[t].set(0, 0, 0);
          let u = 0,
            h = 0,
            d = 0,
            p = 0,
            f = 0,
            m = 0,
            g = 0,
            v = 0;
          s.sort(Ea);
          const y = !0 !== o ? Math.PI : 1;
          for (let t = 0, e = s.length; t < e; t++) {
            const e = s[t],
              o = e.color,
              x = e.intensity,
              b = e.distance,
              _ = e.shadow && e.shadow.map ? e.shadow.map.texture : null;
            if (e.isAmbientLight)
              (a += o.r * x * y), (l += o.g * x * y), (c += o.b * x * y);
            else if (e.isLightProbe)
              for (let t = 0; t < 9; t++)
                r.probe[t].addScaledVector(e.sh.coefficients[t], x);
            else if (e.isDirectionalLight) {
              const t = n.get(e);
              if (
                (t.color.copy(e.color).multiplyScalar(e.intensity * y),
                e.castShadow)
              ) {
                const t = e.shadow,
                  n = i.get(e);
                (n.shadowBias = t.bias),
                  (n.shadowNormalBias = t.normalBias),
                  (n.shadowRadius = t.radius),
                  (n.shadowMapSize = t.mapSize),
                  (r.directionalShadow[u] = n),
                  (r.directionalShadowMap[u] = _),
                  (r.directionalShadowMatrix[u] = e.shadow.matrix),
                  m++;
              }
              (r.directional[u] = t), u++;
            } else if (e.isSpotLight) {
              const t = n.get(e);
              if (
                (t.position.setFromMatrixPosition(e.matrixWorld),
                t.color.copy(o).multiplyScalar(x * y),
                (t.distance = b),
                (t.coneCos = Math.cos(e.angle)),
                (t.penumbraCos = Math.cos(e.angle * (1 - e.penumbra))),
                (t.decay = e.decay),
                e.castShadow)
              ) {
                const t = e.shadow,
                  n = i.get(e);
                (n.shadowBias = t.bias),
                  (n.shadowNormalBias = t.normalBias),
                  (n.shadowRadius = t.radius),
                  (n.shadowMapSize = t.mapSize),
                  (r.spotShadow[d] = n),
                  (r.spotShadowMap[d] = _),
                  (r.spotShadowMatrix[d] = e.shadow.matrix),
                  v++;
              }
              (r.spot[d] = t), d++;
            } else if (e.isRectAreaLight) {
              const t = n.get(e);
              t.color.copy(o).multiplyScalar(x),
                t.halfWidth.set(0.5 * e.width, 0, 0),
                t.halfHeight.set(0, 0.5 * e.height, 0),
                (r.rectArea[p] = t),
                p++;
            } else if (e.isPointLight) {
              const t = n.get(e);
              if (
                (t.color.copy(e.color).multiplyScalar(e.intensity * y),
                (t.distance = e.distance),
                (t.decay = e.decay),
                e.castShadow)
              ) {
                const t = e.shadow,
                  n = i.get(e);
                (n.shadowBias = t.bias),
                  (n.shadowNormalBias = t.normalBias),
                  (n.shadowRadius = t.radius),
                  (n.shadowMapSize = t.mapSize),
                  (n.shadowCameraNear = t.camera.near),
                  (n.shadowCameraFar = t.camera.far),
                  (r.pointShadow[h] = n),
                  (r.pointShadowMap[h] = _),
                  (r.pointShadowMatrix[h] = e.shadow.matrix),
                  g++;
              }
              (r.point[h] = t), h++;
            } else if (e.isHemisphereLight) {
              const t = n.get(e);
              t.skyColor.copy(e.color).multiplyScalar(x * y),
                t.groundColor.copy(e.groundColor).multiplyScalar(x * y),
                (r.hemi[f] = t),
                f++;
            }
          }
          p > 0 &&
            (e.isWebGL2
              ? ((r.rectAreaLTC1 = Qr.LTC_FLOAT_1),
                (r.rectAreaLTC2 = Qr.LTC_FLOAT_2))
              : !0 === t.has("OES_texture_float_linear")
              ? ((r.rectAreaLTC1 = Qr.LTC_FLOAT_1),
                (r.rectAreaLTC2 = Qr.LTC_FLOAT_2))
              : !0 === t.has("OES_texture_half_float_linear")
              ? ((r.rectAreaLTC1 = Qr.LTC_HALF_1),
                (r.rectAreaLTC2 = Qr.LTC_HALF_2))
              : console.error(
                  "THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions."
                )),
            (r.ambient[0] = a),
            (r.ambient[1] = l),
            (r.ambient[2] = c);
          const x = r.hash;
          (x.directionalLength === u &&
            x.pointLength === h &&
            x.spotLength === d &&
            x.rectAreaLength === p &&
            x.hemiLength === f &&
            x.numDirectionalShadows === m &&
            x.numPointShadows === g &&
            x.numSpotShadows === v) ||
            ((r.directional.length = u),
            (r.spot.length = d),
            (r.rectArea.length = p),
            (r.point.length = h),
            (r.hemi.length = f),
            (r.directionalShadow.length = m),
            (r.directionalShadowMap.length = m),
            (r.pointShadow.length = g),
            (r.pointShadowMap.length = g),
            (r.spotShadow.length = v),
            (r.spotShadowMap.length = v),
            (r.directionalShadowMatrix.length = m),
            (r.pointShadowMatrix.length = g),
            (r.spotShadowMatrix.length = v),
            (x.directionalLength = u),
            (x.pointLength = h),
            (x.spotLength = d),
            (x.rectAreaLength = p),
            (x.hemiLength = f),
            (x.numDirectionalShadows = m),
            (x.numPointShadows = g),
            (x.numSpotShadows = v),
            (r.version = Ta++));
        },
        setupView: function (t, e) {
          let n = 0,
            i = 0,
            l = 0,
            c = 0,
            u = 0;
          const h = e.matrixWorldInverse;
          for (let e = 0, d = t.length; e < d; e++) {
            const d = t[e];
            if (d.isDirectionalLight) {
              const t = r.directional[n];
              t.direction.setFromMatrixPosition(d.matrixWorld),
                s.setFromMatrixPosition(d.target.matrixWorld),
                t.direction.sub(s),
                t.direction.transformDirection(h),
                n++;
            } else if (d.isSpotLight) {
              const t = r.spot[l];
              t.position.setFromMatrixPosition(d.matrixWorld),
                t.position.applyMatrix4(h),
                t.direction.setFromMatrixPosition(d.matrixWorld),
                s.setFromMatrixPosition(d.target.matrixWorld),
                t.direction.sub(s),
                t.direction.transformDirection(h),
                l++;
            } else if (d.isRectAreaLight) {
              const t = r.rectArea[c];
              t.position.setFromMatrixPosition(d.matrixWorld),
                t.position.applyMatrix4(h),
                a.identity(),
                o.copy(d.matrixWorld),
                o.premultiply(h),
                a.extractRotation(o),
                t.halfWidth.set(0.5 * d.width, 0, 0),
                t.halfHeight.set(0, 0.5 * d.height, 0),
                t.halfWidth.applyMatrix4(a),
                t.halfHeight.applyMatrix4(a),
                c++;
            } else if (d.isPointLight) {
              const t = r.point[i];
              t.position.setFromMatrixPosition(d.matrixWorld),
                t.position.applyMatrix4(h),
                i++;
            } else if (d.isHemisphereLight) {
              const t = r.hemi[u];
              t.direction.setFromMatrixPosition(d.matrixWorld),
                t.direction.transformDirection(h),
                t.direction.normalize(),
                u++;
            }
          }
        },
        state: r,
      };
    }
    function Ca(t, e) {
      const n = new Aa(t, e),
        i = [],
        r = [];
      return {
        init: function () {
          (i.length = 0), (r.length = 0);
        },
        state: { lightsArray: i, shadowsArray: r, lights: n },
        setupLights: function (t) {
          n.setup(i, t);
        },
        setupLightsView: function (t) {
          n.setupView(i, t);
        },
        pushLight: function (t) {
          i.push(t);
        },
        pushShadow: function (t) {
          r.push(t);
        },
      };
    }
    function La(t, e) {
      let n = new WeakMap();
      return {
        get: function (i, r = 0) {
          let s;
          return (
            !1 === n.has(i)
              ? ((s = new Ca(t, e)), n.set(i, [s]))
              : r >= n.get(i).length
              ? ((s = new Ca(t, e)), n.get(i).push(s))
              : (s = n.get(i)[r]),
            s
          );
        },
        dispose: function () {
          n = new WeakMap();
        },
      };
    }
    class Ra extends Bi {
      constructor(t) {
        super(),
          (this.type = "MeshDepthMaterial"),
          (this.depthPacking = je),
          (this.map = null),
          (this.alphaMap = null),
          (this.displacementMap = null),
          (this.displacementScale = 1),
          (this.displacementBias = 0),
          (this.wireframe = !1),
          (this.wireframeLinewidth = 1),
          (this.fog = !1),
          this.setValues(t);
      }
      copy(t) {
        return (
          super.copy(t),
          (this.depthPacking = t.depthPacking),
          (this.map = t.map),
          (this.alphaMap = t.alphaMap),
          (this.displacementMap = t.displacementMap),
          (this.displacementScale = t.displacementScale),
          (this.displacementBias = t.displacementBias),
          (this.wireframe = t.wireframe),
          (this.wireframeLinewidth = t.wireframeLinewidth),
          this
        );
      }
    }
    Ra.prototype.isMeshDepthMaterial = !0;
    class Pa extends Bi {
      constructor(t) {
        super(),
          (this.type = "MeshDistanceMaterial"),
          (this.referencePosition = new Mn()),
          (this.nearDistance = 1),
          (this.farDistance = 1e3),
          (this.map = null),
          (this.alphaMap = null),
          (this.displacementMap = null),
          (this.displacementScale = 1),
          (this.displacementBias = 0),
          (this.fog = !1),
          this.setValues(t);
      }
      copy(t) {
        return (
          super.copy(t),
          this.referencePosition.copy(t.referencePosition),
          (this.nearDistance = t.nearDistance),
          (this.farDistance = t.farDistance),
          (this.map = t.map),
          (this.alphaMap = t.alphaMap),
          (this.displacementMap = t.displacementMap),
          (this.displacementScale = t.displacementScale),
          (this.displacementBias = t.displacementBias),
          this
        );
      }
    }
    Pa.prototype.isMeshDistanceMaterial = !0;
    const Da = "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",
      ka =
        "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";
    function Ia(t, e, n) {
      let i = new $r();
      const r = new hn(),
        s = new hn(),
        o = new bn(),
        a = new Ra({ depthPacking: qe }),
        l = new Pa(),
        c = {},
        u = n.maxTextureSize,
        h = { 0: g, 1: m, 2: v },
        p = new kr({
          defines: { VSM_SAMPLES: 8 },
          uniforms: {
            shadow_pass: { value: null },
            resolution: { value: new hn() },
            radius: { value: 4 },
          },
          vertexShader: Da,
          fragmentShader: ka,
        }),
        y = p.clone();
      y.defines.HORIZONTAL_PASS = 1;
      const b = new ar();
      b.setAttribute(
        "position",
        new Yi(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3)
      );
      const _ = new Tr(b, p),
        w = this;
      function S(n, i) {
        const r = e.update(_);
        p.defines.VSM_SAMPLES !== n.blurSamples &&
          ((p.defines.VSM_SAMPLES = n.blurSamples),
          (y.defines.VSM_SAMPLES = n.blurSamples),
          (p.needsUpdate = !0),
          (y.needsUpdate = !0)),
          (p.uniforms.shadow_pass.value = n.map.texture),
          (p.uniforms.resolution.value = n.mapSize),
          (p.uniforms.radius.value = n.radius),
          t.setRenderTarget(n.mapPass),
          t.clear(),
          t.renderBufferDirect(i, null, r, p, _, null),
          (y.uniforms.shadow_pass.value = n.mapPass.texture),
          (y.uniforms.resolution.value = n.mapSize),
          (y.uniforms.radius.value = n.radius),
          t.setRenderTarget(n.map),
          t.clear(),
          t.renderBufferDirect(i, null, r, y, _, null);
      }
      function M(e, n, i, r, s, o, u) {
        let d = null;
        const p =
          !0 === r.isPointLight
            ? e.customDistanceMaterial
            : e.customDepthMaterial;
        if (
          ((d = void 0 !== p ? p : !0 === r.isPointLight ? l : a),
          (t.localClippingEnabled &&
            !0 === i.clipShadows &&
            0 !== i.clippingPlanes.length) ||
            (i.displacementMap && 0 !== i.displacementScale) ||
            (i.alphaMap && i.alphaTest > 0))
        ) {
          const t = d.uuid,
            e = i.uuid;
          let n = c[t];
          void 0 === n && ((n = {}), (c[t] = n));
          let r = n[e];
          void 0 === r && ((r = d.clone()), (n[e] = r)), (d = r);
        }
        return (
          (d.visible = i.visible),
          (d.wireframe = i.wireframe),
          (d.side =
            u === f
              ? null !== i.shadowSide
                ? i.shadowSide
                : i.side
              : null !== i.shadowSide
              ? i.shadowSide
              : h[i.side]),
          (d.alphaMap = i.alphaMap),
          (d.alphaTest = i.alphaTest),
          (d.clipShadows = i.clipShadows),
          (d.clippingPlanes = i.clippingPlanes),
          (d.clipIntersection = i.clipIntersection),
          (d.displacementMap = i.displacementMap),
          (d.displacementScale = i.displacementScale),
          (d.displacementBias = i.displacementBias),
          (d.wireframeLinewidth = i.wireframeLinewidth),
          (d.linewidth = i.linewidth),
          !0 === r.isPointLight &&
            !0 === d.isMeshDistanceMaterial &&
            (d.referencePosition.setFromMatrixPosition(r.matrixWorld),
            (d.nearDistance = s),
            (d.farDistance = o)),
          d
        );
      }
      function T(n, r, s, o, a) {
        if (!1 === n.visible) return;
        if (
          n.layers.test(r.layers) &&
          (n.isMesh || n.isLine || n.isPoints) &&
          (n.castShadow || (n.receiveShadow && a === f)) &&
          (!n.frustumCulled || i.intersectsObject(n))
        ) {
          n.modelViewMatrix.multiplyMatrices(
            s.matrixWorldInverse,
            n.matrixWorld
          );
          const i = e.update(n),
            r = n.material;
          if (Array.isArray(r)) {
            const e = i.groups;
            for (let l = 0, c = e.length; l < c; l++) {
              const c = e[l],
                u = r[c.materialIndex];
              if (u && u.visible) {
                const e = M(n, 0, u, o, s.near, s.far, a);
                t.renderBufferDirect(s, null, i, e, n, c);
              }
            }
          } else if (r.visible) {
            const e = M(n, 0, r, o, s.near, s.far, a);
            t.renderBufferDirect(s, null, i, e, n, null);
          }
        }
        const l = n.children;
        for (let t = 0, e = l.length; t < e; t++) T(l[t], r, s, o, a);
      }
      (this.enabled = !1),
        (this.autoUpdate = !0),
        (this.needsUpdate = !1),
        (this.type = d),
        (this.render = function (e, n, a) {
          if (!1 === w.enabled) return;
          if (!1 === w.autoUpdate && !1 === w.needsUpdate) return;
          if (0 === e.length) return;
          const l = t.getRenderTarget(),
            c = t.getActiveCubeFace(),
            h = t.getActiveMipmapLevel(),
            d = t.state;
          d.setBlending(x),
            d.buffers.color.setClear(1, 1, 1, 1),
            d.buffers.depth.setTest(!0),
            d.setScissorTest(!1);
          for (let l = 0, c = e.length; l < c; l++) {
            const c = e[l],
              h = c.shadow;
            if (void 0 === h) {
              console.warn("THREE.WebGLShadowMap:", c, "has no shadow.");
              continue;
            }
            if (!1 === h.autoUpdate && !1 === h.needsUpdate) continue;
            r.copy(h.mapSize);
            const p = h.getFrameExtents();
            if (
              (r.multiply(p),
              s.copy(h.mapSize),
              (r.x > u || r.y > u) &&
                (r.x > u &&
                  ((s.x = Math.floor(u / p.x)),
                  (r.x = s.x * p.x),
                  (h.mapSize.x = s.x)),
                r.y > u &&
                  ((s.y = Math.floor(u / p.y)),
                  (r.y = s.y * p.y),
                  (h.mapSize.y = s.y))),
              null === h.map && !h.isPointLightShadow && this.type === f)
            ) {
              const t = { minFilter: yt, magFilter: yt, format: Nt };
              (h.map = new _n(r.x, r.y, t)),
                (h.map.texture.name = c.name + ".shadowMap"),
                (h.mapPass = new _n(r.x, r.y, t)),
                h.camera.updateProjectionMatrix();
            }
            if (null === h.map) {
              const t = { minFilter: mt, magFilter: mt, format: Nt };
              (h.map = new _n(r.x, r.y, t)),
                (h.map.texture.name = c.name + ".shadowMap"),
                h.camera.updateProjectionMatrix();
            }
            t.setRenderTarget(h.map), t.clear();
            const m = h.getViewportCount();
            for (let t = 0; t < m; t++) {
              const e = h.getViewport(t);
              o.set(s.x * e.x, s.y * e.y, s.x * e.z, s.y * e.w),
                d.viewport(o),
                h.updateMatrices(c, t),
                (i = h.getFrustum()),
                T(n, a, h.camera, c, this.type);
            }
            h.isPointLightShadow || this.type !== f || S(h, a),
              (h.needsUpdate = !1);
          }
          (w.needsUpdate = !1), t.setRenderTarget(l, c, h);
        });
    }
    function Na(t, e, n) {
      const i = n.isWebGL2;
      const r = new (function () {
          let e = !1;
          const n = new bn();
          let i = null;
          const r = new bn(0, 0, 0, 0);
          return {
            setMask: function (n) {
              i === n || e || (t.colorMask(n, n, n, n), (i = n));
            },
            setLocked: function (t) {
              e = t;
            },
            setClear: function (e, i, s, o, a) {
              !0 === a && ((e *= o), (i *= o), (s *= o)),
                n.set(e, i, s, o),
                !1 === r.equals(n) && (t.clearColor(e, i, s, o), r.copy(n));
            },
            reset: function () {
              (e = !1), (i = null), r.set(-1, 0, 0, 0);
            },
          };
        })(),
        s = new (function () {
          let e = !1,
            n = null,
            i = null,
            r = null;
          return {
            setTest: function (t) {
              t ? vt(2929) : yt(2929);
            },
            setMask: function (i) {
              n === i || e || (t.depthMask(i), (n = i));
            },
            setFunc: function (e) {
              if (i !== e) {
                if (e)
                  switch (e) {
                    case F:
                      t.depthFunc(512);
                      break;
                    case V:
                      t.depthFunc(519);
                      break;
                    case W:
                      t.depthFunc(513);
                      break;
                    case G:
                      t.depthFunc(515);
                      break;
                    case j:
                      t.depthFunc(514);
                      break;
                    case q:
                      t.depthFunc(518);
                      break;
                    case X:
                      t.depthFunc(516);
                      break;
                    case J:
                      t.depthFunc(517);
                      break;
                    default:
                      t.depthFunc(515);
                  }
                else t.depthFunc(515);
                i = e;
              }
            },
            setLocked: function (t) {
              e = t;
            },
            setClear: function (e) {
              r !== e && (t.clearDepth(e), (r = e));
            },
            reset: function () {
              (e = !1), (n = null), (i = null), (r = null);
            },
          };
        })(),
        o = new (function () {
          let e = !1,
            n = null,
            i = null,
            r = null,
            s = null,
            o = null,
            a = null,
            l = null,
            c = null;
          return {
            setTest: function (t) {
              e || (t ? vt(2960) : yt(2960));
            },
            setMask: function (i) {
              n === i || e || (t.stencilMask(i), (n = i));
            },
            setFunc: function (e, n, o) {
              (i === e && r === n && s === o) ||
                (t.stencilFunc(e, n, o), (i = e), (r = n), (s = o));
            },
            setOp: function (e, n, i) {
              (o === e && a === n && l === i) ||
                (t.stencilOp(e, n, i), (o = e), (a = n), (l = i));
            },
            setLocked: function (t) {
              e = t;
            },
            setClear: function (e) {
              c !== e && (t.clearStencil(e), (c = e));
            },
            reset: function () {
              (e = !1),
                (n = null),
                (i = null),
                (r = null),
                (s = null),
                (o = null),
                (a = null),
                (l = null),
                (c = null);
            },
          };
        })();
      let a = {},
        l = {},
        d = null,
        p = !1,
        f = null,
        m = null,
        y = null,
        $ = null,
        Y = null,
        Z = null,
        Q = null,
        K = !1,
        tt = null,
        et = null,
        nt = null,
        it = null,
        rt = null;
      const st = t.getParameter(35661);
      let ot = !1,
        at = 0;
      const lt = t.getParameter(7938);
      -1 !== lt.indexOf("WebGL")
        ? ((at = parseFloat(/^WebGL (\d)/.exec(lt)[1])), (ot = at >= 1))
        : -1 !== lt.indexOf("OpenGL ES") &&
          ((at = parseFloat(/^OpenGL ES (\d)/.exec(lt)[1])), (ot = at >= 2));
      let ct = null,
        ut = {};
      const ht = t.getParameter(3088),
        dt = t.getParameter(2978),
        pt = new bn().fromArray(ht),
        ft = new bn().fromArray(dt);
      function mt(e, n, i) {
        const r = new Uint8Array(4),
          s = t.createTexture();
        t.bindTexture(e, s),
          t.texParameteri(e, 10241, 9728),
          t.texParameteri(e, 10240, 9728);
        for (let e = 0; e < i; e++)
          t.texImage2D(n + e, 0, 6408, 1, 1, 0, 6408, 5121, r);
        return s;
      }
      const gt = {};
      function vt(e) {
        !0 !== a[e] && (t.enable(e), (a[e] = !0));
      }
      function yt(e) {
        !1 !== a[e] && (t.disable(e), (a[e] = !1));
      }
      (gt[3553] = mt(3553, 3553, 1)),
        (gt[34067] = mt(34067, 34069, 6)),
        r.setClear(0, 0, 0, 1),
        s.setClear(1),
        o.setClear(0),
        vt(2929),
        s.setFunc(G),
        wt(!1),
        St(u),
        vt(2884),
        _t(x);
      const xt = { [T]: 32774, [E]: 32778, [A]: 32779 };
      if (i) (xt[C] = 32775), (xt[L] = 32776);
      else {
        const t = e.get("EXT_blend_minmax");
        null !== t && ((xt[C] = t.MIN_EXT), (xt[L] = t.MAX_EXT));
      }
      const bt = {
        [R]: 0,
        [P]: 1,
        [D]: 768,
        [I]: 770,
        [U]: 776,
        [H]: 774,
        [O]: 772,
        [k]: 769,
        [N]: 771,
        [B]: 775,
        [z]: 773,
      };
      function _t(e, n, i, r, s, o, a, l) {
        if (e !== x) {
          if ((!1 === p && (vt(3042), (p = !0)), e === M))
            (s = s || n),
              (o = o || i),
              (a = a || r),
              (n === m && s === Y) ||
                (t.blendEquationSeparate(xt[n], xt[s]), (m = n), (Y = s)),
              (i === y && r === $ && o === Z && a === Q) ||
                (t.blendFuncSeparate(bt[i], bt[r], bt[o], bt[a]),
                (y = i),
                ($ = r),
                (Z = o),
                (Q = a)),
              (f = e),
              (K = null);
          else if (e !== f || l !== K) {
            if (
              ((m === T && Y === T) ||
                (t.blendEquation(32774), (m = T), (Y = T)),
              l)
            )
              switch (e) {
                case b:
                  t.blendFuncSeparate(1, 771, 1, 771);
                  break;
                case _:
                  t.blendFunc(1, 1);
                  break;
                case w:
                  t.blendFuncSeparate(0, 0, 769, 771);
                  break;
                case S:
                  t.blendFuncSeparate(0, 768, 0, 770);
                  break;
                default:
                  console.error("THREE.WebGLState: Invalid blending: ", e);
              }
            else
              switch (e) {
                case b:
                  t.blendFuncSeparate(770, 771, 1, 771);
                  break;
                case _:
                  t.blendFunc(770, 1);
                  break;
                case w:
                  t.blendFunc(0, 769);
                  break;
                case S:
                  t.blendFunc(0, 768);
                  break;
                default:
                  console.error("THREE.WebGLState: Invalid blending: ", e);
              }
            (y = null), ($ = null), (Z = null), (Q = null), (f = e), (K = l);
          }
        } else !0 === p && (yt(3042), (p = !1));
      }
      function wt(e) {
        tt !== e && (e ? t.frontFace(2304) : t.frontFace(2305), (tt = e));
      }
      function St(e) {
        e !== c
          ? (vt(2884),
            e !== et &&
              (e === u
                ? t.cullFace(1029)
                : e === h
                ? t.cullFace(1028)
                : t.cullFace(1032)))
          : yt(2884),
          (et = e);
      }
      function Mt(e, n, i) {
        e
          ? (vt(32823),
            (it === n && rt === i) ||
              (t.polygonOffset(n, i), (it = n), (rt = i)))
          : yt(32823);
      }
      function Tt(e) {
        void 0 === e && (e = 33984 + st - 1),
          ct !== e && (t.activeTexture(e), (ct = e));
      }
      return {
        buffers: { color: r, depth: s, stencil: o },
        enable: vt,
        disable: yt,
        bindFramebuffer: function (e, n) {
          return (
            l[e] !== n &&
            (t.bindFramebuffer(e, n),
            (l[e] = n),
            i && (36009 === e && (l[36160] = n), 36160 === e && (l[36009] = n)),
            !0)
          );
        },
        useProgram: function (e) {
          return d !== e && (t.useProgram(e), (d = e), !0);
        },
        setBlending: _t,
        setMaterial: function (t, e) {
          t.side === v ? yt(2884) : vt(2884);
          let n = t.side === g;
          e && (n = !n),
            wt(n),
            t.blending === b && !1 === t.transparent
              ? _t(x)
              : _t(
                  t.blending,
                  t.blendEquation,
                  t.blendSrc,
                  t.blendDst,
                  t.blendEquationAlpha,
                  t.blendSrcAlpha,
                  t.blendDstAlpha,
                  t.premultipliedAlpha
                ),
            s.setFunc(t.depthFunc),
            s.setTest(t.depthTest),
            s.setMask(t.depthWrite),
            r.setMask(t.colorWrite);
          const i = t.stencilWrite;
          o.setTest(i),
            i &&
              (o.setMask(t.stencilWriteMask),
              o.setFunc(t.stencilFunc, t.stencilRef, t.stencilFuncMask),
              o.setOp(t.stencilFail, t.stencilZFail, t.stencilZPass)),
            Mt(t.polygonOffset, t.polygonOffsetFactor, t.polygonOffsetUnits),
            !0 === t.alphaToCoverage ? vt(32926) : yt(32926);
        },
        setFlipSided: wt,
        setCullFace: St,
        setLineWidth: function (e) {
          e !== nt && (ot && t.lineWidth(e), (nt = e));
        },
        setPolygonOffset: Mt,
        setScissorTest: function (t) {
          t ? vt(3089) : yt(3089);
        },
        activeTexture: Tt,
        bindTexture: function (e, n) {
          null === ct && Tt();
          let i = ut[ct];
          void 0 === i &&
            ((i = { type: void 0, texture: void 0 }), (ut[ct] = i)),
            (i.type === e && i.texture === n) ||
              (t.bindTexture(e, n || gt[e]), (i.type = e), (i.texture = n));
        },
        unbindTexture: function () {
          const e = ut[ct];
          void 0 !== e &&
            void 0 !== e.type &&
            (t.bindTexture(e.type, null),
            (e.type = void 0),
            (e.texture = void 0));
        },
        compressedTexImage2D: function () {
          try {
            t.compressedTexImage2D.apply(t, arguments);
          } catch (t) {
            console.error("THREE.WebGLState:", t);
          }
        },
        texImage2D: function () {
          try {
            t.texImage2D.apply(t, arguments);
          } catch (t) {
            console.error("THREE.WebGLState:", t);
          }
        },
        texImage3D: function () {
          try {
            t.texImage3D.apply(t, arguments);
          } catch (t) {
            console.error("THREE.WebGLState:", t);
          }
        },
        texStorage2D: function () {
          try {
            t.texStorage2D.apply(t, arguments);
          } catch (t) {
            console.error("THREE.WebGLState:", t);
          }
        },
        texStorage3D: function () {
          try {
            t.texStorage3D.apply(t, arguments);
          } catch (t) {
            console.error("THREE.WebGLState:", t);
          }
        },
        texSubImage2D: function () {
          try {
            t.texSubImage2D.apply(t, arguments);
          } catch (t) {
            console.error("THREE.WebGLState:", t);
          }
        },
        texSubImage3D: function () {
          try {
            t.texSubImage3D.apply(t, arguments);
          } catch (t) {
            console.error("THREE.WebGLState:", t);
          }
        },
        compressedTexSubImage2D: function () {
          try {
            t.compressedTexSubImage2D.apply(t, arguments);
          } catch (t) {
            console.error("THREE.WebGLState:", t);
          }
        },
        scissor: function (e) {
          !1 === pt.equals(e) && (t.scissor(e.x, e.y, e.z, e.w), pt.copy(e));
        },
        viewport: function (e) {
          !1 === ft.equals(e) && (t.viewport(e.x, e.y, e.z, e.w), ft.copy(e));
        },
        reset: function () {
          t.disable(3042),
            t.disable(2884),
            t.disable(2929),
            t.disable(32823),
            t.disable(3089),
            t.disable(2960),
            t.disable(32926),
            t.blendEquation(32774),
            t.blendFunc(1, 0),
            t.blendFuncSeparate(1, 0, 1, 0),
            t.colorMask(!0, !0, !0, !0),
            t.clearColor(0, 0, 0, 0),
            t.depthMask(!0),
            t.depthFunc(513),
            t.clearDepth(1),
            t.stencilMask(4294967295),
            t.stencilFunc(519, 0, 4294967295),
            t.stencilOp(7680, 7680, 7680),
            t.clearStencil(0),
            t.cullFace(1029),
            t.frontFace(2305),
            t.polygonOffset(0, 0),
            t.activeTexture(33984),
            t.bindFramebuffer(36160, null),
            !0 === i &&
              (t.bindFramebuffer(36009, null), t.bindFramebuffer(36008, null)),
            t.useProgram(null),
            t.lineWidth(1),
            t.scissor(0, 0, t.canvas.width, t.canvas.height),
            t.viewport(0, 0, t.canvas.width, t.canvas.height),
            (a = {}),
            (ct = null),
            (ut = {}),
            (l = {}),
            (d = null),
            (p = !1),
            (f = null),
            (m = null),
            (y = null),
            ($ = null),
            (Y = null),
            (Z = null),
            (Q = null),
            (K = !1),
            (tt = null),
            (et = null),
            (nt = null),
            (it = null),
            (rt = null),
            pt.set(0, 0, t.canvas.width, t.canvas.height),
            ft.set(0, 0, t.canvas.width, t.canvas.height),
            r.reset(),
            s.reset(),
            o.reset();
        },
      };
    }
    function Oa(t, e, n, i, r, s, o) {
      const a = r.isWebGL2,
        l = r.maxTextures,
        c = r.maxCubemapSize,
        u = r.maxTextureSize,
        h = r.maxSamples,
        d = e.has("WEBGL_multisampled_render_to_texture")
          ? e.get("WEBGL_multisampled_render_to_texture")
          : void 0,
        p = new WeakMap();
      let f,
        m = !1;
      try {
        m =
          "undefined" != typeof OffscreenCanvas &&
          null !== new OffscreenCanvas(1, 1).getContext("2d");
      } catch (t) {}
      function g(t, e) {
        return m ? new OffscreenCanvas(t, e) : fn("canvas");
      }
      function v(t, e, n, i) {
        let r = 1;
        if (
          ((t.width > i || t.height > i) &&
            (r = i / Math.max(t.width, t.height)),
          r < 1 || !0 === e)
        ) {
          if (
            ("undefined" != typeof HTMLImageElement &&
              t instanceof HTMLImageElement) ||
            ("undefined" != typeof HTMLCanvasElement &&
              t instanceof HTMLCanvasElement) ||
            ("undefined" != typeof ImageBitmap && t instanceof ImageBitmap)
          ) {
            const i = e ? un : Math.floor,
              s = i(r * t.width),
              o = i(r * t.height);
            void 0 === f && (f = g(s, o));
            const a = n ? g(s, o) : f;
            return (
              (a.width = s),
              (a.height = o),
              a.getContext("2d").drawImage(t, 0, 0, s, o),
              console.warn(
                "THREE.WebGLRenderer: Texture has been resized from (" +
                  t.width +
                  "x" +
                  t.height +
                  ") to (" +
                  s +
                  "x" +
                  o +
                  ")."
              ),
              a
            );
          }
          return (
            "data" in t &&
              console.warn(
                "THREE.WebGLRenderer: Image in DataTexture is too big (" +
                  t.width +
                  "x" +
                  t.height +
                  ")."
              ),
            t
          );
        }
        return t;
      }
      function y(t) {
        return cn(t.width) && cn(t.height);
      }
      function x(t, e) {
        return (
          t.generateMipmaps && e && t.minFilter !== mt && t.minFilter !== yt
        );
      }
      function b(e) {
        t.generateMipmap(e);
      }
      function _(n, i, r, s) {
        if (!1 === a) return i;
        if (null !== n) {
          if (void 0 !== t[n]) return t[n];
          console.warn(
            "THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" +
              n +
              "'"
          );
        }
        let o = i;
        return (
          6403 === i &&
            (5126 === r && (o = 33326),
            5131 === r && (o = 33325),
            5121 === r && (o = 33321)),
          6407 === i &&
            (5126 === r && (o = 34837),
            5131 === r && (o = 34843),
            5121 === r && (o = 32849)),
          6408 === i &&
            (5126 === r && (o = 34836),
            5131 === r && (o = 34842),
            5121 === r && (o = s === Ge ? 35907 : 32856)),
          (33325 !== o && 33326 !== o && 34842 !== o && 34836 !== o) ||
            e.get("EXT_color_buffer_float"),
          o
        );
      }
      function w(t, e, n) {
        return !0 === x(t, n) ||
          (t.isFramebufferTexture && t.minFilter !== mt && t.minFilter !== yt)
          ? Math.log2(Math.max(e.width, e.height)) + 1
          : void 0 !== t.mipmaps && t.mipmaps.length > 0
          ? t.mipmaps.length
          : t.isCompressedTexture && Array.isArray(t.image)
          ? e.mipmaps.length
          : 1;
      }
      function S(t) {
        return t === mt || t === gt || t === vt ? 9728 : 9729;
      }
      function M(e) {
        const n = e.target;
        n.removeEventListener("dispose", M),
          (function (e) {
            const n = i.get(e);
            if (void 0 === n.__webglInit) return;
            t.deleteTexture(n.__webglTexture), i.remove(e);
          })(n),
          n.isVideoTexture && p.delete(n),
          o.memory.textures--;
      }
      function T(e) {
        const n = e.target;
        n.removeEventListener("dispose", T),
          (function (e) {
            const n = e.texture,
              r = i.get(e),
              s = i.get(n);
            if (!e) return;
            void 0 !== s.__webglTexture &&
              (t.deleteTexture(s.__webglTexture), o.memory.textures--);
            e.depthTexture && e.depthTexture.dispose();
            if (e.isWebGLCubeRenderTarget)
              for (let e = 0; e < 6; e++)
                t.deleteFramebuffer(r.__webglFramebuffer[e]),
                  r.__webglDepthbuffer &&
                    t.deleteRenderbuffer(r.__webglDepthbuffer[e]);
            else
              t.deleteFramebuffer(r.__webglFramebuffer),
                r.__webglDepthbuffer &&
                  t.deleteRenderbuffer(r.__webglDepthbuffer),
                r.__webglMultisampledFramebuffer &&
                  t.deleteFramebuffer(r.__webglMultisampledFramebuffer),
                r.__webglColorRenderbuffer &&
                  t.deleteRenderbuffer(r.__webglColorRenderbuffer),
                r.__webglDepthRenderbuffer &&
                  t.deleteRenderbuffer(r.__webglDepthRenderbuffer);
            if (e.isWebGLMultipleRenderTargets)
              for (let e = 0, r = n.length; e < r; e++) {
                const r = i.get(n[e]);
                r.__webglTexture &&
                  (t.deleteTexture(r.__webglTexture), o.memory.textures--),
                  i.remove(n[e]);
              }
            i.remove(n), i.remove(e);
          })(n);
      }
      let E = 0;
      function A(t, e) {
        const r = i.get(t);
        if (
          (t.isVideoTexture &&
            (function (t) {
              const e = o.render.frame;
              p.get(t) !== e && (p.set(t, e), t.update());
            })(t),
          t.version > 0 && r.__version !== t.version)
        ) {
          const n = t.image;
          if (void 0 === n)
            console.warn(
              "THREE.WebGLRenderer: Texture marked for update but image is undefined"
            );
          else {
            if (!1 !== n.complete) return void k(r, t, e);
            console.warn(
              "THREE.WebGLRenderer: Texture marked for update but image is incomplete"
            );
          }
        }
        n.activeTexture(33984 + e), n.bindTexture(3553, r.__webglTexture);
      }
      function C(e, r) {
        const o = i.get(e);
        e.version > 0 && o.__version !== e.version
          ? (function (e, i, r) {
              if (6 !== i.image.length) return;
              D(e, i),
                n.activeTexture(33984 + r),
                n.bindTexture(34067, e.__webglTexture),
                t.pixelStorei(37440, i.flipY),
                t.pixelStorei(37441, i.premultiplyAlpha),
                t.pixelStorei(3317, i.unpackAlignment),
                t.pixelStorei(37443, 0);
              const o =
                  i &&
                  (i.isCompressedTexture || i.image[0].isCompressedTexture),
                l = i.image[0] && i.image[0].isDataTexture,
                u = [];
              for (let t = 0; t < 6; t++)
                u[t] =
                  o || l
                    ? l
                      ? i.image[t].image
                      : i.image[t]
                    : v(i.image[t], !1, !0, c);
              const h = u[0],
                d = y(h) || a,
                p = s.convert(i.format),
                f = s.convert(i.type),
                m = _(i.internalFormat, p, f, i.encoding),
                g = a && !0 !== i.isVideoTexture,
                S = void 0 === e.__version;
              let M,
                T = w(i, h, d);
              if ((P(34067, i, d), o)) {
                g && S && n.texStorage2D(34067, T, m, h.width, h.height);
                for (let t = 0; t < 6; t++) {
                  M = u[t].mipmaps;
                  for (let e = 0; e < M.length; e++) {
                    const r = M[e];
                    i.format !== Nt && i.format !== It
                      ? null !== p
                        ? g
                          ? n.compressedTexSubImage2D(
                              34069 + t,
                              e,
                              0,
                              0,
                              r.width,
                              r.height,
                              p,
                              r.data
                            )
                          : n.compressedTexImage2D(
                              34069 + t,
                              e,
                              m,
                              r.width,
                              r.height,
                              0,
                              r.data
                            )
                        : console.warn(
                            "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"
                          )
                      : g
                      ? n.texSubImage2D(
                          34069 + t,
                          e,
                          0,
                          0,
                          r.width,
                          r.height,
                          p,
                          f,
                          r.data
                        )
                      : n.texImage2D(
                          34069 + t,
                          e,
                          m,
                          r.width,
                          r.height,
                          0,
                          p,
                          f,
                          r.data
                        );
                  }
                }
              } else {
                (M = i.mipmaps),
                  g &&
                    S &&
                    (M.length > 0 && T++,
                    n.texStorage2D(34067, T, m, u[0].width, u[0].height));
                for (let t = 0; t < 6; t++)
                  if (l) {
                    g
                      ? n.texSubImage2D(
                          34069 + t,
                          0,
                          0,
                          0,
                          u[t].width,
                          u[t].height,
                          p,
                          f,
                          u[t].data
                        )
                      : n.texImage2D(
                          34069 + t,
                          0,
                          m,
                          u[t].width,
                          u[t].height,
                          0,
                          p,
                          f,
                          u[t].data
                        );
                    for (let e = 0; e < M.length; e++) {
                      const i = M[e].image[t].image;
                      g
                        ? n.texSubImage2D(
                            34069 + t,
                            e + 1,
                            0,
                            0,
                            i.width,
                            i.height,
                            p,
                            f,
                            i.data
                          )
                        : n.texImage2D(
                            34069 + t,
                            e + 1,
                            m,
                            i.width,
                            i.height,
                            0,
                            p,
                            f,
                            i.data
                          );
                    }
                  } else {
                    g
                      ? n.texSubImage2D(34069 + t, 0, 0, 0, p, f, u[t])
                      : n.texImage2D(34069 + t, 0, m, p, f, u[t]);
                    for (let e = 0; e < M.length; e++) {
                      const i = M[e];
                      g
                        ? n.texSubImage2D(
                            34069 + t,
                            e + 1,
                            0,
                            0,
                            p,
                            f,
                            i.image[t]
                          )
                        : n.texImage2D(34069 + t, e + 1, m, p, f, i.image[t]);
                    }
                  }
              }
              x(i, d) && b(34067);
              (e.__version = i.version), i.onUpdate && i.onUpdate(i);
            })(o, e, r)
          : (n.activeTexture(33984 + r),
            n.bindTexture(34067, o.__webglTexture));
      }
      const L = { [dt]: 10497, [pt]: 33071, [ft]: 33648 },
        R = {
          [mt]: 9728,
          [gt]: 9984,
          [vt]: 9986,
          [yt]: 9729,
          [xt]: 9985,
          [bt]: 9987,
        };
      function P(n, s, o) {
        if (
          (o
            ? (t.texParameteri(n, 10242, L[s.wrapS]),
              t.texParameteri(n, 10243, L[s.wrapT]),
              (32879 !== n && 35866 !== n) ||
                t.texParameteri(n, 32882, L[s.wrapR]),
              t.texParameteri(n, 10240, R[s.magFilter]),
              t.texParameteri(n, 10241, R[s.minFilter]))
            : (t.texParameteri(n, 10242, 33071),
              t.texParameteri(n, 10243, 33071),
              (32879 !== n && 35866 !== n) || t.texParameteri(n, 32882, 33071),
              (s.wrapS === pt && s.wrapT === pt) ||
                console.warn(
                  "THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."
                ),
              t.texParameteri(n, 10240, S(s.magFilter)),
              t.texParameteri(n, 10241, S(s.minFilter)),
              s.minFilter !== mt &&
                s.minFilter !== yt &&
                console.warn(
                  "THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter."
                )),
          !0 === e.has("EXT_texture_filter_anisotropic"))
        ) {
          const o = e.get("EXT_texture_filter_anisotropic");
          if (s.type === At && !1 === e.has("OES_texture_float_linear")) return;
          if (
            !1 === a &&
            s.type === Ct &&
            !1 === e.has("OES_texture_half_float_linear")
          )
            return;
          (s.anisotropy > 1 || i.get(s).__currentAnisotropy) &&
            (t.texParameterf(
              n,
              o.TEXTURE_MAX_ANISOTROPY_EXT,
              Math.min(s.anisotropy, r.getMaxAnisotropy())
            ),
            (i.get(s).__currentAnisotropy = s.anisotropy));
        }
      }
      function D(e, n) {
        void 0 === e.__webglInit &&
          ((e.__webglInit = !0),
          n.addEventListener("dispose", M),
          (e.__webglTexture = t.createTexture()),
          o.memory.textures++);
      }
      function k(e, i, r) {
        let o = 3553;
        i.isDataTexture2DArray && (o = 35866),
          i.isDataTexture3D && (o = 32879),
          D(e, i),
          n.activeTexture(33984 + r),
          n.bindTexture(o, e.__webglTexture),
          t.pixelStorei(37440, i.flipY),
          t.pixelStorei(37441, i.premultiplyAlpha),
          t.pixelStorei(3317, i.unpackAlignment),
          t.pixelStorei(37443, 0);
        const l =
            (function (t) {
              return (
                !a &&
                (t.wrapS !== pt ||
                  t.wrapT !== pt ||
                  (t.minFilter !== mt && t.minFilter !== yt))
              );
            })(i) && !1 === y(i.image),
          c = v(i.image, l, !1, u),
          h = y(c) || a,
          d = s.convert(i.format);
        let p,
          f = s.convert(i.type),
          m = _(i.internalFormat, d, f, i.encoding);
        P(o, i, h);
        const g = i.mipmaps,
          S = a && !0 !== i.isVideoTexture,
          M = void 0 === e.__version,
          T = w(i, c, h);
        if (i.isDepthTexture)
          (m = 6402),
            a
              ? (m =
                  i.type === At
                    ? 36012
                    : i.type === Et
                    ? 33190
                    : i.type === Dt
                    ? 35056
                    : 33189)
              : i.type === At &&
                console.error(
                  "WebGLRenderer: Floating point depth texture requires WebGL2."
                ),
            i.format === Ht &&
              6402 === m &&
              i.type !== Mt &&
              i.type !== Et &&
              (console.warn(
                "THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."
              ),
              (i.type = Mt),
              (f = s.convert(i.type))),
            i.format === Bt &&
              6402 === m &&
              ((m = 34041),
              i.type !== Dt &&
                (console.warn(
                  "THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."
                ),
                (i.type = Dt),
                (f = s.convert(i.type)))),
            S && M
              ? n.texStorage2D(3553, 1, m, c.width, c.height)
              : n.texImage2D(3553, 0, m, c.width, c.height, 0, d, f, null);
        else if (i.isDataTexture)
          if (g.length > 0 && h) {
            S && M && n.texStorage2D(3553, T, m, g[0].width, g[0].height);
            for (let t = 0, e = g.length; t < e; t++)
              (p = g[t]),
                S
                  ? n.texSubImage2D(
                      3553,
                      0,
                      0,
                      0,
                      p.width,
                      p.height,
                      d,
                      f,
                      p.data
                    )
                  : n.texImage2D(
                      3553,
                      t,
                      m,
                      p.width,
                      p.height,
                      0,
                      d,
                      f,
                      p.data
                    );
            i.generateMipmaps = !1;
          } else
            S
              ? (M && n.texStorage2D(3553, T, m, c.width, c.height),
                n.texSubImage2D(3553, 0, 0, 0, c.width, c.height, d, f, c.data))
              : n.texImage2D(3553, 0, m, c.width, c.height, 0, d, f, c.data);
        else if (i.isCompressedTexture) {
          S && M && n.texStorage2D(3553, T, m, g[0].width, g[0].height);
          for (let t = 0, e = g.length; t < e; t++)
            (p = g[t]),
              i.format !== Nt && i.format !== It
                ? null !== d
                  ? S
                    ? n.compressedTexSubImage2D(
                        3553,
                        t,
                        0,
                        0,
                        p.width,
                        p.height,
                        d,
                        p.data
                      )
                    : n.compressedTexImage2D(
                        3553,
                        t,
                        m,
                        p.width,
                        p.height,
                        0,
                        p.data
                      )
                  : console.warn(
                      "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                    )
                : S
                ? n.texSubImage2D(
                    3553,
                    t,
                    0,
                    0,
                    p.width,
                    p.height,
                    d,
                    f,
                    p.data
                  )
                : n.texImage2D(3553, t, m, p.width, p.height, 0, d, f, p.data);
        } else if (i.isDataTexture2DArray)
          S
            ? (M && n.texStorage3D(35866, T, m, c.width, c.height, c.depth),
              n.texSubImage3D(
                35866,
                0,
                0,
                0,
                0,
                c.width,
                c.height,
                c.depth,
                d,
                f,
                c.data
              ))
            : n.texImage3D(
                35866,
                0,
                m,
                c.width,
                c.height,
                c.depth,
                0,
                d,
                f,
                c.data
              );
        else if (i.isDataTexture3D)
          S
            ? (M && n.texStorage3D(32879, T, m, c.width, c.height, c.depth),
              n.texSubImage3D(
                32879,
                0,
                0,
                0,
                0,
                c.width,
                c.height,
                c.depth,
                d,
                f,
                c.data
              ))
            : n.texImage3D(
                32879,
                0,
                m,
                c.width,
                c.height,
                c.depth,
                0,
                d,
                f,
                c.data
              );
        else if (i.isFramebufferTexture)
          S && M
            ? n.texStorage2D(3553, T, m, c.width, c.height)
            : n.texImage2D(3553, 0, m, c.width, c.height, 0, d, f, null);
        else if (g.length > 0 && h) {
          S && M && n.texStorage2D(3553, T, m, g[0].width, g[0].height);
          for (let t = 0, e = g.length; t < e; t++)
            (p = g[t]),
              S
                ? n.texSubImage2D(3553, t, 0, 0, d, f, p)
                : n.texImage2D(3553, t, m, d, f, p);
          i.generateMipmaps = !1;
        } else
          S
            ? (M && n.texStorage2D(3553, T, m, c.width, c.height),
              n.texSubImage2D(3553, 0, 0, 0, d, f, c))
            : n.texImage2D(3553, 0, m, d, f, c);
        x(i, h) && b(o), (e.__version = i.version), i.onUpdate && i.onUpdate(i);
      }
      function I(e, r, o, a, l) {
        const c = s.convert(o.format),
          u = s.convert(o.type),
          h = _(o.internalFormat, c, u, o.encoding);
        i.get(r).__hasExternalTextures ||
          (32879 === l || 35866 === l
            ? n.texImage3D(l, 0, h, r.width, r.height, r.depth, 0, c, u, null)
            : n.texImage2D(l, 0, h, r.width, r.height, 0, c, u, null)),
          n.bindFramebuffer(36160, e),
          r.useRenderToTexture
            ? d.framebufferTexture2DMultisampleEXT(
                36160,
                a,
                l,
                i.get(o).__webglTexture,
                0,
                z(r)
              )
            : t.framebufferTexture2D(36160, a, l, i.get(o).__webglTexture, 0),
          n.bindFramebuffer(36160, null);
      }
      function N(e, n, i) {
        if ((t.bindRenderbuffer(36161, e), n.depthBuffer && !n.stencilBuffer)) {
          let r = 33189;
          if (i || n.useRenderToTexture) {
            const e = n.depthTexture;
            e &&
              e.isDepthTexture &&
              (e.type === At ? (r = 36012) : e.type === Et && (r = 33190));
            const i = z(n);
            n.useRenderToTexture
              ? d.renderbufferStorageMultisampleEXT(
                  36161,
                  i,
                  r,
                  n.width,
                  n.height
                )
              : t.renderbufferStorageMultisample(
                  36161,
                  i,
                  r,
                  n.width,
                  n.height
                );
          } else t.renderbufferStorage(36161, r, n.width, n.height);
          t.framebufferRenderbuffer(36160, 36096, 36161, e);
        } else if (n.depthBuffer && n.stencilBuffer) {
          const r = z(n);
          i && n.useRenderbuffer
            ? t.renderbufferStorageMultisample(
                36161,
                r,
                35056,
                n.width,
                n.height
              )
            : n.useRenderToTexture
            ? d.renderbufferStorageMultisampleEXT(
                36161,
                r,
                35056,
                n.width,
                n.height
              )
            : t.renderbufferStorage(36161, 34041, n.width, n.height),
            t.framebufferRenderbuffer(36160, 33306, 36161, e);
        } else {
          const e =
              !0 === n.isWebGLMultipleRenderTargets ? n.texture[0] : n.texture,
            r = s.convert(e.format),
            o = s.convert(e.type),
            a = _(e.internalFormat, r, o, e.encoding),
            l = z(n);
          i && n.useRenderbuffer
            ? t.renderbufferStorageMultisample(36161, l, a, n.width, n.height)
            : n.useRenderToTexture
            ? d.renderbufferStorageMultisampleEXT(
                36161,
                l,
                a,
                n.width,
                n.height
              )
            : t.renderbufferStorage(36161, a, n.width, n.height);
        }
        t.bindRenderbuffer(36161, null);
      }
      function O(e) {
        const r = i.get(e),
          s = !0 === e.isWebGLCubeRenderTarget;
        if (e.depthTexture && !r.__autoAllocateDepthBuffer) {
          if (s)
            throw new Error(
              "target.depthTexture not supported in Cube render targets"
            );
          !(function (e, r) {
            if (r && r.isWebGLCubeRenderTarget)
              throw new Error(
                "Depth Texture with cube render targets is not supported"
              );
            if (
              (n.bindFramebuffer(36160, e),
              !r.depthTexture || !r.depthTexture.isDepthTexture)
            )
              throw new Error(
                "renderTarget.depthTexture must be an instance of THREE.DepthTexture"
              );
            (i.get(r.depthTexture).__webglTexture &&
              r.depthTexture.image.width === r.width &&
              r.depthTexture.image.height === r.height) ||
              ((r.depthTexture.image.width = r.width),
              (r.depthTexture.image.height = r.height),
              (r.depthTexture.needsUpdate = !0)),
              A(r.depthTexture, 0);
            const s = i.get(r.depthTexture).__webglTexture,
              o = z(r);
            if (r.depthTexture.format === Ht)
              r.useRenderToTexture
                ? d.framebufferTexture2DMultisampleEXT(
                    36160,
                    36096,
                    3553,
                    s,
                    0,
                    o
                  )
                : t.framebufferTexture2D(36160, 36096, 3553, s, 0);
            else {
              if (r.depthTexture.format !== Bt)
                throw new Error("Unknown depthTexture format");
              r.useRenderToTexture
                ? d.framebufferTexture2DMultisampleEXT(
                    36160,
                    33306,
                    3553,
                    s,
                    0,
                    o
                  )
                : t.framebufferTexture2D(36160, 33306, 3553, s, 0);
            }
          })(r.__webglFramebuffer, e);
        } else if (s) {
          r.__webglDepthbuffer = [];
          for (let i = 0; i < 6; i++)
            n.bindFramebuffer(36160, r.__webglFramebuffer[i]),
              (r.__webglDepthbuffer[i] = t.createRenderbuffer()),
              N(r.__webglDepthbuffer[i], e, !1);
        } else
          n.bindFramebuffer(36160, r.__webglFramebuffer),
            (r.__webglDepthbuffer = t.createRenderbuffer()),
            N(r.__webglDepthbuffer, e, !1);
        n.bindFramebuffer(36160, null);
      }
      function z(t) {
        return a && (t.useRenderbuffer || t.useRenderToTexture)
          ? Math.min(h, t.samples)
          : 0;
      }
      let H = !1,
        B = !1;
      (this.allocateTextureUnit = function () {
        const t = E;
        return (
          t >= l &&
            console.warn(
              "THREE.WebGLTextures: Trying to use " +
                t +
                " texture units while this GPU supports only " +
                l
            ),
          (E += 1),
          t
        );
      }),
        (this.resetTextureUnits = function () {
          E = 0;
        }),
        (this.setTexture2D = A),
        (this.setTexture2DArray = function (t, e) {
          const r = i.get(t);
          t.version > 0 && r.__version !== t.version
            ? k(r, t, e)
            : (n.activeTexture(33984 + e),
              n.bindTexture(35866, r.__webglTexture));
        }),
        (this.setTexture3D = function (t, e) {
          const r = i.get(t);
          t.version > 0 && r.__version !== t.version
            ? k(r, t, e)
            : (n.activeTexture(33984 + e),
              n.bindTexture(32879, r.__webglTexture));
        }),
        (this.setTextureCube = C),
        (this.rebindTextures = function (t, e, n) {
          const r = i.get(t);
          void 0 !== e && I(r.__webglFramebuffer, t, t.texture, 36064, 3553),
            void 0 !== n && O(t);
        }),
        (this.setupRenderTarget = function (e) {
          const l = e.texture,
            c = i.get(e),
            u = i.get(l);
          e.addEventListener("dispose", T),
            !0 !== e.isWebGLMultipleRenderTargets &&
              (void 0 === u.__webglTexture &&
                (u.__webglTexture = t.createTexture()),
              (u.__version = l.version),
              o.memory.textures++);
          const h = !0 === e.isWebGLCubeRenderTarget,
            d = !0 === e.isWebGLMultipleRenderTargets,
            p = l.isDataTexture3D || l.isDataTexture2DArray,
            f = y(e) || a;
          if (
            (!a ||
              l.format !== It ||
              (l.type !== At && l.type !== Ct) ||
              ((l.format = Nt),
              console.warn(
                "THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead."
              )),
            h)
          ) {
            c.__webglFramebuffer = [];
            for (let e = 0; e < 6; e++)
              c.__webglFramebuffer[e] = t.createFramebuffer();
          } else if (((c.__webglFramebuffer = t.createFramebuffer()), d))
            if (r.drawBuffers) {
              const n = e.texture;
              for (let e = 0, r = n.length; e < r; e++) {
                const r = i.get(n[e]);
                void 0 === r.__webglTexture &&
                  ((r.__webglTexture = t.createTexture()), o.memory.textures++);
              }
            } else
              console.warn(
                "THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension."
              );
          else if (e.useRenderbuffer)
            if (a) {
              (c.__webglMultisampledFramebuffer = t.createFramebuffer()),
                (c.__webglColorRenderbuffer = t.createRenderbuffer()),
                t.bindRenderbuffer(36161, c.__webglColorRenderbuffer);
              const i = s.convert(l.format),
                r = s.convert(l.type),
                o = _(l.internalFormat, i, r, l.encoding),
                a = z(e);
              t.renderbufferStorageMultisample(36161, a, o, e.width, e.height),
                n.bindFramebuffer(36160, c.__webglMultisampledFramebuffer),
                t.framebufferRenderbuffer(
                  36160,
                  36064,
                  36161,
                  c.__webglColorRenderbuffer
                ),
                t.bindRenderbuffer(36161, null),
                e.depthBuffer &&
                  ((c.__webglDepthRenderbuffer = t.createRenderbuffer()),
                  N(c.__webglDepthRenderbuffer, e, !0)),
                n.bindFramebuffer(36160, null);
            } else
              console.warn(
                "THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2."
              );
          if (h) {
            n.bindTexture(34067, u.__webglTexture), P(34067, l, f);
            for (let t = 0; t < 6; t++)
              I(c.__webglFramebuffer[t], e, l, 36064, 34069 + t);
            x(l, f) && b(34067), n.unbindTexture();
          } else if (d) {
            const t = e.texture;
            for (let r = 0, s = t.length; r < s; r++) {
              const s = t[r],
                o = i.get(s);
              n.bindTexture(3553, o.__webglTexture),
                P(3553, s, f),
                I(c.__webglFramebuffer, e, s, 36064 + r, 3553),
                x(s, f) && b(3553);
            }
            n.unbindTexture();
          } else {
            let t = 3553;
            if (p)
              if (a) {
                t = l.isDataTexture3D ? 32879 : 35866;
              } else
                console.warn(
                  "THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2."
                );
            n.bindTexture(t, u.__webglTexture),
              P(t, l, f),
              I(c.__webglFramebuffer, e, l, 36064, t),
              x(l, f) && b(t),
              n.unbindTexture();
          }
          e.depthBuffer && O(e);
        }),
        (this.updateRenderTargetMipmap = function (t) {
          const e = y(t) || a,
            r = !0 === t.isWebGLMultipleRenderTargets ? t.texture : [t.texture];
          for (let s = 0, o = r.length; s < o; s++) {
            const o = r[s];
            if (x(o, e)) {
              const e = t.isWebGLCubeRenderTarget ? 34067 : 3553,
                r = i.get(o).__webglTexture;
              n.bindTexture(e, r), b(e), n.unbindTexture();
            }
          }
        }),
        (this.updateMultisampleRenderTarget = function (e) {
          if (e.useRenderbuffer)
            if (a) {
              const r = e.width,
                s = e.height;
              let o = 16384;
              const a = [36064],
                l = e.stencilBuffer ? 33306 : 36096;
              e.depthBuffer && a.push(l),
                e.ignoreDepthForMultisampleCopy ||
                  (e.depthBuffer && (o |= 256), e.stencilBuffer && (o |= 1024));
              const c = i.get(e);
              n.bindFramebuffer(36008, c.__webglMultisampledFramebuffer),
                n.bindFramebuffer(36009, c.__webglFramebuffer),
                e.ignoreDepthForMultisampleCopy &&
                  (t.invalidateFramebuffer(36008, [l]),
                  t.invalidateFramebuffer(36009, [l])),
                t.blitFramebuffer(0, 0, r, s, 0, 0, r, s, o, 9728),
                t.invalidateFramebuffer(36008, a),
                n.bindFramebuffer(36008, null),
                n.bindFramebuffer(36009, c.__webglMultisampledFramebuffer);
            } else
              console.warn(
                "THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2."
              );
        }),
        (this.setupDepthRenderbuffer = O),
        (this.setupFrameBufferTexture = I),
        (this.safeSetTexture2D = function (t, e) {
          t &&
            t.isWebGLRenderTarget &&
            (!1 === H &&
              (console.warn(
                "THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."
              ),
              (H = !0)),
            (t = t.texture)),
            A(t, e);
        }),
        (this.safeSetTextureCube = function (t, e) {
          t &&
            t.isWebGLCubeRenderTarget &&
            (!1 === B &&
              (console.warn(
                "THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."
              ),
              (B = !0)),
            (t = t.texture)),
            C(t, e);
        });
    }
    function za(t, e, n) {
      const i = n.isWebGL2;
      return {
        convert: function (t) {
          let n;
          if (t === _t) return 5121;
          if (t === Lt) return 32819;
          if (t === Rt) return 32820;
          if (t === Pt) return 33635;
          if (t === wt) return 5120;
          if (t === St) return 5122;
          if (t === Mt) return 5123;
          if (t === Tt) return 5124;
          if (t === Et) return 5125;
          if (t === At) return 5126;
          if (t === Ct)
            return i
              ? 5131
              : ((n = e.get("OES_texture_half_float")),
                null !== n ? n.HALF_FLOAT_OES : null);
          if (t === kt) return 6406;
          if (t === It) return 6407;
          if (t === Nt) return 6408;
          if (t === Ot) return 6409;
          if (t === zt) return 6410;
          if (t === Ht) return 6402;
          if (t === Bt) return 34041;
          if (t === Ut) return 6403;
          if (t === Ft) return 36244;
          if (t === Vt) return 33319;
          if (t === Wt) return 33320;
          if (t === Gt) return 36248;
          if (t === jt) return 36249;
          if (t === qt || t === $t || t === Xt || t === Jt) {
            if (((n = e.get("WEBGL_compressed_texture_s3tc")), null === n))
              return null;
            if (t === qt) return n.COMPRESSED_RGB_S3TC_DXT1_EXT;
            if (t === $t) return n.COMPRESSED_RGBA_S3TC_DXT1_EXT;
            if (t === Xt) return n.COMPRESSED_RGBA_S3TC_DXT3_EXT;
            if (t === Jt) return n.COMPRESSED_RGBA_S3TC_DXT5_EXT;
          }
          if (t === Yt || t === Zt || t === Qt || t === Kt) {
            if (((n = e.get("WEBGL_compressed_texture_pvrtc")), null === n))
              return null;
            if (t === Yt) return n.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
            if (t === Zt) return n.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
            if (t === Qt) return n.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
            if (t === Kt) return n.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
          }
          if (t === te)
            return (
              (n = e.get("WEBGL_compressed_texture_etc1")),
              null !== n ? n.COMPRESSED_RGB_ETC1_WEBGL : null
            );
          if (
            (t === ee || t === ne) &&
            ((n = e.get("WEBGL_compressed_texture_etc")), null !== n)
          ) {
            if (t === ee) return n.COMPRESSED_RGB8_ETC2;
            if (t === ne) return n.COMPRESSED_RGBA8_ETC2_EAC;
          }
          return t === ie ||
            t === re ||
            t === se ||
            t === oe ||
            t === ae ||
            t === le ||
            t === ce ||
            t === ue ||
            t === he ||
            t === de ||
            t === pe ||
            t === fe ||
            t === me ||
            t === ge ||
            t === ye ||
            t === xe ||
            t === be ||
            t === _e ||
            t === we ||
            t === Se ||
            t === Me ||
            t === Te ||
            t === Ee ||
            t === Ae ||
            t === Ce ||
            t === Le ||
            t === Re ||
            t === Pe
            ? ((n = e.get("WEBGL_compressed_texture_astc")),
              null !== n ? t : null)
            : t === ve
            ? ((n = e.get("EXT_texture_compression_bptc")),
              null !== n ? t : null)
            : t === Dt
            ? i
              ? 34042
              : ((n = e.get("WEBGL_depth_texture")),
                null !== n ? n.UNSIGNED_INT_24_8_WEBGL : null)
            : void 0;
        },
      };
    }
    class Ha extends Nr {
      constructor(t = []) {
        super(), (this.cameras = t);
      }
    }
    Ha.prototype.isArrayCamera = !0;
    class Ba extends Ei {
      constructor() {
        super(), (this.type = "Group");
      }
    }
    Ba.prototype.isGroup = !0;
    const Ua = { type: "move" };
    class Fa {
      constructor() {
        (this._targetRay = null), (this._grip = null), (this._hand = null);
      }
      getHandSpace() {
        return (
          null === this._hand &&
            ((this._hand = new Ba()),
            (this._hand.matrixAutoUpdate = !1),
            (this._hand.visible = !1),
            (this._hand.joints = {}),
            (this._hand.inputState = { pinching: !1 })),
          this._hand
        );
      }
      getTargetRaySpace() {
        return (
          null === this._targetRay &&
            ((this._targetRay = new Ba()),
            (this._targetRay.matrixAutoUpdate = !1),
            (this._targetRay.visible = !1),
            (this._targetRay.hasLinearVelocity = !1),
            (this._targetRay.linearVelocity = new Mn()),
            (this._targetRay.hasAngularVelocity = !1),
            (this._targetRay.angularVelocity = new Mn())),
          this._targetRay
        );
      }
      getGripSpace() {
        return (
          null === this._grip &&
            ((this._grip = new Ba()),
            (this._grip.matrixAutoUpdate = !1),
            (this._grip.visible = !1),
            (this._grip.hasLinearVelocity = !1),
            (this._grip.linearVelocity = new Mn()),
            (this._grip.hasAngularVelocity = !1),
            (this._grip.angularVelocity = new Mn())),
          this._grip
        );
      }
      dispatchEvent(t) {
        return (
          null !== this._targetRay && this._targetRay.dispatchEvent(t),
          null !== this._grip && this._grip.dispatchEvent(t),
          null !== this._hand && this._hand.dispatchEvent(t),
          this
        );
      }
      disconnect(t) {
        return (
          this.dispatchEvent({ type: "disconnected", data: t }),
          null !== this._targetRay && (this._targetRay.visible = !1),
          null !== this._grip && (this._grip.visible = !1),
          null !== this._hand && (this._hand.visible = !1),
          this
        );
      }
      update(t, e, n) {
        let i = null,
          r = null,
          s = null;
        const o = this._targetRay,
          a = this._grip,
          l = this._hand;
        if (t && "visible-blurred" !== e.session.visibilityState)
          if (
            (null !== o &&
              ((i = e.getPose(t.targetRaySpace, n)),
              null !== i &&
                (o.matrix.fromArray(i.transform.matrix),
                o.matrix.decompose(o.position, o.rotation, o.scale),
                i.linearVelocity
                  ? ((o.hasLinearVelocity = !0),
                    o.linearVelocity.copy(i.linearVelocity))
                  : (o.hasLinearVelocity = !1),
                i.angularVelocity
                  ? ((o.hasAngularVelocity = !0),
                    o.angularVelocity.copy(i.angularVelocity))
                  : (o.hasAngularVelocity = !1),
                this.dispatchEvent(Ua))),
            l && t.hand)
          ) {
            s = !0;
            for (const i of t.hand.values()) {
              const t = e.getJointPose(i, n);
              if (void 0 === l.joints[i.jointName]) {
                const t = new Ba();
                (t.matrixAutoUpdate = !1),
                  (t.visible = !1),
                  (l.joints[i.jointName] = t),
                  l.add(t);
              }
              const r = l.joints[i.jointName];
              null !== t &&
                (r.matrix.fromArray(t.transform.matrix),
                r.matrix.decompose(r.position, r.rotation, r.scale),
                (r.jointRadius = t.radius)),
                (r.visible = null !== t);
            }
            const i = l.joints["index-finger-tip"],
              r = l.joints["thumb-tip"],
              o = i.position.distanceTo(r.position),
              a = 0.02,
              c = 0.005;
            l.inputState.pinching && o > a + c
              ? ((l.inputState.pinching = !1),
                this.dispatchEvent({
                  type: "pinchend",
                  handedness: t.handedness,
                  target: this,
                }))
              : !l.inputState.pinching &&
                o <= a - c &&
                ((l.inputState.pinching = !0),
                this.dispatchEvent({
                  type: "pinchstart",
                  handedness: t.handedness,
                  target: this,
                }));
          } else
            null !== a &&
              t.gripSpace &&
              ((r = e.getPose(t.gripSpace, n)),
              null !== r &&
                (a.matrix.fromArray(r.transform.matrix),
                a.matrix.decompose(a.position, a.rotation, a.scale),
                r.linearVelocity
                  ? ((a.hasLinearVelocity = !0),
                    a.linearVelocity.copy(r.linearVelocity))
                  : (a.hasLinearVelocity = !1),
                r.angularVelocity
                  ? ((a.hasAngularVelocity = !0),
                    a.angularVelocity.copy(r.angularVelocity))
                  : (a.hasAngularVelocity = !1)));
        return (
          null !== o && (o.visible = null !== i),
          null !== a && (a.visible = null !== r),
          null !== l && (l.visible = null !== s),
          this
        );
      }
    }
    class Va extends yn {
      constructor(t, e, n, i, r, s, o, a, l, c) {
        if ((c = void 0 !== c ? c : Ht) !== Ht && c !== Bt)
          throw new Error(
            "DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"
          );
        void 0 === n && c === Ht && (n = Mt),
          void 0 === n && c === Bt && (n = Dt),
          super(null, i, r, s, o, a, c, n, l),
          (this.image = { width: t, height: e }),
          (this.magFilter = void 0 !== o ? o : mt),
          (this.minFilter = void 0 !== a ? a : mt),
          (this.flipY = !1),
          (this.generateMipmaps = !1);
      }
    }
    Va.prototype.isDepthTexture = !0;
    class Wa extends tn {
      constructor(t, e) {
        super();
        const n = this;
        let i = null,
          r = 1,
          s = null,
          o = "local-floor";
        const a = t.extensions.has("WEBGL_multisampled_render_to_texture");
        let l = null,
          c = null,
          u = null,
          h = null,
          d = !1,
          p = null;
        const f = e.getContextAttributes();
        let m = null,
          g = null;
        const v = [],
          y = new Map(),
          x = new Nr();
        x.layers.enable(1), (x.viewport = new bn());
        const b = new Nr();
        b.layers.enable(2), (b.viewport = new bn());
        const _ = [x, b],
          w = new Ha();
        w.layers.enable(1), w.layers.enable(2);
        let S = null,
          M = null;
        function T(t) {
          const e = y.get(t.inputSource);
          e && e.dispatchEvent({ type: t.type, data: t.inputSource });
        }
        function E() {
          y.forEach(function (t, e) {
            t.disconnect(e);
          }),
            y.clear(),
            (S = null),
            (M = null),
            t.setRenderTarget(m),
            (h = null),
            (u = null),
            (c = null),
            (i = null),
            (g = null),
            D.stop(),
            (n.isPresenting = !1),
            n.dispatchEvent({ type: "sessionend" });
        }
        function A(t) {
          const e = i.inputSources;
          for (let t = 0; t < v.length; t++) y.set(e[t], v[t]);
          for (let e = 0; e < t.removed.length; e++) {
            const n = t.removed[e],
              i = y.get(n);
            i &&
              (i.dispatchEvent({ type: "disconnected", data: n }), y.delete(n));
          }
          for (let e = 0; e < t.added.length; e++) {
            const n = t.added[e],
              i = y.get(n);
            i && i.dispatchEvent({ type: "connected", data: n });
          }
        }
        (this.cameraAutoUpdate = !0),
          (this.enabled = !1),
          (this.isPresenting = !1),
          (this.getController = function (t) {
            let e = v[t];
            return (
              void 0 === e && ((e = new Fa()), (v[t] = e)),
              e.getTargetRaySpace()
            );
          }),
          (this.getControllerGrip = function (t) {
            let e = v[t];
            return (
              void 0 === e && ((e = new Fa()), (v[t] = e)), e.getGripSpace()
            );
          }),
          (this.getHand = function (t) {
            let e = v[t];
            return (
              void 0 === e && ((e = new Fa()), (v[t] = e)), e.getHandSpace()
            );
          }),
          (this.setFramebufferScaleFactor = function (t) {
            (r = t),
              !0 === n.isPresenting &&
                console.warn(
                  "THREE.WebXRManager: Cannot change framebuffer scale while presenting."
                );
          }),
          (this.setReferenceSpaceType = function (t) {
            (o = t),
              !0 === n.isPresenting &&
                console.warn(
                  "THREE.WebXRManager: Cannot change reference space type while presenting."
                );
          }),
          (this.getReferenceSpace = function () {
            return s;
          }),
          (this.getBaseLayer = function () {
            return null !== u ? u : h;
          }),
          (this.getBinding = function () {
            return c;
          }),
          (this.getFrame = function () {
            return p;
          }),
          (this.getSession = function () {
            return i;
          }),
          (this.setSession = async function (l) {
            if (((i = l), null !== i)) {
              if (
                ((m = t.getRenderTarget()),
                i.addEventListener("select", T),
                i.addEventListener("selectstart", T),
                i.addEventListener("selectend", T),
                i.addEventListener("squeeze", T),
                i.addEventListener("squeezestart", T),
                i.addEventListener("squeezeend", T),
                i.addEventListener("end", E),
                i.addEventListener("inputsourceschange", A),
                !0 !== f.xrCompatible && (await e.makeXRCompatible()),
                void 0 === i.renderState.layers ||
                  !1 === t.capabilities.isWebGL2)
              ) {
                const n = {
                  antialias: void 0 !== i.renderState.layers || f.antialias,
                  alpha: f.alpha,
                  depth: f.depth,
                  stencil: f.stencil,
                  framebufferScaleFactor: r,
                };
                (h = new XRWebGLLayer(i, e, n)),
                  i.updateRenderState({ baseLayer: h }),
                  (g = new _n(h.framebufferWidth, h.framebufferHeight, {
                    format: Nt,
                    type: _t,
                    encoding: t.outputEncoding,
                  }));
              } else {
                d = f.antialias;
                let n = null,
                  s = null,
                  o = null;
                f.depth &&
                  ((o = f.stencil ? 35056 : 33190),
                  (n = f.stencil ? Bt : Ht),
                  (s = f.stencil ? Dt : Mt));
                const l = {
                  colorFormat: f.alpha || d ? 32856 : 32849,
                  depthFormat: o,
                  scaleFactor: r,
                };
                (c = new XRWebGLBinding(i, e)),
                  (u = c.createProjectionLayer(l)),
                  i.updateRenderState({ layers: [u] }),
                  (g = d
                    ? new wn(u.textureWidth, u.textureHeight, {
                        format: Nt,
                        type: _t,
                        depthTexture: new Va(
                          u.textureWidth,
                          u.textureHeight,
                          s,
                          void 0,
                          void 0,
                          void 0,
                          void 0,
                          void 0,
                          void 0,
                          n
                        ),
                        stencilBuffer: f.stencil,
                        ignoreDepth: u.ignoreDepthValues,
                        useRenderToTexture: a,
                        encoding: t.outputEncoding,
                      })
                    : new _n(u.textureWidth, u.textureHeight, {
                        format: f.alpha ? Nt : It,
                        type: _t,
                        depthTexture: new Va(
                          u.textureWidth,
                          u.textureHeight,
                          s,
                          void 0,
                          void 0,
                          void 0,
                          void 0,
                          void 0,
                          void 0,
                          n
                        ),
                        stencilBuffer: f.stencil,
                        ignoreDepth: u.ignoreDepthValues,
                        encoding: t.outputEncoding,
                      }));
              }
              this.setFoveation(1),
                (s = await i.requestReferenceSpace(o)),
                D.setContext(i),
                D.start(),
                (n.isPresenting = !0),
                n.dispatchEvent({ type: "sessionstart" });
            }
          });
        const C = new Mn(),
          L = new Mn();
        function R(t, e) {
          null === e
            ? t.matrixWorld.copy(t.matrix)
            : t.matrixWorld.multiplyMatrices(e.matrixWorld, t.matrix),
            t.matrixWorldInverse.copy(t.matrixWorld).invert();
        }
        (this.updateCamera = function (t) {
          if (null === i) return;
          (w.near = b.near = x.near = t.near),
            (w.far = b.far = x.far = t.far),
            (S === w.near && M === w.far) ||
              (i.updateRenderState({ depthNear: w.near, depthFar: w.far }),
              (S = w.near),
              (M = w.far));
          const e = t.parent,
            n = w.cameras;
          R(w, e);
          for (let t = 0; t < n.length; t++) R(n[t], e);
          w.matrixWorld.decompose(w.position, w.quaternion, w.scale),
            t.position.copy(w.position),
            t.quaternion.copy(w.quaternion),
            t.scale.copy(w.scale),
            t.matrix.copy(w.matrix),
            t.matrixWorld.copy(w.matrixWorld);
          const r = t.children;
          for (let t = 0, e = r.length; t < e; t++) r[t].updateMatrixWorld(!0);
          2 === n.length
            ? (function (t, e, n) {
                C.setFromMatrixPosition(e.matrixWorld),
                  L.setFromMatrixPosition(n.matrixWorld);
                const i = C.distanceTo(L),
                  r = e.projectionMatrix.elements,
                  s = n.projectionMatrix.elements,
                  o = r[14] / (r[10] - 1),
                  a = r[14] / (r[10] + 1),
                  l = (r[9] + 1) / r[5],
                  c = (r[9] - 1) / r[5],
                  u = (r[8] - 1) / r[0],
                  h = (s[8] + 1) / s[0],
                  d = o * u,
                  p = o * h,
                  f = i / (-u + h),
                  m = f * -u;
                e.matrixWorld.decompose(t.position, t.quaternion, t.scale),
                  t.translateX(m),
                  t.translateZ(f),
                  t.matrixWorld.compose(t.position, t.quaternion, t.scale),
                  t.matrixWorldInverse.copy(t.matrixWorld).invert();
                const g = o + f,
                  v = a + f,
                  y = d - m,
                  x = p + (i - m),
                  b = ((l * a) / v) * g,
                  _ = ((c * a) / v) * g;
                t.projectionMatrix.makePerspective(y, x, b, _, g, v);
              })(w, x, b)
            : w.projectionMatrix.copy(x.projectionMatrix);
        }),
          (this.getCamera = function () {
            return w;
          }),
          (this.getFoveation = function () {
            return null !== u
              ? u.fixedFoveation
              : null !== h
              ? h.fixedFoveation
              : void 0;
          }),
          (this.setFoveation = function (t) {
            null !== u && (u.fixedFoveation = t),
              null !== h &&
                void 0 !== h.fixedFoveation &&
                (h.fixedFoveation = t);
          });
        let P = null;
        const D = new Xr();
        D.setAnimationLoop(function (e, n) {
          if (((l = n.getViewerPose(s)), (p = n), null !== l)) {
            const e = l.views;
            null !== h &&
              (t.setRenderTargetFramebuffer(g, h.framebuffer),
              t.setRenderTarget(g));
            let n = !1;
            e.length !== w.cameras.length && ((w.cameras.length = 0), (n = !0));
            for (let i = 0; i < e.length; i++) {
              const r = e[i];
              let s = null;
              if (null !== h) s = h.getViewport(r);
              else {
                const e = c.getViewSubImage(u, r);
                (s = e.viewport),
                  0 === i &&
                    (t.setRenderTargetTextures(
                      g,
                      e.colorTexture,
                      u.ignoreDepthValues ? void 0 : e.depthStencilTexture
                    ),
                    t.setRenderTarget(g));
              }
              const o = _[i];
              o.matrix.fromArray(r.transform.matrix),
                o.projectionMatrix.fromArray(r.projectionMatrix),
                o.viewport.set(s.x, s.y, s.width, s.height),
                0 === i && w.matrix.copy(o.matrix),
                !0 === n && w.cameras.push(o);
            }
          }
          const r = i.inputSources;
          for (let t = 0; t < v.length; t++) {
            const e = v[t],
              i = r[t];
            e.update(i, n, s);
          }
          P && P(e, n), (p = null);
        }),
          (this.setAnimationLoop = function (t) {
            P = t;
          }),
          (this.dispose = function () {});
      }
    }
    function Ga(t) {
      function e(e, n) {
        (e.opacity.value = n.opacity),
          n.color && e.diffuse.value.copy(n.color),
          n.emissive &&
            e.emissive.value
              .copy(n.emissive)
              .multiplyScalar(n.emissiveIntensity),
          n.map && (e.map.value = n.map),
          n.alphaMap && (e.alphaMap.value = n.alphaMap),
          n.specularMap && (e.specularMap.value = n.specularMap),
          n.alphaTest > 0 && (e.alphaTest.value = n.alphaTest);
        const i = t.get(n).envMap;
        let r, s;
        i &&
          ((e.envMap.value = i),
          (e.flipEnvMap.value =
            i.isCubeTexture && !1 === i.isRenderTargetTexture ? -1 : 1),
          (e.reflectivity.value = n.reflectivity),
          (e.ior.value = n.ior),
          (e.refractionRatio.value = n.refractionRatio)),
          n.lightMap &&
            ((e.lightMap.value = n.lightMap),
            (e.lightMapIntensity.value = n.lightMapIntensity)),
          n.aoMap &&
            ((e.aoMap.value = n.aoMap),
            (e.aoMapIntensity.value = n.aoMapIntensity)),
          n.map
            ? (r = n.map)
            : n.specularMap
            ? (r = n.specularMap)
            : n.displacementMap
            ? (r = n.displacementMap)
            : n.normalMap
            ? (r = n.normalMap)
            : n.bumpMap
            ? (r = n.bumpMap)
            : n.roughnessMap
            ? (r = n.roughnessMap)
            : n.metalnessMap
            ? (r = n.metalnessMap)
            : n.alphaMap
            ? (r = n.alphaMap)
            : n.emissiveMap
            ? (r = n.emissiveMap)
            : n.clearcoatMap
            ? (r = n.clearcoatMap)
            : n.clearcoatNormalMap
            ? (r = n.clearcoatNormalMap)
            : n.clearcoatRoughnessMap
            ? (r = n.clearcoatRoughnessMap)
            : n.specularIntensityMap
            ? (r = n.specularIntensityMap)
            : n.specularColorMap
            ? (r = n.specularColorMap)
            : n.transmissionMap
            ? (r = n.transmissionMap)
            : n.thicknessMap
            ? (r = n.thicknessMap)
            : n.sheenColorMap
            ? (r = n.sheenColorMap)
            : n.sheenRoughnessMap && (r = n.sheenRoughnessMap),
          void 0 !== r &&
            (r.isWebGLRenderTarget && (r = r.texture),
            !0 === r.matrixAutoUpdate && r.updateMatrix(),
            e.uvTransform.value.copy(r.matrix)),
          n.aoMap ? (s = n.aoMap) : n.lightMap && (s = n.lightMap),
          void 0 !== s &&
            (s.isWebGLRenderTarget && (s = s.texture),
            !0 === s.matrixAutoUpdate && s.updateMatrix(),
            e.uv2Transform.value.copy(s.matrix));
      }
      function n(e, n) {
        (e.roughness.value = n.roughness),
          (e.metalness.value = n.metalness),
          n.roughnessMap && (e.roughnessMap.value = n.roughnessMap),
          n.metalnessMap && (e.metalnessMap.value = n.metalnessMap),
          n.emissiveMap && (e.emissiveMap.value = n.emissiveMap),
          n.bumpMap &&
            ((e.bumpMap.value = n.bumpMap),
            (e.bumpScale.value = n.bumpScale),
            n.side === g && (e.bumpScale.value *= -1)),
          n.normalMap &&
            ((e.normalMap.value = n.normalMap),
            e.normalScale.value.copy(n.normalScale),
            n.side === g && e.normalScale.value.negate()),
          n.displacementMap &&
            ((e.displacementMap.value = n.displacementMap),
            (e.displacementScale.value = n.displacementScale),
            (e.displacementBias.value = n.displacementBias)),
          t.get(n).envMap && (e.envMapIntensity.value = n.envMapIntensity);
      }
      return {
        refreshFogUniforms: function (t, e) {
          t.fogColor.value.copy(e.color),
            e.isFog
              ? ((t.fogNear.value = e.near), (t.fogFar.value = e.far))
              : e.isFogExp2 && (t.fogDensity.value = e.density);
        },
        refreshMaterialUniforms: function (t, i, r, s, o) {
          i.isMeshBasicMaterial
            ? e(t, i)
            : i.isMeshLambertMaterial
            ? (e(t, i),
              (function (t, e) {
                e.emissiveMap && (t.emissiveMap.value = e.emissiveMap);
              })(t, i))
            : i.isMeshToonMaterial
            ? (e(t, i),
              (function (t, e) {
                e.gradientMap && (t.gradientMap.value = e.gradientMap);
                e.emissiveMap && (t.emissiveMap.value = e.emissiveMap);
                e.bumpMap &&
                  ((t.bumpMap.value = e.bumpMap),
                  (t.bumpScale.value = e.bumpScale),
                  e.side === g && (t.bumpScale.value *= -1));
                e.normalMap &&
                  ((t.normalMap.value = e.normalMap),
                  t.normalScale.value.copy(e.normalScale),
                  e.side === g && t.normalScale.value.negate());
                e.displacementMap &&
                  ((t.displacementMap.value = e.displacementMap),
                  (t.displacementScale.value = e.displacementScale),
                  (t.displacementBias.value = e.displacementBias));
              })(t, i))
            : i.isMeshPhongMaterial
            ? (e(t, i),
              (function (t, e) {
                t.specular.value.copy(e.specular),
                  (t.shininess.value = Math.max(e.shininess, 1e-4)),
                  e.emissiveMap && (t.emissiveMap.value = e.emissiveMap);
                e.bumpMap &&
                  ((t.bumpMap.value = e.bumpMap),
                  (t.bumpScale.value = e.bumpScale),
                  e.side === g && (t.bumpScale.value *= -1));
                e.normalMap &&
                  ((t.normalMap.value = e.normalMap),
                  t.normalScale.value.copy(e.normalScale),
                  e.side === g && t.normalScale.value.negate());
                e.displacementMap &&
                  ((t.displacementMap.value = e.displacementMap),
                  (t.displacementScale.value = e.displacementScale),
                  (t.displacementBias.value = e.displacementBias));
              })(t, i))
            : i.isMeshStandardMaterial
            ? (e(t, i),
              i.isMeshPhysicalMaterial
                ? (function (t, e, i) {
                    n(t, e),
                      (t.ior.value = e.ior),
                      e.sheen > 0 &&
                        (t.sheenColor.value
                          .copy(e.sheenColor)
                          .multiplyScalar(e.sheen),
                        (t.sheenRoughness.value = e.sheenRoughness),
                        e.sheenColorMap &&
                          (t.sheenColorMap.value = e.sheenColorMap),
                        e.sheenRoughnessMap &&
                          (t.sheenRoughnessMap.value = e.sheenRoughnessMap));
                    e.clearcoat > 0 &&
                      ((t.clearcoat.value = e.clearcoat),
                      (t.clearcoatRoughness.value = e.clearcoatRoughness),
                      e.clearcoatMap && (t.clearcoatMap.value = e.clearcoatMap),
                      e.clearcoatRoughnessMap &&
                        (t.clearcoatRoughnessMap.value =
                          e.clearcoatRoughnessMap),
                      e.clearcoatNormalMap &&
                        (t.clearcoatNormalScale.value.copy(
                          e.clearcoatNormalScale
                        ),
                        (t.clearcoatNormalMap.value = e.clearcoatNormalMap),
                        e.side === g && t.clearcoatNormalScale.value.negate()));
                    e.transmission > 0 &&
                      ((t.transmission.value = e.transmission),
                      (t.transmissionSamplerMap.value = i.texture),
                      t.transmissionSamplerSize.value.set(i.width, i.height),
                      e.transmissionMap &&
                        (t.transmissionMap.value = e.transmissionMap),
                      (t.thickness.value = e.thickness),
                      e.thicknessMap && (t.thicknessMap.value = e.thicknessMap),
                      (t.attenuationDistance.value = e.attenuationDistance),
                      t.attenuationColor.value.copy(e.attenuationColor));
                    (t.specularIntensity.value = e.specularIntensity),
                      t.specularColor.value.copy(e.specularColor),
                      e.specularIntensityMap &&
                        (t.specularIntensityMap.value = e.specularIntensityMap);
                    e.specularColorMap &&
                      (t.specularColorMap.value = e.specularColorMap);
                  })(t, i, o)
                : n(t, i))
            : i.isMeshMatcapMaterial
            ? (e(t, i),
              (function (t, e) {
                e.matcap && (t.matcap.value = e.matcap);
                e.bumpMap &&
                  ((t.bumpMap.value = e.bumpMap),
                  (t.bumpScale.value = e.bumpScale),
                  e.side === g && (t.bumpScale.value *= -1));
                e.normalMap &&
                  ((t.normalMap.value = e.normalMap),
                  t.normalScale.value.copy(e.normalScale),
                  e.side === g && t.normalScale.value.negate());
                e.displacementMap &&
                  ((t.displacementMap.value = e.displacementMap),
                  (t.displacementScale.value = e.displacementScale),
                  (t.displacementBias.value = e.displacementBias));
              })(t, i))
            : i.isMeshDepthMaterial
            ? (e(t, i),
              (function (t, e) {
                e.displacementMap &&
                  ((t.displacementMap.value = e.displacementMap),
                  (t.displacementScale.value = e.displacementScale),
                  (t.displacementBias.value = e.displacementBias));
              })(t, i))
            : i.isMeshDistanceMaterial
            ? (e(t, i),
              (function (t, e) {
                e.displacementMap &&
                  ((t.displacementMap.value = e.displacementMap),
                  (t.displacementScale.value = e.displacementScale),
                  (t.displacementBias.value = e.displacementBias));
                t.referencePosition.value.copy(e.referencePosition),
                  (t.nearDistance.value = e.nearDistance),
                  (t.farDistance.value = e.farDistance);
              })(t, i))
            : i.isMeshNormalMaterial
            ? (e(t, i),
              (function (t, e) {
                e.bumpMap &&
                  ((t.bumpMap.value = e.bumpMap),
                  (t.bumpScale.value = e.bumpScale),
                  e.side === g && (t.bumpScale.value *= -1));
                e.normalMap &&
                  ((t.normalMap.value = e.normalMap),
                  t.normalScale.value.copy(e.normalScale),
                  e.side === g && t.normalScale.value.negate());
                e.displacementMap &&
                  ((t.displacementMap.value = e.displacementMap),
                  (t.displacementScale.value = e.displacementScale),
                  (t.displacementBias.value = e.displacementBias));
              })(t, i))
            : i.isLineBasicMaterial
            ? ((function (t, e) {
                t.diffuse.value.copy(e.color), (t.opacity.value = e.opacity);
              })(t, i),
              i.isLineDashedMaterial &&
                (function (t, e) {
                  (t.dashSize.value = e.dashSize),
                    (t.totalSize.value = e.dashSize + e.gapSize),
                    (t.scale.value = e.scale);
                })(t, i))
            : i.isPointsMaterial
            ? (function (t, e, n, i) {
                t.diffuse.value.copy(e.color),
                  (t.opacity.value = e.opacity),
                  (t.size.value = e.size * n),
                  (t.scale.value = 0.5 * i),
                  e.map && (t.map.value = e.map);
                e.alphaMap && (t.alphaMap.value = e.alphaMap);
                e.alphaTest > 0 && (t.alphaTest.value = e.alphaTest);
                let r;
                e.map ? (r = e.map) : e.alphaMap && (r = e.alphaMap);
                void 0 !== r &&
                  (!0 === r.matrixAutoUpdate && r.updateMatrix(),
                  t.uvTransform.value.copy(r.matrix));
              })(t, i, r, s)
            : i.isSpriteMaterial
            ? (function (t, e) {
                t.diffuse.value.copy(e.color),
                  (t.opacity.value = e.opacity),
                  (t.rotation.value = e.rotation),
                  e.map && (t.map.value = e.map);
                e.alphaMap && (t.alphaMap.value = e.alphaMap);
                e.alphaTest > 0 && (t.alphaTest.value = e.alphaTest);
                let n;
                e.map ? (n = e.map) : e.alphaMap && (n = e.alphaMap);
                void 0 !== n &&
                  (!0 === n.matrixAutoUpdate && n.updateMatrix(),
                  t.uvTransform.value.copy(n.matrix));
              })(t, i)
            : i.isShadowMaterial
            ? (t.color.value.copy(i.color), (t.opacity.value = i.opacity))
            : i.isShaderMaterial && (i.uniformsNeedUpdate = !1);
        },
      };
    }
    function ja(t = {}) {
      const e =
          void 0 !== t.canvas
            ? t.canvas
            : (function () {
                const t = fn("canvas");
                return (t.style.display = "block"), t;
              })(),
        n = void 0 !== t.context ? t.context : null,
        i = void 0 !== t.alpha && t.alpha,
        r = void 0 === t.depth || t.depth,
        s = void 0 === t.stencil || t.stencil,
        o = void 0 !== t.antialias && t.antialias,
        a = void 0 === t.premultipliedAlpha || t.premultipliedAlpha,
        c = void 0 !== t.preserveDrawingBuffer && t.preserveDrawingBuffer,
        u = void 0 !== t.powerPreference ? t.powerPreference : "default",
        h =
          void 0 !== t.failIfMajorPerformanceCaveat &&
          t.failIfMajorPerformanceCaveat;
      let d = null,
        p = null;
      const f = [],
        y = [];
      (this.domElement = e),
        (this.debug = { checkShaderErrors: !0 }),
        (this.autoClear = !0),
        (this.autoClearColor = !0),
        (this.autoClearDepth = !0),
        (this.autoClearStencil = !0),
        (this.sortObjects = !0),
        (this.clippingPlanes = []),
        (this.localClippingEnabled = !1),
        (this.outputEncoding = We),
        (this.physicallyCorrectLights = !1),
        (this.toneMapping = K),
        (this.toneMappingExposure = 1);
      const x = this;
      let b = !1,
        _ = 0,
        w = 0,
        S = null,
        M = -1,
        T = null;
      const E = new bn(),
        A = new bn();
      let C = null,
        L = e.width,
        R = e.height,
        P = 1,
        D = null,
        k = null;
      const I = new bn(0, 0, L, R),
        N = new bn(0, 0, L, R);
      let O = !1;
      const z = [],
        H = new $r();
      let B = !1,
        U = !1,
        F = null;
      const V = new ei(),
        W = new Mn(),
        G = {
          background: null,
          fog: null,
          environment: null,
          overrideMaterial: null,
          isScene: !0,
        };
      function j() {
        return null === S ? P : 1;
      }
      let q,
        $,
        X,
        J,
        Y,
        Z,
        Q,
        tt,
        et,
        nt,
        it,
        rt,
        st,
        ot,
        at,
        lt,
        ct,
        ut,
        ht,
        dt,
        ft,
        gt,
        vt,
        yt = n;
      function xt(t, n) {
        for (let i = 0; i < t.length; i++) {
          const r = t[i],
            s = e.getContext(r, n);
          if (null !== s) return s;
        }
        return null;
      }
      try {
        const t = {
          alpha: i,
          depth: r,
          stencil: s,
          antialias: o,
          premultipliedAlpha: a,
          preserveDrawingBuffer: c,
          powerPreference: u,
          failIfMajorPerformanceCaveat: h,
        };
        if (
          ("setAttribute" in e &&
            e.setAttribute("data-engine", `three.js r${l}`),
          e.addEventListener("webglcontextlost", Mt, !1),
          e.addEventListener("webglcontextrestored", Tt, !1),
          null === yt)
        ) {
          const e = ["webgl2", "webgl", "experimental-webgl"];
          if (
            (!0 === x.isWebGL1Renderer && e.shift(),
            (yt = xt(e, t)),
            null === yt)
          )
            throw xt(e)
              ? new Error(
                  "Error creating WebGL context with your selected attributes."
                )
              : new Error("Error creating WebGL context.");
        }
        void 0 === yt.getShaderPrecisionFormat &&
          (yt.getShaderPrecisionFormat = function () {
            return { rangeMin: 1, rangeMax: 1, precision: 1 };
          });
      } catch (t) {
        throw (console.error("THREE.WebGLRenderer: " + t.message), t);
      }
      function wt() {
        (q = new ks(yt)),
          ($ = new is(yt, q, t)),
          q.init($),
          (gt = new za(yt, q, $)),
          (X = new Na(yt, q, $)),
          (z[0] = 1029),
          (J = new Os(yt)),
          (Y = new xa()),
          (Z = new Oa(yt, q, X, Y, $, gt, J)),
          (Q = new ss(x)),
          (tt = new Ds(x)),
          (et = new Jr(yt, $)),
          (vt = new es(yt, q, et, $)),
          (nt = new Is(yt, et, J, vt)),
          (it = new Vs(yt, nt, et, J)),
          (ht = new Fs(yt, $, Z)),
          (lt = new rs(Y)),
          (rt = new ya(x, Q, tt, q, $, vt, lt)),
          (st = new Ga(Y)),
          (ot = new Sa()),
          (at = new La(q, $)),
          (ut = new ts(x, Q, X, it, a)),
          (ct = new Ia(x, it, $)),
          (dt = new ns(yt, q, J, $)),
          (ft = new Ns(yt, q, J, $)),
          (J.programs = rt.programs),
          (x.capabilities = $),
          (x.extensions = q),
          (x.properties = Y),
          (x.renderLists = ot),
          (x.shadowMap = ct),
          (x.state = X),
          (x.info = J);
      }
      wt();
      const St = new Wa(x, yt);
      function Mt(t) {
        t.preventDefault(),
          console.log("THREE.WebGLRenderer: Context Lost."),
          (b = !0);
      }
      function Tt() {
        console.log("THREE.WebGLRenderer: Context Restored."), (b = !1);
        const t = J.autoReset,
          e = ct.enabled,
          n = ct.autoUpdate,
          i = ct.needsUpdate,
          r = ct.type;
        wt(),
          (J.autoReset = t),
          (ct.enabled = e),
          (ct.autoUpdate = n),
          (ct.needsUpdate = i),
          (ct.type = r);
      }
      function Et(t) {
        const e = t.target;
        e.removeEventListener("dispose", Et),
          (function (t) {
            (function (t) {
              const e = Y.get(t).programs;
              void 0 !== e &&
                (e.forEach(function (t) {
                  rt.releaseProgram(t);
                }),
                t.isShaderMaterial && rt.releaseShaderCache(t));
            })(t),
              Y.remove(t);
          })(e);
      }
      (this.xr = St),
        (this.getContext = function () {
          return yt;
        }),
        (this.getContextAttributes = function () {
          return yt.getContextAttributes();
        }),
        (this.forceContextLoss = function () {
          const t = q.get("WEBGL_lose_context");
          t && t.loseContext();
        }),
        (this.forceContextRestore = function () {
          const t = q.get("WEBGL_lose_context");
          t && t.restoreContext();
        }),
        (this.getPixelRatio = function () {
          return P;
        }),
        (this.setPixelRatio = function (t) {
          void 0 !== t && ((P = t), this.setSize(L, R, !1));
        }),
        (this.getSize = function (t) {
          return t.set(L, R);
        }),
        (this.setSize = function (t, n, i) {
          St.isPresenting
            ? console.warn(
                "THREE.WebGLRenderer: Can't change size while VR device is presenting."
              )
            : ((L = t),
              (R = n),
              (e.width = Math.floor(t * P)),
              (e.height = Math.floor(n * P)),
              !1 !== i &&
                ((e.style.width = t + "px"), (e.style.height = n + "px")),
              this.setViewport(0, 0, t, n));
        }),
        (this.getDrawingBufferSize = function (t) {
          return t.set(L * P, R * P).floor();
        }),
        (this.setDrawingBufferSize = function (t, n, i) {
          (L = t),
            (R = n),
            (P = i),
            (e.width = Math.floor(t * i)),
            (e.height = Math.floor(n * i)),
            this.setViewport(0, 0, t, n);
        }),
        (this.getCurrentViewport = function (t) {
          return t.copy(E);
        }),
        (this.getViewport = function (t) {
          return t.copy(I);
        }),
        (this.setViewport = function (t, e, n, i) {
          t.isVector4 ? I.set(t.x, t.y, t.z, t.w) : I.set(t, e, n, i),
            X.viewport(E.copy(I).multiplyScalar(P).floor());
        }),
        (this.getScissor = function (t) {
          return t.copy(N);
        }),
        (this.setScissor = function (t, e, n, i) {
          t.isVector4 ? N.set(t.x, t.y, t.z, t.w) : N.set(t, e, n, i),
            X.scissor(A.copy(N).multiplyScalar(P).floor());
        }),
        (this.getScissorTest = function () {
          return O;
        }),
        (this.setScissorTest = function (t) {
          X.setScissorTest((O = t));
        }),
        (this.setOpaqueSort = function (t) {
          D = t;
        }),
        (this.setTransparentSort = function (t) {
          k = t;
        }),
        (this.getClearColor = function (t) {
          return t.copy(ut.getClearColor());
        }),
        (this.setClearColor = function () {
          ut.setClearColor.apply(ut, arguments);
        }),
        (this.getClearAlpha = function () {
          return ut.getClearAlpha();
        }),
        (this.setClearAlpha = function () {
          ut.setClearAlpha.apply(ut, arguments);
        }),
        (this.clear = function (t, e, n) {
          let i = 0;
          (void 0 === t || t) && (i |= 16384),
            (void 0 === e || e) && (i |= 256),
            (void 0 === n || n) && (i |= 1024),
            yt.clear(i);
        }),
        (this.clearColor = function () {
          this.clear(!0, !1, !1);
        }),
        (this.clearDepth = function () {
          this.clear(!1, !0, !1);
        }),
        (this.clearStencil = function () {
          this.clear(!1, !1, !0);
        }),
        (this.dispose = function () {
          e.removeEventListener("webglcontextlost", Mt, !1),
            e.removeEventListener("webglcontextrestored", Tt, !1),
            ot.dispose(),
            at.dispose(),
            Y.dispose(),
            Q.dispose(),
            tt.dispose(),
            it.dispose(),
            vt.dispose(),
            rt.dispose(),
            St.dispose(),
            St.removeEventListener("sessionstart", Rt),
            St.removeEventListener("sessionend", Pt),
            F && (F.dispose(), (F = null)),
            Dt.stop();
        }),
        (this.renderBufferDirect = function (t, e, n, i, r, s) {
          null === e && (e = G);
          const o = r.isMesh && r.matrixWorld.determinant() < 0,
            a = (function (t, e, n, i, r) {
              !0 !== e.isScene && (e = G);
              Z.resetTextureUnits();
              const s = e.fog,
                o = i.isMeshStandardMaterial ? e.environment : null,
                a = null === S ? x.outputEncoding : S.texture.encoding,
                l = (i.isMeshStandardMaterial ? tt : Q).get(i.envMap || o),
                c =
                  !0 === i.vertexColors &&
                  !!n.attributes.color &&
                  4 === n.attributes.color.itemSize,
                u = !!i.normalMap && !!n.attributes.tangent,
                h = !!n.morphAttributes.position,
                d = !!n.morphAttributes.normal,
                f = n.morphAttributes.position
                  ? n.morphAttributes.position.length
                  : 0,
                m = i.toneMapped ? x.toneMapping : K,
                g = Y.get(i),
                v = p.state.lights;
              if (!0 === B && (!0 === U || t !== T)) {
                const e = t === T && i.id === M;
                lt.setState(i, t, e);
              }
              let y = !1;
              i.version === g.__version
                ? g.needsLights && g.lightsStateVersion !== v.state.version
                  ? (y = !0)
                  : g.outputEncoding !== a
                  ? (y = !0)
                  : r.isInstancedMesh && !1 === g.instancing
                  ? (y = !0)
                  : r.isInstancedMesh || !0 !== g.instancing
                  ? r.isSkinnedMesh && !1 === g.skinning
                    ? (y = !0)
                    : r.isSkinnedMesh || !0 !== g.skinning
                    ? g.envMap !== l
                      ? (y = !0)
                      : i.fog && g.fog !== s
                      ? (y = !0)
                      : void 0 === g.numClippingPlanes ||
                        (g.numClippingPlanes === lt.numPlanes &&
                          g.numIntersection === lt.numIntersection)
                      ? g.vertexAlphas !== c
                        ? (y = !0)
                        : g.vertexTangents !== u
                        ? (y = !0)
                        : g.morphTargets !== h
                        ? (y = !0)
                        : g.morphNormals !== d
                        ? (y = !0)
                        : g.toneMapping !== m
                        ? (y = !0)
                        : !0 === $.isWebGL2 &&
                          g.morphTargetsCount !== f &&
                          (y = !0)
                      : (y = !0)
                    : (y = !0)
                  : (y = !0)
                : ((y = !0), (g.__version = i.version));
              let b = g.currentProgram;
              !0 === y && (b = zt(i, e, r));
              let _ = !1,
                w = !1,
                E = !1;
              const A = b.getUniforms(),
                C = g.uniforms;
              X.useProgram(b.program) && ((_ = !0), (w = !0), (E = !0));
              i.id !== M && ((M = i.id), (w = !0));
              if (_ || T !== t) {
                if (
                  (A.setValue(yt, "projectionMatrix", t.projectionMatrix),
                  $.logarithmicDepthBuffer &&
                    A.setValue(
                      yt,
                      "logDepthBufFC",
                      2 / (Math.log(t.far + 1) / Math.LN2)
                    ),
                  T !== t && ((T = t), (w = !0), (E = !0)),
                  i.isShaderMaterial ||
                    i.isMeshPhongMaterial ||
                    i.isMeshToonMaterial ||
                    i.isMeshStandardMaterial ||
                    i.envMap)
                ) {
                  const e = A.map.cameraPosition;
                  void 0 !== e &&
                    e.setValue(yt, W.setFromMatrixPosition(t.matrixWorld));
                }
                (i.isMeshPhongMaterial ||
                  i.isMeshToonMaterial ||
                  i.isMeshLambertMaterial ||
                  i.isMeshBasicMaterial ||
                  i.isMeshStandardMaterial ||
                  i.isShaderMaterial) &&
                  A.setValue(
                    yt,
                    "isOrthographic",
                    !0 === t.isOrthographicCamera
                  ),
                  (i.isMeshPhongMaterial ||
                    i.isMeshToonMaterial ||
                    i.isMeshLambertMaterial ||
                    i.isMeshBasicMaterial ||
                    i.isMeshStandardMaterial ||
                    i.isShaderMaterial ||
                    i.isShadowMaterial ||
                    r.isSkinnedMesh) &&
                    A.setValue(yt, "viewMatrix", t.matrixWorldInverse);
              }
              if (r.isSkinnedMesh) {
                A.setOptional(yt, r, "bindMatrix"),
                  A.setOptional(yt, r, "bindMatrixInverse");
                const t = r.skeleton;
                t &&
                  ($.floatVertexTextures
                    ? (null === t.boneTexture && t.computeBoneTexture(),
                      A.setValue(yt, "boneTexture", t.boneTexture, Z),
                      A.setValue(yt, "boneTextureSize", t.boneTextureSize))
                    : A.setOptional(yt, t, "boneMatrices"));
              }
              !n ||
                (void 0 === n.morphAttributes.position &&
                  void 0 === n.morphAttributes.normal) ||
                ht.update(r, n, i, b);
              (w || g.receiveShadow !== r.receiveShadow) &&
                ((g.receiveShadow = r.receiveShadow),
                A.setValue(yt, "receiveShadow", r.receiveShadow));
              w &&
                (A.setValue(yt, "toneMappingExposure", x.toneMappingExposure),
                g.needsLights &&
                  ((D = E),
                  ((L = C).ambientLightColor.needsUpdate = D),
                  (L.lightProbe.needsUpdate = D),
                  (L.directionalLights.needsUpdate = D),
                  (L.directionalLightShadows.needsUpdate = D),
                  (L.pointLights.needsUpdate = D),
                  (L.pointLightShadows.needsUpdate = D),
                  (L.spotLights.needsUpdate = D),
                  (L.spotLightShadows.needsUpdate = D),
                  (L.rectAreaLights.needsUpdate = D),
                  (L.hemisphereLights.needsUpdate = D)),
                s && i.fog && st.refreshFogUniforms(C, s),
                st.refreshMaterialUniforms(C, i, P, R, F),
                Xo.upload(yt, g.uniformsList, C, Z));
              var L, D;
              i.isShaderMaterial &&
                !0 === i.uniformsNeedUpdate &&
                (Xo.upload(yt, g.uniformsList, C, Z),
                (i.uniformsNeedUpdate = !1));
              i.isSpriteMaterial && A.setValue(yt, "center", r.center);
              return (
                A.setValue(yt, "modelViewMatrix", r.modelViewMatrix),
                A.setValue(yt, "normalMatrix", r.normalMatrix),
                A.setValue(yt, "modelMatrix", r.matrixWorld),
                b
              );
            })(t, e, n, i, r);
          X.setMaterial(i, o);
          let l = n.index;
          const c = n.attributes.position;
          if (null === l) {
            if (void 0 === c || 0 === c.count) return;
          } else if (0 === l.count) return;
          let u,
            h = 1;
          !0 === i.wireframe && ((l = nt.getWireframeAttribute(n)), (h = 2)),
            vt.setup(r, i, a, n, l);
          let d = dt;
          null !== l && ((u = et.get(l)), (d = ft), d.setIndex(u));
          const f = null !== l ? l.count : c.count,
            m = n.drawRange.start * h,
            g = n.drawRange.count * h,
            v = null !== s ? s.start * h : 0,
            y = null !== s ? s.count * h : 1 / 0,
            b = Math.max(m, v),
            _ = Math.min(f, m + g, v + y) - 1,
            w = Math.max(0, _ - b + 1);
          if (0 !== w) {
            if (r.isMesh)
              !0 === i.wireframe
                ? (X.setLineWidth(i.wireframeLinewidth * j()), d.setMode(1))
                : d.setMode(4);
            else if (r.isLine) {
              let t = i.linewidth;
              void 0 === t && (t = 1),
                X.setLineWidth(t * j()),
                r.isLineSegments
                  ? d.setMode(1)
                  : r.isLineLoop
                  ? d.setMode(2)
                  : d.setMode(3);
            } else r.isPoints ? d.setMode(0) : r.isSprite && d.setMode(4);
            if (r.isInstancedMesh) d.renderInstances(b, w, r.count);
            else if (n.isInstancedBufferGeometry) {
              const t = Math.min(n.instanceCount, n._maxInstanceCount);
              d.renderInstances(b, w, t);
            } else d.render(b, w);
          }
        }),
        (this.compile = function (t, e) {
          (p = at.get(t)),
            p.init(),
            y.push(p),
            t.traverseVisible(function (t) {
              t.isLight &&
                t.layers.test(e.layers) &&
                (p.pushLight(t), t.castShadow && p.pushShadow(t));
            }),
            p.setupLights(x.physicallyCorrectLights),
            t.traverse(function (e) {
              const n = e.material;
              if (n)
                if (Array.isArray(n))
                  for (let i = 0; i < n.length; i++) {
                    zt(n[i], t, e);
                  }
                else zt(n, t, e);
            }),
            y.pop(),
            (p = null);
        });
      let Lt = null;
      function Rt() {
        Dt.stop();
      }
      function Pt() {
        Dt.start();
      }
      const Dt = new Xr();
      function kt(t, e, n, i) {
        const r = t.opaque,
          s = t.transmissive,
          a = t.transparent;
        p.setupLightsView(n),
          s.length > 0 &&
            (function (t, e, n) {
              if (null === F) {
                const t = !0 === o && !0 === $.isWebGL2;
                F = new (t ? wn : _n)(1024, 1024, {
                  generateMipmaps: !0,
                  type: null !== gt.convert(Ct) ? Ct : _t,
                  minFilter: bt,
                  magFilter: mt,
                  wrapS: pt,
                  wrapT: pt,
                  useRenderToTexture: q.has(
                    "WEBGL_multisampled_render_to_texture"
                  ),
                });
              }
              const i = x.getRenderTarget();
              x.setRenderTarget(F), x.clear();
              const r = x.toneMapping;
              (x.toneMapping = K),
                It(t, e, n),
                (x.toneMapping = r),
                Z.updateMultisampleRenderTarget(F),
                Z.updateRenderTargetMipmap(F),
                x.setRenderTarget(i);
            })(r, e, n),
          i && X.viewport(E.copy(i)),
          r.length > 0 && It(r, e, n),
          s.length > 0 && It(s, e, n),
          a.length > 0 && It(a, e, n);
      }
      function It(t, e, n) {
        const i = !0 === e.isScene ? e.overrideMaterial : null;
        for (let r = 0, s = t.length; r < s; r++) {
          const s = t[r],
            o = s.object,
            a = s.geometry,
            l = null === i ? s.material : i,
            c = s.group;
          o.layers.test(n.layers) && Ot(o, e, n, a, l, c);
        }
      }
      function Ot(t, e, n, i, r, s) {
        t.onBeforeRender(x, e, n, i, r, s),
          t.modelViewMatrix.multiplyMatrices(
            n.matrixWorldInverse,
            t.matrixWorld
          ),
          t.normalMatrix.getNormalMatrix(t.modelViewMatrix),
          r.onBeforeRender(x, e, n, i, t, s),
          !0 === r.transparent && r.side === v
            ? ((r.side = g),
              (r.needsUpdate = !0),
              x.renderBufferDirect(n, e, i, r, t, s),
              (r.side = m),
              (r.needsUpdate = !0),
              x.renderBufferDirect(n, e, i, r, t, s),
              (r.side = v))
            : x.renderBufferDirect(n, e, i, r, t, s),
          t.onAfterRender(x, e, n, i, r, s);
      }
      function zt(t, e, n) {
        !0 !== e.isScene && (e = G);
        const i = Y.get(t),
          r = p.state.lights,
          s = p.state.shadowsArray,
          o = r.state.version,
          a = rt.getParameters(t, r.state, s, e, n),
          l = rt.getProgramCacheKey(a);
        let c = i.programs;
        (i.environment = t.isMeshStandardMaterial ? e.environment : null),
          (i.fog = e.fog),
          (i.envMap = (t.isMeshStandardMaterial ? tt : Q).get(
            t.envMap || i.environment
          )),
          void 0 === c &&
            (t.addEventListener("dispose", Et),
            (c = new Map()),
            (i.programs = c));
        let u = c.get(l);
        if (void 0 !== u) {
          if (i.currentProgram === u && i.lightsStateVersion === o)
            return Ht(t, a), u;
        } else
          (a.uniforms = rt.getUniforms(t)),
            t.onBuild(n, a, x),
            t.onBeforeCompile(a, x),
            (u = rt.acquireProgram(a, l)),
            c.set(l, u),
            (i.uniforms = a.uniforms);
        const h = i.uniforms;
        ((t.isShaderMaterial || t.isRawShaderMaterial) && !0 !== t.clipping) ||
          (h.clippingPlanes = lt.uniform),
          Ht(t, a),
          (i.needsLights = (function (t) {
            return (
              t.isMeshLambertMaterial ||
              t.isMeshToonMaterial ||
              t.isMeshPhongMaterial ||
              t.isMeshStandardMaterial ||
              t.isShadowMaterial ||
              (t.isShaderMaterial && !0 === t.lights)
            );
          })(t)),
          (i.lightsStateVersion = o),
          i.needsLights &&
            ((h.ambientLightColor.value = r.state.ambient),
            (h.lightProbe.value = r.state.probe),
            (h.directionalLights.value = r.state.directional),
            (h.directionalLightShadows.value = r.state.directionalShadow),
            (h.spotLights.value = r.state.spot),
            (h.spotLightShadows.value = r.state.spotShadow),
            (h.rectAreaLights.value = r.state.rectArea),
            (h.ltc_1.value = r.state.rectAreaLTC1),
            (h.ltc_2.value = r.state.rectAreaLTC2),
            (h.pointLights.value = r.state.point),
            (h.pointLightShadows.value = r.state.pointShadow),
            (h.hemisphereLights.value = r.state.hemi),
            (h.directionalShadowMap.value = r.state.directionalShadowMap),
            (h.directionalShadowMatrix.value = r.state.directionalShadowMatrix),
            (h.spotShadowMap.value = r.state.spotShadowMap),
            (h.spotShadowMatrix.value = r.state.spotShadowMatrix),
            (h.pointShadowMap.value = r.state.pointShadowMap),
            (h.pointShadowMatrix.value = r.state.pointShadowMatrix));
        const d = u.getUniforms(),
          f = Xo.seqWithValue(d.seq, h);
        return (i.currentProgram = u), (i.uniformsList = f), u;
      }
      function Ht(t, e) {
        const n = Y.get(t);
        (n.outputEncoding = e.outputEncoding),
          (n.instancing = e.instancing),
          (n.skinning = e.skinning),
          (n.morphTargets = e.morphTargets),
          (n.morphNormals = e.morphNormals),
          (n.morphTargetsCount = e.morphTargetsCount),
          (n.numClippingPlanes = e.numClippingPlanes),
          (n.numIntersection = e.numClipIntersection),
          (n.vertexAlphas = e.vertexAlphas),
          (n.vertexTangents = e.vertexTangents),
          (n.toneMapping = e.toneMapping);
      }
      Dt.setAnimationLoop(function (t) {
        Lt && Lt(t);
      }),
        "undefined" != typeof window && Dt.setContext(window),
        (this.setAnimationLoop = function (t) {
          (Lt = t), St.setAnimationLoop(t), null === t ? Dt.stop() : Dt.start();
        }),
        St.addEventListener("sessionstart", Rt),
        St.addEventListener("sessionend", Pt),
        (this.render = function (t, e) {
          if (void 0 !== e && !0 !== e.isCamera)
            return void console.error(
              "THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."
            );
          if (!0 === b) return;
          !0 === t.autoUpdate && t.updateMatrixWorld(),
            null === e.parent && e.updateMatrixWorld(),
            !0 === St.enabled &&
              !0 === St.isPresenting &&
              (!0 === St.cameraAutoUpdate && St.updateCamera(e),
              (e = St.getCamera())),
            !0 === t.isScene && t.onBeforeRender(x, t, e, S),
            (p = at.get(t, y.length)),
            p.init(),
            y.push(p),
            V.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse),
            H.setFromProjectionMatrix(V),
            (U = this.localClippingEnabled),
            (B = lt.init(this.clippingPlanes, U, e)),
            (d = ot.get(t, f.length)),
            d.init(),
            f.push(d),
            (function t(e, n, i, r) {
              if (!1 === e.visible) return;
              if (e.layers.test(n.layers))
                if (e.isGroup) i = e.renderOrder;
                else if (e.isLOD) !0 === e.autoUpdate && e.update(n);
                else if (e.isLight)
                  p.pushLight(e), e.castShadow && p.pushShadow(e);
                else if (e.isSprite) {
                  if (!e.frustumCulled || H.intersectsSprite(e)) {
                    r && W.setFromMatrixPosition(e.matrixWorld).applyMatrix4(V);
                    const t = it.update(e),
                      n = e.material;
                    n.visible && d.push(e, t, n, i, W.z, null);
                  }
                } else if (
                  (e.isMesh || e.isLine || e.isPoints) &&
                  (e.isSkinnedMesh &&
                    e.skeleton.frame !== J.render.frame &&
                    (e.skeleton.update(), (e.skeleton.frame = J.render.frame)),
                  !e.frustumCulled || H.intersectsObject(e))
                ) {
                  r && W.setFromMatrixPosition(e.matrixWorld).applyMatrix4(V);
                  const t = it.update(e),
                    n = e.material;
                  if (Array.isArray(n)) {
                    const r = t.groups;
                    for (let s = 0, o = r.length; s < o; s++) {
                      const o = r[s],
                        a = n[o.materialIndex];
                      a && a.visible && d.push(e, t, a, i, W.z, o);
                    }
                  } else n.visible && d.push(e, t, n, i, W.z, null);
                }
              const s = e.children;
              for (let e = 0, o = s.length; e < o; e++) t(s[e], n, i, r);
            })(t, e, 0, x.sortObjects),
            d.finish(),
            !0 === x.sortObjects && d.sort(D, k),
            !0 === B && lt.beginShadows();
          const n = p.state.shadowsArray;
          if (
            (ct.render(n, t, e),
            !0 === B && lt.endShadows(),
            !0 === this.info.autoReset && this.info.reset(),
            ut.render(d, t),
            p.setupLights(x.physicallyCorrectLights),
            e.isArrayCamera)
          ) {
            const n = e.cameras;
            for (let e = 0, i = n.length; e < i; e++) {
              const i = n[e];
              kt(d, t, i, i.viewport);
            }
          } else kt(d, t, e);
          null !== S &&
            (Z.updateMultisampleRenderTarget(S), Z.updateRenderTargetMipmap(S)),
            !0 === t.isScene && t.onAfterRender(x, t, e),
            X.buffers.depth.setTest(!0),
            X.buffers.depth.setMask(!0),
            X.buffers.color.setMask(!0),
            X.setPolygonOffset(!1),
            vt.resetDefaultState(),
            (M = -1),
            (T = null),
            y.pop(),
            (p = y.length > 0 ? y[y.length - 1] : null),
            f.pop(),
            (d = f.length > 0 ? f[f.length - 1] : null);
        }),
        (this.getActiveCubeFace = function () {
          return _;
        }),
        (this.getActiveMipmapLevel = function () {
          return w;
        }),
        (this.getRenderTarget = function () {
          return S;
        }),
        (this.setRenderTargetTextures = function (t, e, n) {
          (Y.get(t.texture).__webglTexture = e),
            (Y.get(t.depthTexture).__webglTexture = n);
          const i = Y.get(t);
          (i.__hasExternalTextures = !0),
            i.__hasExternalTextures &&
              ((i.__autoAllocateDepthBuffer = void 0 === n),
              i.__autoAllocateDepthBuffer ||
                (t.useRenderToTexture &&
                  (console.warn(
                    "render-to-texture extension was disabled because an external texture was provided"
                  ),
                  (t.useRenderToTexture = !1),
                  (t.useRenderbuffer = !0))));
        }),
        (this.setRenderTargetFramebuffer = function (t, e) {
          const n = Y.get(t);
          (n.__webglFramebuffer = e),
            (n.__useDefaultFramebuffer = void 0 === e);
        }),
        (this.setRenderTarget = function (t, e = 0, n = 0) {
          (S = t), (_ = e), (w = n);
          let i = !0;
          if (t) {
            const e = Y.get(t);
            void 0 !== e.__useDefaultFramebuffer
              ? (X.bindFramebuffer(36160, null), (i = !1))
              : void 0 === e.__webglFramebuffer
              ? Z.setupRenderTarget(t)
              : e.__hasExternalTextures &&
                Z.rebindTextures(
                  t,
                  Y.get(t.texture).__webglTexture,
                  Y.get(t.depthTexture).__webglTexture
                );
          }
          let r = null,
            s = !1,
            o = !1;
          if (t) {
            const n = t.texture;
            (n.isDataTexture3D || n.isDataTexture2DArray) && (o = !0);
            const i = Y.get(t).__webglFramebuffer;
            t.isWebGLCubeRenderTarget
              ? ((r = i[e]), (s = !0))
              : (r = t.useRenderbuffer
                  ? Y.get(t).__webglMultisampledFramebuffer
                  : i),
              E.copy(t.viewport),
              A.copy(t.scissor),
              (C = t.scissorTest);
          } else
            E.copy(I).multiplyScalar(P).floor(),
              A.copy(N).multiplyScalar(P).floor(),
              (C = O);
          if (X.bindFramebuffer(36160, r) && $.drawBuffers && i) {
            let e = !1;
            if (t)
              if (t.isWebGLMultipleRenderTargets) {
                const n = t.texture;
                if (z.length !== n.length || 36064 !== z[0]) {
                  for (let t = 0, e = n.length; t < e; t++) z[t] = 36064 + t;
                  (z.length = n.length), (e = !0);
                }
              } else
                (1 === z.length && 36064 === z[0]) ||
                  ((z[0] = 36064), (z.length = 1), (e = !0));
            else
              (1 === z.length && 1029 === z[0]) ||
                ((z[0] = 1029), (z.length = 1), (e = !0));
            e &&
              ($.isWebGL2
                ? yt.drawBuffers(z)
                : q.get("WEBGL_draw_buffers").drawBuffersWEBGL(z));
          }
          if ((X.viewport(E), X.scissor(A), X.setScissorTest(C), s)) {
            const i = Y.get(t.texture);
            yt.framebufferTexture2D(
              36160,
              36064,
              34069 + e,
              i.__webglTexture,
              n
            );
          } else if (o) {
            const i = Y.get(t.texture),
              r = e || 0;
            yt.framebufferTextureLayer(
              36160,
              36064,
              i.__webglTexture,
              n || 0,
              r
            );
          }
          M = -1;
        }),
        (this.readRenderTargetPixels = function (t, e, n, i, r, s, o) {
          if (!t || !t.isWebGLRenderTarget)
            return void console.error(
              "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."
            );
          let a = Y.get(t).__webglFramebuffer;
          if ((t.isWebGLCubeRenderTarget && void 0 !== o && (a = a[o]), a)) {
            X.bindFramebuffer(36160, a);
            try {
              const o = t.texture,
                a = o.format,
                l = o.type;
              if (a !== Nt && gt.convert(a) !== yt.getParameter(35739))
                return void console.error(
                  "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."
                );
              const c =
                l === Ct &&
                (q.has("EXT_color_buffer_half_float") ||
                  ($.isWebGL2 && q.has("EXT_color_buffer_float")));
              if (
                !(
                  l === _t ||
                  gt.convert(l) === yt.getParameter(35738) ||
                  (l === At &&
                    ($.isWebGL2 ||
                      q.has("OES_texture_float") ||
                      q.has("WEBGL_color_buffer_float"))) ||
                  c
                )
              )
                return void console.error(
                  "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."
                );
              36053 === yt.checkFramebufferStatus(36160)
                ? e >= 0 &&
                  e <= t.width - i &&
                  n >= 0 &&
                  n <= t.height - r &&
                  yt.readPixels(e, n, i, r, gt.convert(a), gt.convert(l), s)
                : console.error(
                    "THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete."
                  );
            } finally {
              const t = null !== S ? Y.get(S).__webglFramebuffer : null;
              X.bindFramebuffer(36160, t);
            }
          }
        }),
        (this.copyFramebufferToTexture = function (t, e, n = 0) {
          if (!0 !== e.isFramebufferTexture)
            return void console.error(
              "THREE.WebGLRenderer: copyFramebufferToTexture() can only be used with FramebufferTexture."
            );
          const i = Math.pow(2, -n),
            r = Math.floor(e.image.width * i),
            s = Math.floor(e.image.height * i);
          Z.setTexture2D(e, 0),
            yt.copyTexSubImage2D(3553, n, 0, 0, t.x, t.y, r, s),
            X.unbindTexture();
        }),
        (this.copyTextureToTexture = function (t, e, n, i = 0) {
          const r = e.image.width,
            s = e.image.height,
            o = gt.convert(n.format),
            a = gt.convert(n.type);
          Z.setTexture2D(n, 0),
            yt.pixelStorei(37440, n.flipY),
            yt.pixelStorei(37441, n.premultiplyAlpha),
            yt.pixelStorei(3317, n.unpackAlignment),
            e.isDataTexture
              ? yt.texSubImage2D(3553, i, t.x, t.y, r, s, o, a, e.image.data)
              : e.isCompressedTexture
              ? yt.compressedTexSubImage2D(
                  3553,
                  i,
                  t.x,
                  t.y,
                  e.mipmaps[0].width,
                  e.mipmaps[0].height,
                  o,
                  e.mipmaps[0].data
                )
              : yt.texSubImage2D(3553, i, t.x, t.y, o, a, e.image),
            0 === i && n.generateMipmaps && yt.generateMipmap(3553),
            X.unbindTexture();
        }),
        (this.copyTextureToTexture3D = function (t, e, n, i, r = 0) {
          if (x.isWebGL1Renderer)
            return void console.warn(
              "THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2."
            );
          const s = t.max.x - t.min.x + 1,
            o = t.max.y - t.min.y + 1,
            a = t.max.z - t.min.z + 1,
            l = gt.convert(i.format),
            c = gt.convert(i.type);
          let u;
          if (i.isDataTexture3D) Z.setTexture3D(i, 0), (u = 32879);
          else {
            if (!i.isDataTexture2DArray)
              return void console.warn(
                "THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray."
              );
            Z.setTexture2DArray(i, 0), (u = 35866);
          }
          yt.pixelStorei(37440, i.flipY),
            yt.pixelStorei(37441, i.premultiplyAlpha),
            yt.pixelStorei(3317, i.unpackAlignment);
          const h = yt.getParameter(3314),
            d = yt.getParameter(32878),
            p = yt.getParameter(3316),
            f = yt.getParameter(3315),
            m = yt.getParameter(32877),
            g = n.isCompressedTexture ? n.mipmaps[0] : n.image;
          yt.pixelStorei(3314, g.width),
            yt.pixelStorei(32878, g.height),
            yt.pixelStorei(3316, t.min.x),
            yt.pixelStorei(3315, t.min.y),
            yt.pixelStorei(32877, t.min.z),
            n.isDataTexture || n.isDataTexture3D
              ? yt.texSubImage3D(u, r, e.x, e.y, e.z, s, o, a, l, c, g.data)
              : n.isCompressedTexture
              ? (console.warn(
                  "THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."
                ),
                yt.compressedTexSubImage3D(
                  u,
                  r,
                  e.x,
                  e.y,
                  e.z,
                  s,
                  o,
                  a,
                  l,
                  g.data
                ))
              : yt.texSubImage3D(u, r, e.x, e.y, e.z, s, o, a, l, c, g),
            yt.pixelStorei(3314, h),
            yt.pixelStorei(32878, d),
            yt.pixelStorei(3316, p),
            yt.pixelStorei(3315, f),
            yt.pixelStorei(32877, m),
            0 === r && i.generateMipmaps && yt.generateMipmap(u),
            X.unbindTexture();
        }),
        (this.initTexture = function (t) {
          Z.setTexture2D(t, 0), X.unbindTexture();
        }),
        (this.resetState = function () {
          (_ = 0), (w = 0), (S = null), X.reset(), vt.reset();
        }),
        "undefined" != typeof __THREE_DEVTOOLS__ &&
          __THREE_DEVTOOLS__.dispatchEvent(
            new CustomEvent("observe", { detail: this })
          );
    }
    ja.prototype.isWebGLRenderer = !0;
    (class extends ja {}.prototype.isWebGL1Renderer = !0);
    class qa {
      constructor(t, e = 25e-5) {
        (this.name = ""), (this.color = new qi(t)), (this.density = e);
      }
      clone() {
        return new qa(this.color, this.density);
      }
      toJSON() {
        return {
          type: "FogExp2",
          color: this.color.getHex(),
          density: this.density,
        };
      }
    }
    qa.prototype.isFogExp2 = !0;
    class $a {
      constructor(t, e = 1, n = 1e3) {
        (this.name = ""),
          (this.color = new qi(t)),
          (this.near = e),
          (this.far = n);
      }
      clone() {
        return new $a(this.color, this.near, this.far);
      }
      toJSON() {
        return {
          type: "Fog",
          color: this.color.getHex(),
          near: this.near,
          far: this.far,
        };
      }
    }
    $a.prototype.isFog = !0;
    class Xa extends Ei {
      constructor() {
        super(),
          (this.type = "Scene"),
          (this.background = null),
          (this.environment = null),
          (this.fog = null),
          (this.overrideMaterial = null),
          (this.autoUpdate = !0),
          "undefined" != typeof __THREE_DEVTOOLS__ &&
            __THREE_DEVTOOLS__.dispatchEvent(
              new CustomEvent("observe", { detail: this })
            );
      }
      copy(t, e) {
        return (
          super.copy(t, e),
          null !== t.background && (this.background = t.background.clone()),
          null !== t.environment && (this.environment = t.environment.clone()),
          null !== t.fog && (this.fog = t.fog.clone()),
          null !== t.overrideMaterial &&
            (this.overrideMaterial = t.overrideMaterial.clone()),
          (this.autoUpdate = t.autoUpdate),
          (this.matrixAutoUpdate = t.matrixAutoUpdate),
          this
        );
      }
      toJSON(t) {
        const e = super.toJSON(t);
        return null !== this.fog && (e.object.fog = this.fog.toJSON()), e;
      }
    }
    Xa.prototype.isScene = !0;
    class Ja {
      constructor(t, e) {
        (this.array = t),
          (this.stride = e),
          (this.count = void 0 !== t ? t.length / e : 0),
          (this.usage = Ze),
          (this.updateRange = { offset: 0, count: -1 }),
          (this.version = 0),
          (this.uuid = sn());
      }
      onUploadCallback() {}
      set needsUpdate(t) {
        !0 === t && this.version++;
      }
      setUsage(t) {
        return (this.usage = t), this;
      }
      copy(t) {
        return (
          (this.array = new t.array.constructor(t.array)),
          (this.count = t.count),
          (this.stride = t.stride),
          (this.usage = t.usage),
          this
        );
      }
      copyAt(t, e, n) {
        (t *= this.stride), (n *= e.stride);
        for (let i = 0, r = this.stride; i < r; i++)
          this.array[t + i] = e.array[n + i];
        return this;
      }
      set(t, e = 0) {
        return this.array.set(t, e), this;
      }
      clone(t) {
        void 0 === t.arrayBuffers && (t.arrayBuffers = {}),
          void 0 === this.array.buffer._uuid &&
            (this.array.buffer._uuid = sn()),
          void 0 === t.arrayBuffers[this.array.buffer._uuid] &&
            (t.arrayBuffers[this.array.buffer._uuid] =
              this.array.slice(0).buffer);
        const e = new this.array.constructor(
            t.arrayBuffers[this.array.buffer._uuid]
          ),
          n = new this.constructor(e, this.stride);
        return n.setUsage(this.usage), n;
      }
      onUpload(t) {
        return (this.onUploadCallback = t), this;
      }
      toJSON(t) {
        return (
          void 0 === t.arrayBuffers && (t.arrayBuffers = {}),
          void 0 === this.array.buffer._uuid &&
            (this.array.buffer._uuid = sn()),
          void 0 === t.arrayBuffers[this.array.buffer._uuid] &&
            (t.arrayBuffers[this.array.buffer._uuid] =
              Array.prototype.slice.call(new Uint32Array(this.array.buffer))),
          {
            uuid: this.uuid,
            buffer: this.array.buffer._uuid,
            type: this.array.constructor.name,
            stride: this.stride,
          }
        );
      }
    }
    Ja.prototype.isInterleavedBuffer = !0;
    const Ya = new Mn();
    class Za {
      constructor(t, e, n, i = !1) {
        (this.name = ""),
          (this.data = t),
          (this.itemSize = e),
          (this.offset = n),
          (this.normalized = !0 === i);
      }
      get count() {
        return this.data.count;
      }
      get array() {
        return this.data.array;
      }
      set needsUpdate(t) {
        this.data.needsUpdate = t;
      }
      applyMatrix4(t) {
        for (let e = 0, n = this.data.count; e < n; e++)
          (Ya.x = this.getX(e)),
            (Ya.y = this.getY(e)),
            (Ya.z = this.getZ(e)),
            Ya.applyMatrix4(t),
            this.setXYZ(e, Ya.x, Ya.y, Ya.z);
        return this;
      }
      applyNormalMatrix(t) {
        for (let e = 0, n = this.count; e < n; e++)
          (Ya.x = this.getX(e)),
            (Ya.y = this.getY(e)),
            (Ya.z = this.getZ(e)),
            Ya.applyNormalMatrix(t),
            this.setXYZ(e, Ya.x, Ya.y, Ya.z);
        return this;
      }
      transformDirection(t) {
        for (let e = 0, n = this.count; e < n; e++)
          (Ya.x = this.getX(e)),
            (Ya.y = this.getY(e)),
            (Ya.z = this.getZ(e)),
            Ya.transformDirection(t),
            this.setXYZ(e, Ya.x, Ya.y, Ya.z);
        return this;
      }
      setX(t, e) {
        return (this.data.array[t * this.data.stride + this.offset] = e), this;
      }
      setY(t, e) {
        return (
          (this.data.array[t * this.data.stride + this.offset + 1] = e), this
        );
      }
      setZ(t, e) {
        return (
          (this.data.array[t * this.data.stride + this.offset + 2] = e), this
        );
      }
      setW(t, e) {
        return (
          (this.data.array[t * this.data.stride + this.offset + 3] = e), this
        );
      }
      getX(t) {
        return this.data.array[t * this.data.stride + this.offset];
      }
      getY(t) {
        return this.data.array[t * this.data.stride + this.offset + 1];
      }
      getZ(t) {
        return this.data.array[t * this.data.stride + this.offset + 2];
      }
      getW(t) {
        return this.data.array[t * this.data.stride + this.offset + 3];
      }
      setXY(t, e, n) {
        return (
          (t = t * this.data.stride + this.offset),
          (this.data.array[t + 0] = e),
          (this.data.array[t + 1] = n),
          this
        );
      }
      setXYZ(t, e, n, i) {
        return (
          (t = t * this.data.stride + this.offset),
          (this.data.array[t + 0] = e),
          (this.data.array[t + 1] = n),
          (this.data.array[t + 2] = i),
          this
        );
      }
      setXYZW(t, e, n, i, r) {
        return (
          (t = t * this.data.stride + this.offset),
          (this.data.array[t + 0] = e),
          (this.data.array[t + 1] = n),
          (this.data.array[t + 2] = i),
          (this.data.array[t + 3] = r),
          this
        );
      }
      clone(t) {
        if (void 0 === t) {
          console.log(
            "THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data."
          );
          const t = [];
          for (let e = 0; e < this.count; e++) {
            const n = e * this.data.stride + this.offset;
            for (let e = 0; e < this.itemSize; e++)
              t.push(this.data.array[n + e]);
          }
          return new Yi(
            new this.array.constructor(t),
            this.itemSize,
            this.normalized
          );
        }
        return (
          void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}),
          void 0 === t.interleavedBuffers[this.data.uuid] &&
            (t.interleavedBuffers[this.data.uuid] = this.data.clone(t)),
          new Za(
            t.interleavedBuffers[this.data.uuid],
            this.itemSize,
            this.offset,
            this.normalized
          )
        );
      }
      toJSON(t) {
        if (void 0 === t) {
          console.log(
            "THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data."
          );
          const t = [];
          for (let e = 0; e < this.count; e++) {
            const n = e * this.data.stride + this.offset;
            for (let e = 0; e < this.itemSize; e++)
              t.push(this.data.array[n + e]);
          }
          return {
            itemSize: this.itemSize,
            type: this.array.constructor.name,
            array: t,
            normalized: this.normalized,
          };
        }
        return (
          void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}),
          void 0 === t.interleavedBuffers[this.data.uuid] &&
            (t.interleavedBuffers[this.data.uuid] = this.data.toJSON(t)),
          {
            isInterleavedBufferAttribute: !0,
            itemSize: this.itemSize,
            data: this.data.uuid,
            offset: this.offset,
            normalized: this.normalized,
          }
        );
      }
    }
    Za.prototype.isInterleavedBufferAttribute = !0;
    class Qa extends Bi {
      constructor(t) {
        super(),
          (this.type = "SpriteMaterial"),
          (this.color = new qi(16777215)),
          (this.map = null),
          (this.alphaMap = null),
          (this.rotation = 0),
          (this.sizeAttenuation = !0),
          (this.transparent = !0),
          this.setValues(t);
      }
      copy(t) {
        return (
          super.copy(t),
          this.color.copy(t.color),
          (this.map = t.map),
          (this.alphaMap = t.alphaMap),
          (this.rotation = t.rotation),
          (this.sizeAttenuation = t.sizeAttenuation),
          this
        );
      }
    }
    let Ka;
    Qa.prototype.isSpriteMaterial = !0;
    const tl = new Mn(),
      el = new Mn(),
      nl = new Mn(),
      il = new hn(),
      rl = new hn(),
      sl = new ei(),
      ol = new Mn(),
      al = new Mn(),
      ll = new Mn(),
      cl = new hn(),
      ul = new hn(),
      hl = new hn();
    class dl extends Ei {
      constructor(t) {
        if ((super(), (this.type = "Sprite"), void 0 === Ka)) {
          Ka = new ar();
          const t = new Float32Array([
              -0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5,
              0.5, 0, 0, 1,
            ]),
            e = new Ja(t, 5);
          Ka.setIndex([0, 1, 2, 0, 2, 3]),
            Ka.setAttribute("position", new Za(e, 3, 0, !1)),
            Ka.setAttribute("uv", new Za(e, 2, 3, !1));
        }
        (this.geometry = Ka),
          (this.material = void 0 !== t ? t : new Qa()),
          (this.center = new hn(0.5, 0.5));
      }
      raycast(t, e) {
        null === t.camera &&
          console.error(
            'THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'
          ),
          el.setFromMatrixScale(this.matrixWorld),
          sl.copy(t.camera.matrixWorld),
          this.modelViewMatrix.multiplyMatrices(
            t.camera.matrixWorldInverse,
            this.matrixWorld
          ),
          nl.setFromMatrixPosition(this.modelViewMatrix),
          t.camera.isPerspectiveCamera &&
            !1 === this.material.sizeAttenuation &&
            el.multiplyScalar(-nl.z);
        const n = this.material.rotation;
        let i, r;
        0 !== n && ((r = Math.cos(n)), (i = Math.sin(n)));
        const s = this.center;
        pl(ol.set(-0.5, -0.5, 0), nl, s, el, i, r),
          pl(al.set(0.5, -0.5, 0), nl, s, el, i, r),
          pl(ll.set(0.5, 0.5, 0), nl, s, el, i, r),
          cl.set(0, 0),
          ul.set(1, 0),
          hl.set(1, 1);
        let o = t.ray.intersectTriangle(ol, al, ll, !1, tl);
        if (
          null === o &&
          (pl(al.set(-0.5, 0.5, 0), nl, s, el, i, r),
          ul.set(0, 1),
          (o = t.ray.intersectTriangle(ol, ll, al, !1, tl)),
          null === o)
        )
          return;
        const a = t.ray.origin.distanceTo(tl);
        a < t.near ||
          a > t.far ||
          e.push({
            distance: a,
            point: tl.clone(),
            uv: zi.getUV(tl, ol, al, ll, cl, ul, hl, new hn()),
            face: null,
            object: this,
          });
      }
      copy(t) {
        return (
          super.copy(t),
          void 0 !== t.center && this.center.copy(t.center),
          (this.material = t.material),
          this
        );
      }
    }
    function pl(t, e, n, i, r, s) {
      il.subVectors(t, n).addScalar(0.5).multiply(i),
        void 0 !== r
          ? ((rl.x = s * il.x - r * il.y), (rl.y = r * il.x + s * il.y))
          : rl.copy(il),
        t.copy(e),
        (t.x += rl.x),
        (t.y += rl.y),
        t.applyMatrix4(sl);
    }
    dl.prototype.isSprite = !0;
    const fl = new Mn(),
      ml = new bn(),
      gl = new bn(),
      vl = new Mn(),
      yl = new ei();
    class xl extends Tr {
      constructor(t, e) {
        super(t, e),
          (this.type = "SkinnedMesh"),
          (this.bindMode = "attached"),
          (this.bindMatrix = new ei()),
          (this.bindMatrixInverse = new ei());
      }
      copy(t) {
        return (
          super.copy(t),
          (this.bindMode = t.bindMode),
          this.bindMatrix.copy(t.bindMatrix),
          this.bindMatrixInverse.copy(t.bindMatrixInverse),
          (this.skeleton = t.skeleton),
          this
        );
      }
      bind(t, e) {
        (this.skeleton = t),
          void 0 === e &&
            (this.updateMatrixWorld(!0),
            this.skeleton.calculateInverses(),
            (e = this.matrixWorld)),
          this.bindMatrix.copy(e),
          this.bindMatrixInverse.copy(e).invert();
      }
      pose() {
        this.skeleton.pose();
      }
      normalizeSkinWeights() {
        const t = new bn(),
          e = this.geometry.attributes.skinWeight;
        for (let n = 0, i = e.count; n < i; n++) {
          (t.x = e.getX(n)),
            (t.y = e.getY(n)),
            (t.z = e.getZ(n)),
            (t.w = e.getW(n));
          const i = 1 / t.manhattanLength();
          i !== 1 / 0 ? t.multiplyScalar(i) : t.set(1, 0, 0, 0),
            e.setXYZW(n, t.x, t.y, t.z, t.w);
        }
      }
      updateMatrixWorld(t) {
        super.updateMatrixWorld(t),
          "attached" === this.bindMode
            ? this.bindMatrixInverse.copy(this.matrixWorld).invert()
            : "detached" === this.bindMode
            ? this.bindMatrixInverse.copy(this.bindMatrix).invert()
            : console.warn(
                "THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode
              );
      }
      boneTransform(t, e) {
        const n = this.skeleton,
          i = this.geometry;
        ml.fromBufferAttribute(i.attributes.skinIndex, t),
          gl.fromBufferAttribute(i.attributes.skinWeight, t),
          fl.copy(e).applyMatrix4(this.bindMatrix),
          e.set(0, 0, 0);
        for (let t = 0; t < 4; t++) {
          const i = gl.getComponent(t);
          if (0 !== i) {
            const r = ml.getComponent(t);
            yl.multiplyMatrices(n.bones[r].matrixWorld, n.boneInverses[r]),
              e.addScaledVector(vl.copy(fl).applyMatrix4(yl), i);
          }
        }
        return e.applyMatrix4(this.bindMatrixInverse);
      }
    }
    xl.prototype.isSkinnedMesh = !0;
    class bl extends Ei {
      constructor() {
        super(), (this.type = "Bone");
      }
    }
    bl.prototype.isBone = !0;
    class _l extends yn {
      constructor(t = null, e = 1, n = 1, i, r, s, o, a, l = mt, c = mt, u, h) {
        super(null, s, o, a, l, c, i, r, u, h),
          (this.image = { data: t, width: e, height: n }),
          (this.magFilter = l),
          (this.minFilter = c),
          (this.generateMipmaps = !1),
          (this.flipY = !1),
          (this.unpackAlignment = 1);
      }
    }
    _l.prototype.isDataTexture = !0;
    class wl extends Yi {
      constructor(t, e, n, i = 1) {
        "number" == typeof n &&
          ((i = n),
          (n = !1),
          console.error(
            "THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument."
          )),
          super(t, e, n),
          (this.meshPerAttribute = i);
      }
      copy(t) {
        return (
          super.copy(t), (this.meshPerAttribute = t.meshPerAttribute), this
        );
      }
      toJSON() {
        const t = super.toJSON();
        return (
          (t.meshPerAttribute = this.meshPerAttribute),
          (t.isInstancedBufferAttribute = !0),
          t
        );
      }
    }
    wl.prototype.isInstancedBufferAttribute = !0;
    const Sl = new ei(),
      Ml = new ei(),
      Tl = [],
      El = new Tr();
    class Al extends Tr {
      constructor(t, e, n) {
        super(t, e),
          (this.instanceMatrix = new wl(new Float32Array(16 * n), 16)),
          (this.instanceColor = null),
          (this.count = n),
          (this.frustumCulled = !1);
      }
      copy(t) {
        return (
          super.copy(t),
          this.instanceMatrix.copy(t.instanceMatrix),
          null !== t.instanceColor &&
            (this.instanceColor = t.instanceColor.clone()),
          (this.count = t.count),
          this
        );
      }
      getColorAt(t, e) {
        e.fromArray(this.instanceColor.array, 3 * t);
      }
      getMatrixAt(t, e) {
        e.fromArray(this.instanceMatrix.array, 16 * t);
      }
      raycast(t, e) {
        const n = this.matrixWorld,
          i = this.count;
        if (
          ((El.geometry = this.geometry),
          (El.material = this.material),
          void 0 !== El.material)
        )
          for (let r = 0; r < i; r++) {
            this.getMatrixAt(r, Sl),
              Ml.multiplyMatrices(n, Sl),
              (El.matrixWorld = Ml),
              El.raycast(t, Tl);
            for (let t = 0, n = Tl.length; t < n; t++) {
              const n = Tl[t];
              (n.instanceId = r), (n.object = this), e.push(n);
            }
            Tl.length = 0;
          }
      }
      setColorAt(t, e) {
        null === this.instanceColor &&
          (this.instanceColor = new wl(
            new Float32Array(3 * this.instanceMatrix.count),
            3
          )),
          e.toArray(this.instanceColor.array, 3 * t);
      }
      setMatrixAt(t, e) {
        e.toArray(this.instanceMatrix.array, 16 * t);
      }
      updateMorphTargets() {}
      dispose() {
        this.dispatchEvent({ type: "dispose" });
      }
    }
    Al.prototype.isInstancedMesh = !0;
    class Cl extends Bi {
      constructor(t) {
        super(),
          (this.type = "LineBasicMaterial"),
          (this.color = new qi(16777215)),
          (this.linewidth = 1),
          (this.linecap = "round"),
          (this.linejoin = "round"),
          this.setValues(t);
      }
      copy(t) {
        return (
          super.copy(t),
          this.color.copy(t.color),
          (this.linewidth = t.linewidth),
          (this.linecap = t.linecap),
          (this.linejoin = t.linejoin),
          this
        );
      }
    }
    Cl.prototype.isLineBasicMaterial = !0;
    const Ll = new Mn(),
      Rl = new Mn(),
      Pl = new ei(),
      Dl = new ti(),
      kl = new qn();
    class Il extends Ei {
      constructor(t = new ar(), e = new Cl()) {
        super(),
          (this.type = "Line"),
          (this.geometry = t),
          (this.material = e),
          this.updateMorphTargets();
      }
      copy(t) {
        return (
          super.copy(t),
          (this.material = t.material),
          (this.geometry = t.geometry),
          this
        );
      }
      computeLineDistances() {
        const t = this.geometry;
        if (t.isBufferGeometry)
          if (null === t.index) {
            const e = t.attributes.position,
              n = [0];
            for (let t = 1, i = e.count; t < i; t++)
              Ll.fromBufferAttribute(e, t - 1),
                Rl.fromBufferAttribute(e, t),
                (n[t] = n[t - 1]),
                (n[t] += Ll.distanceTo(Rl));
            t.setAttribute("lineDistance", new Ki(n, 1));
          } else
            console.warn(
              "THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
            );
        else
          t.isGeometry &&
            console.error(
              "THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
            );
        return this;
      }
      raycast(t, e) {
        const n = this.geometry,
          i = this.matrixWorld,
          r = t.params.Line.threshold,
          s = n.drawRange;
        if (
          (null === n.boundingSphere && n.computeBoundingSphere(),
          kl.copy(n.boundingSphere),
          kl.applyMatrix4(i),
          (kl.radius += r),
          !1 === t.ray.intersectsSphere(kl))
        )
          return;
        Pl.copy(i).invert(), Dl.copy(t.ray).applyMatrix4(Pl);
        const o = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
          a = o * o,
          l = new Mn(),
          c = new Mn(),
          u = new Mn(),
          h = new Mn(),
          d = this.isLineSegments ? 2 : 1;
        if (n.isBufferGeometry) {
          const i = n.index,
            r = n.attributes.position;
          if (null !== i) {
            for (
              let n = Math.max(0, s.start),
                o = Math.min(i.count, s.start + s.count) - 1;
              n < o;
              n += d
            ) {
              const s = i.getX(n),
                o = i.getX(n + 1);
              if (
                (l.fromBufferAttribute(r, s),
                c.fromBufferAttribute(r, o),
                Dl.distanceSqToSegment(l, c, h, u) > a)
              )
                continue;
              h.applyMatrix4(this.matrixWorld);
              const d = t.ray.origin.distanceTo(h);
              d < t.near ||
                d > t.far ||
                e.push({
                  distance: d,
                  point: u.clone().applyMatrix4(this.matrixWorld),
                  index: n,
                  face: null,
                  faceIndex: null,
                  object: this,
                });
            }
          } else {
            for (
              let n = Math.max(0, s.start),
                i = Math.min(r.count, s.start + s.count) - 1;
              n < i;
              n += d
            ) {
              if (
                (l.fromBufferAttribute(r, n),
                c.fromBufferAttribute(r, n + 1),
                Dl.distanceSqToSegment(l, c, h, u) > a)
              )
                continue;
              h.applyMatrix4(this.matrixWorld);
              const i = t.ray.origin.distanceTo(h);
              i < t.near ||
                i > t.far ||
                e.push({
                  distance: i,
                  point: u.clone().applyMatrix4(this.matrixWorld),
                  index: n,
                  face: null,
                  faceIndex: null,
                  object: this,
                });
            }
          }
        } else
          n.isGeometry &&
            console.error(
              "THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
            );
      }
      updateMorphTargets() {
        const t = this.geometry;
        if (t.isBufferGeometry) {
          const e = t.morphAttributes,
            n = Object.keys(e);
          if (n.length > 0) {
            const t = e[n[0]];
            if (void 0 !== t) {
              (this.morphTargetInfluences = []),
                (this.morphTargetDictionary = {});
              for (let e = 0, n = t.length; e < n; e++) {
                const n = t[e].name || String(e);
                this.morphTargetInfluences.push(0),
                  (this.morphTargetDictionary[n] = e);
              }
            }
          }
        } else {
          const e = t.morphTargets;
          void 0 !== e &&
            e.length > 0 &&
            console.error(
              "THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead."
            );
        }
      }
    }
    Il.prototype.isLine = !0;
    const Nl = new Mn(),
      Ol = new Mn();
    class zl extends Il {
      constructor(t, e) {
        super(t, e), (this.type = "LineSegments");
      }
      computeLineDistances() {
        const t = this.geometry;
        if (t.isBufferGeometry)
          if (null === t.index) {
            const e = t.attributes.position,
              n = [];
            for (let t = 0, i = e.count; t < i; t += 2)
              Nl.fromBufferAttribute(e, t),
                Ol.fromBufferAttribute(e, t + 1),
                (n[t] = 0 === t ? 0 : n[t - 1]),
                (n[t + 1] = n[t] + Nl.distanceTo(Ol));
            t.setAttribute("lineDistance", new Ki(n, 1));
          } else
            console.warn(
              "THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
            );
        else
          t.isGeometry &&
            console.error(
              "THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
            );
        return this;
      }
    }
    zl.prototype.isLineSegments = !0;
    class Hl extends Il {
      constructor(t, e) {
        super(t, e), (this.type = "LineLoop");
      }
    }
    Hl.prototype.isLineLoop = !0;
    class Bl extends Bi {
      constructor(t) {
        super(),
          (this.type = "PointsMaterial"),
          (this.color = new qi(16777215)),
          (this.map = null),
          (this.alphaMap = null),
          (this.size = 1),
          (this.sizeAttenuation = !0),
          this.setValues(t);
      }
      copy(t) {
        return (
          super.copy(t),
          this.color.copy(t.color),
          (this.map = t.map),
          (this.alphaMap = t.alphaMap),
          (this.size = t.size),
          (this.sizeAttenuation = t.sizeAttenuation),
          this
        );
      }
    }
    Bl.prototype.isPointsMaterial = !0;
    const Ul = new ei(),
      Fl = new ti(),
      Vl = new qn(),
      Wl = new Mn();
    class Gl extends Ei {
      constructor(t = new ar(), e = new Bl()) {
        super(),
          (this.type = "Points"),
          (this.geometry = t),
          (this.material = e),
          this.updateMorphTargets();
      }
      copy(t) {
        return (
          super.copy(t),
          (this.material = t.material),
          (this.geometry = t.geometry),
          this
        );
      }
      raycast(t, e) {
        const n = this.geometry,
          i = this.matrixWorld,
          r = t.params.Points.threshold,
          s = n.drawRange;
        if (
          (null === n.boundingSphere && n.computeBoundingSphere(),
          Vl.copy(n.boundingSphere),
          Vl.applyMatrix4(i),
          (Vl.radius += r),
          !1 === t.ray.intersectsSphere(Vl))
        )
          return;
        Ul.copy(i).invert(), Fl.copy(t.ray).applyMatrix4(Ul);
        const o = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
          a = o * o;
        if (n.isBufferGeometry) {
          const r = n.index,
            o = n.attributes.position;
          if (null !== r) {
            for (
              let n = Math.max(0, s.start),
                l = Math.min(r.count, s.start + s.count);
              n < l;
              n++
            ) {
              const s = r.getX(n);
              Wl.fromBufferAttribute(o, s), jl(Wl, s, a, i, t, e, this);
            }
          } else {
            for (
              let n = Math.max(0, s.start),
                r = Math.min(o.count, s.start + s.count);
              n < r;
              n++
            )
              Wl.fromBufferAttribute(o, n), jl(Wl, n, a, i, t, e, this);
          }
        } else
          console.error(
            "THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
          );
      }
      updateMorphTargets() {
        const t = this.geometry;
        if (t.isBufferGeometry) {
          const e = t.morphAttributes,
            n = Object.keys(e);
          if (n.length > 0) {
            const t = e[n[0]];
            if (void 0 !== t) {
              (this.morphTargetInfluences = []),
                (this.morphTargetDictionary = {});
              for (let e = 0, n = t.length; e < n; e++) {
                const n = t[e].name || String(e);
                this.morphTargetInfluences.push(0),
                  (this.morphTargetDictionary[n] = e);
              }
            }
          }
        } else {
          const e = t.morphTargets;
          void 0 !== e &&
            e.length > 0 &&
            console.error(
              "THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead."
            );
        }
      }
    }
    function jl(t, e, n, i, r, s, o) {
      const a = Fl.distanceSqToPoint(t);
      if (a < n) {
        const n = new Mn();
        Fl.closestPointToPoint(t, n), n.applyMatrix4(i);
        const l = r.ray.origin.distanceTo(n);
        if (l < r.near || l > r.far) return;
        s.push({
          distance: l,
          distanceToRay: Math.sqrt(a),
          point: n,
          index: e,
          face: null,
          object: o,
        });
      }
    }
    Gl.prototype.isPoints = !0;
    (class extends yn {
      constructor(t, e, n, i, r, s, o, a, l) {
        super(t, e, n, i, r, s, o, a, l),
          (this.format = void 0 !== o ? o : It),
          (this.minFilter = void 0 !== s ? s : yt),
          (this.magFilter = void 0 !== r ? r : yt),
          (this.generateMipmaps = !1);
        const c = this;
        "requestVideoFrameCallback" in t &&
          t.requestVideoFrameCallback(function e() {
            (c.needsUpdate = !0), t.requestVideoFrameCallback(e);
          });
      }
      clone() {
        return new this.constructor(this.image).copy(this);
      }
      update() {
        const t = this.image;
        !1 === "requestVideoFrameCallback" in t &&
          t.readyState >= t.HAVE_CURRENT_DATA &&
          (this.needsUpdate = !0);
      }
    }.prototype.isVideoTexture = !0);
    (class extends yn {
      constructor(t, e, n) {
        super({ width: t, height: e }),
          (this.format = n),
          (this.magFilter = mt),
          (this.minFilter = mt),
          (this.generateMipmaps = !1),
          (this.needsUpdate = !0);
      }
    }.prototype.isFramebufferTexture = !0);
    class ql extends yn {
      constructor(t, e, n, i, r, s, o, a, l, c, u, h) {
        super(null, s, o, a, l, c, i, r, u, h),
          (this.image = { width: e, height: n }),
          (this.mipmaps = t),
          (this.flipY = !1),
          (this.generateMipmaps = !1);
      }
    }
    ql.prototype.isCompressedTexture = !0;
    (class extends yn {
      constructor(t, e, n, i, r, s, o, a, l) {
        super(t, e, n, i, r, s, o, a, l), (this.needsUpdate = !0);
      }
    }.prototype.isCanvasTexture = !0);
    new Mn(), new Mn(), new Mn(), new zi();
    class $l {
      constructor() {
        (this.type = "Curve"), (this.arcLengthDivisions = 200);
      }
      getPoint() {
        return console.warn("THREE.Curve: .getPoint() not implemented."), null;
      }
      getPointAt(t, e) {
        const n = this.getUtoTmapping(t);
        return this.getPoint(n, e);
      }
      getPoints(t = 5) {
        const e = [];
        for (let n = 0; n <= t; n++) e.push(this.getPoint(n / t));
        return e;
      }
      getSpacedPoints(t = 5) {
        const e = [];
        for (let n = 0; n <= t; n++) e.push(this.getPointAt(n / t));
        return e;
      }
      getLength() {
        const t = this.getLengths();
        return t[t.length - 1];
      }
      getLengths(t = this.arcLengthDivisions) {
        if (
          this.cacheArcLengths &&
          this.cacheArcLengths.length === t + 1 &&
          !this.needsUpdate
        )
          return this.cacheArcLengths;
        this.needsUpdate = !1;
        const e = [];
        let n,
          i = this.getPoint(0),
          r = 0;
        e.push(0);
        for (let s = 1; s <= t; s++)
          (n = this.getPoint(s / t)),
            (r += n.distanceTo(i)),
            e.push(r),
            (i = n);
        return (this.cacheArcLengths = e), e;
      }
      updateArcLengths() {
        (this.needsUpdate = !0), this.getLengths();
      }
      getUtoTmapping(t, e) {
        const n = this.getLengths();
        let i = 0;
        const r = n.length;
        let s;
        s = e || t * n[r - 1];
        let o,
          a = 0,
          l = r - 1;
        for (; a <= l; )
          if (((i = Math.floor(a + (l - a) / 2)), (o = n[i] - s), o < 0))
            a = i + 1;
          else {
            if (!(o > 0)) {
              l = i;
              break;
            }
            l = i - 1;
          }
        if (((i = l), n[i] === s)) return i / (r - 1);
        const c = n[i];
        return (i + (s - c) / (n[i + 1] - c)) / (r - 1);
      }
      getTangent(t, e) {
        let n = t - 1e-4,
          i = t + 1e-4;
        n < 0 && (n = 0), i > 1 && (i = 1);
        const r = this.getPoint(n),
          s = this.getPoint(i),
          o = e || (r.isVector2 ? new hn() : new Mn());
        return o.copy(s).sub(r).normalize(), o;
      }
      getTangentAt(t, e) {
        const n = this.getUtoTmapping(t);
        return this.getTangent(n, e);
      }
      computeFrenetFrames(t, e) {
        const n = new Mn(),
          i = [],
          r = [],
          s = [],
          o = new Mn(),
          a = new ei();
        for (let e = 0; e <= t; e++) {
          const n = e / t;
          i[e] = this.getTangentAt(n, new Mn());
        }
        (r[0] = new Mn()), (s[0] = new Mn());
        let l = Number.MAX_VALUE;
        const c = Math.abs(i[0].x),
          u = Math.abs(i[0].y),
          h = Math.abs(i[0].z);
        c <= l && ((l = c), n.set(1, 0, 0)),
          u <= l && ((l = u), n.set(0, 1, 0)),
          h <= l && n.set(0, 0, 1),
          o.crossVectors(i[0], n).normalize(),
          r[0].crossVectors(i[0], o),
          s[0].crossVectors(i[0], r[0]);
        for (let e = 1; e <= t; e++) {
          if (
            ((r[e] = r[e - 1].clone()),
            (s[e] = s[e - 1].clone()),
            o.crossVectors(i[e - 1], i[e]),
            o.length() > Number.EPSILON)
          ) {
            o.normalize();
            const t = Math.acos(on(i[e - 1].dot(i[e]), -1, 1));
            r[e].applyMatrix4(a.makeRotationAxis(o, t));
          }
          s[e].crossVectors(i[e], r[e]);
        }
        if (!0 === e) {
          let e = Math.acos(on(r[0].dot(r[t]), -1, 1));
          (e /= t), i[0].dot(o.crossVectors(r[0], r[t])) > 0 && (e = -e);
          for (let n = 1; n <= t; n++)
            r[n].applyMatrix4(a.makeRotationAxis(i[n], e * n)),
              s[n].crossVectors(i[n], r[n]);
        }
        return { tangents: i, normals: r, binormals: s };
      }
      clone() {
        return new this.constructor().copy(this);
      }
      copy(t) {
        return (this.arcLengthDivisions = t.arcLengthDivisions), this;
      }
      toJSON() {
        const t = {
          metadata: { version: 4.5, type: "Curve", generator: "Curve.toJSON" },
        };
        return (
          (t.arcLengthDivisions = this.arcLengthDivisions),
          (t.type = this.type),
          t
        );
      }
      fromJSON(t) {
        return (this.arcLengthDivisions = t.arcLengthDivisions), this;
      }
    }
    class Xl extends $l {
      constructor(
        t = 0,
        e = 0,
        n = 1,
        i = 1,
        r = 0,
        s = 2 * Math.PI,
        o = !1,
        a = 0
      ) {
        super(),
          (this.type = "EllipseCurve"),
          (this.aX = t),
          (this.aY = e),
          (this.xRadius = n),
          (this.yRadius = i),
          (this.aStartAngle = r),
          (this.aEndAngle = s),
          (this.aClockwise = o),
          (this.aRotation = a);
      }
      getPoint(t, e) {
        const n = e || new hn(),
          i = 2 * Math.PI;
        let r = this.aEndAngle - this.aStartAngle;
        const s = Math.abs(r) < Number.EPSILON;
        for (; r < 0; ) r += i;
        for (; r > i; ) r -= i;
        r < Number.EPSILON && (r = s ? 0 : i),
          !0 !== this.aClockwise || s || (r === i ? (r = -i) : (r -= i));
        const o = this.aStartAngle + t * r;
        let a = this.aX + this.xRadius * Math.cos(o),
          l = this.aY + this.yRadius * Math.sin(o);
        if (0 !== this.aRotation) {
          const t = Math.cos(this.aRotation),
            e = Math.sin(this.aRotation),
            n = a - this.aX,
            i = l - this.aY;
          (a = n * t - i * e + this.aX), (l = n * e + i * t + this.aY);
        }
        return n.set(a, l);
      }
      copy(t) {
        return (
          super.copy(t),
          (this.aX = t.aX),
          (this.aY = t.aY),
          (this.xRadius = t.xRadius),
          (this.yRadius = t.yRadius),
          (this.aStartAngle = t.aStartAngle),
          (this.aEndAngle = t.aEndAngle),
          (this.aClockwise = t.aClockwise),
          (this.aRotation = t.aRotation),
          this
        );
      }
      toJSON() {
        const t = super.toJSON();
        return (
          (t.aX = this.aX),
          (t.aY = this.aY),
          (t.xRadius = this.xRadius),
          (t.yRadius = this.yRadius),
          (t.aStartAngle = this.aStartAngle),
          (t.aEndAngle = this.aEndAngle),
          (t.aClockwise = this.aClockwise),
          (t.aRotation = this.aRotation),
          t
        );
      }
      fromJSON(t) {
        return (
          super.fromJSON(t),
          (this.aX = t.aX),
          (this.aY = t.aY),
          (this.xRadius = t.xRadius),
          (this.yRadius = t.yRadius),
          (this.aStartAngle = t.aStartAngle),
          (this.aEndAngle = t.aEndAngle),
          (this.aClockwise = t.aClockwise),
          (this.aRotation = t.aRotation),
          this
        );
      }
    }
    Xl.prototype.isEllipseCurve = !0;
    class Jl extends Xl {
      constructor(t, e, n, i, r, s) {
        super(t, e, n, n, i, r, s), (this.type = "ArcCurve");
      }
    }
    function Yl() {
      let t = 0,
        e = 0,
        n = 0,
        i = 0;
      function r(r, s, o, a) {
        (t = r),
          (e = o),
          (n = -3 * r + 3 * s - 2 * o - a),
          (i = 2 * r - 2 * s + o + a);
      }
      return {
        initCatmullRom: function (t, e, n, i, s) {
          r(e, n, s * (n - t), s * (i - e));
        },
        initNonuniformCatmullRom: function (t, e, n, i, s, o, a) {
          let l = (e - t) / s - (n - t) / (s + o) + (n - e) / o,
            c = (n - e) / o - (i - e) / (o + a) + (i - n) / a;
          (l *= o), (c *= o), r(e, n, l, c);
        },
        calc: function (r) {
          const s = r * r;
          return t + e * r + n * s + i * (s * r);
        },
      };
    }
    Jl.prototype.isArcCurve = !0;
    const Zl = new Mn(),
      Ql = new Yl(),
      Kl = new Yl(),
      tc = new Yl();
    class ec extends $l {
      constructor(t = [], e = !1, n = "centripetal", i = 0.5) {
        super(),
          (this.type = "CatmullRomCurve3"),
          (this.points = t),
          (this.closed = e),
          (this.curveType = n),
          (this.tension = i);
      }
      getPoint(t, e = new Mn()) {
        const n = e,
          i = this.points,
          r = i.length,
          s = (r - (this.closed ? 0 : 1)) * t;
        let o,
          a,
          l = Math.floor(s),
          c = s - l;
        this.closed
          ? (l += l > 0 ? 0 : (Math.floor(Math.abs(l) / r) + 1) * r)
          : 0 === c && l === r - 1 && ((l = r - 2), (c = 1)),
          this.closed || l > 0
            ? (o = i[(l - 1) % r])
            : (Zl.subVectors(i[0], i[1]).add(i[0]), (o = Zl));
        const u = i[l % r],
          h = i[(l + 1) % r];
        if (
          (this.closed || l + 2 < r
            ? (a = i[(l + 2) % r])
            : (Zl.subVectors(i[r - 1], i[r - 2]).add(i[r - 1]), (a = Zl)),
          "centripetal" === this.curveType || "chordal" === this.curveType)
        ) {
          const t = "chordal" === this.curveType ? 0.5 : 0.25;
          let e = Math.pow(o.distanceToSquared(u), t),
            n = Math.pow(u.distanceToSquared(h), t),
            i = Math.pow(h.distanceToSquared(a), t);
          n < 1e-4 && (n = 1),
            e < 1e-4 && (e = n),
            i < 1e-4 && (i = n),
            Ql.initNonuniformCatmullRom(o.x, u.x, h.x, a.x, e, n, i),
            Kl.initNonuniformCatmullRom(o.y, u.y, h.y, a.y, e, n, i),
            tc.initNonuniformCatmullRom(o.z, u.z, h.z, a.z, e, n, i);
        } else
          "catmullrom" === this.curveType &&
            (Ql.initCatmullRom(o.x, u.x, h.x, a.x, this.tension),
            Kl.initCatmullRom(o.y, u.y, h.y, a.y, this.tension),
            tc.initCatmullRom(o.z, u.z, h.z, a.z, this.tension));
        return n.set(Ql.calc(c), Kl.calc(c), tc.calc(c)), n;
      }
      copy(t) {
        super.copy(t), (this.points = []);
        for (let e = 0, n = t.points.length; e < n; e++) {
          const n = t.points[e];
          this.points.push(n.clone());
        }
        return (
          (this.closed = t.closed),
          (this.curveType = t.curveType),
          (this.tension = t.tension),
          this
        );
      }
      toJSON() {
        const t = super.toJSON();
        t.points = [];
        for (let e = 0, n = this.points.length; e < n; e++) {
          const n = this.points[e];
          t.points.push(n.toArray());
        }
        return (
          (t.closed = this.closed),
          (t.curveType = this.curveType),
          (t.tension = this.tension),
          t
        );
      }
      fromJSON(t) {
        super.fromJSON(t), (this.points = []);
        for (let e = 0, n = t.points.length; e < n; e++) {
          const n = t.points[e];
          this.points.push(new Mn().fromArray(n));
        }
        return (
          (this.closed = t.closed),
          (this.curveType = t.curveType),
          (this.tension = t.tension),
          this
        );
      }
    }
    function nc(t, e, n, i, r) {
      const s = 0.5 * (i - e),
        o = 0.5 * (r - n),
        a = t * t;
      return (
        (2 * n - 2 * i + s + o) * (t * a) +
        (-3 * n + 3 * i - 2 * s - o) * a +
        s * t +
        n
      );
    }
    function ic(t, e, n, i) {
      return (
        (function (t, e) {
          const n = 1 - t;
          return n * n * e;
        })(t, e) +
        (function (t, e) {
          return 2 * (1 - t) * t * e;
        })(t, n) +
        (function (t, e) {
          return t * t * e;
        })(t, i)
      );
    }
    function rc(t, e, n, i, r) {
      return (
        (function (t, e) {
          const n = 1 - t;
          return n * n * n * e;
        })(t, e) +
        (function (t, e) {
          const n = 1 - t;
          return 3 * n * n * t * e;
        })(t, n) +
        (function (t, e) {
          return 3 * (1 - t) * t * t * e;
        })(t, i) +
        (function (t, e) {
          return t * t * t * e;
        })(t, r)
      );
    }
    ec.prototype.isCatmullRomCurve3 = !0;
    class sc extends $l {
      constructor(t = new hn(), e = new hn(), n = new hn(), i = new hn()) {
        super(),
          (this.type = "CubicBezierCurve"),
          (this.v0 = t),
          (this.v1 = e),
          (this.v2 = n),
          (this.v3 = i);
      }
      getPoint(t, e = new hn()) {
        const n = e,
          i = this.v0,
          r = this.v1,
          s = this.v2,
          o = this.v3;
        return n.set(rc(t, i.x, r.x, s.x, o.x), rc(t, i.y, r.y, s.y, o.y)), n;
      }
      copy(t) {
        return (
          super.copy(t),
          this.v0.copy(t.v0),
          this.v1.copy(t.v1),
          this.v2.copy(t.v2),
          this.v3.copy(t.v3),
          this
        );
      }
      toJSON() {
        const t = super.toJSON();
        return (
          (t.v0 = this.v0.toArray()),
          (t.v1 = this.v1.toArray()),
          (t.v2 = this.v2.toArray()),
          (t.v3 = this.v3.toArray()),
          t
        );
      }
      fromJSON(t) {
        return (
          super.fromJSON(t),
          this.v0.fromArray(t.v0),
          this.v1.fromArray(t.v1),
          this.v2.fromArray(t.v2),
          this.v3.fromArray(t.v3),
          this
        );
      }
    }
    sc.prototype.isCubicBezierCurve = !0;
    class oc extends $l {
      constructor(t = new Mn(), e = new Mn(), n = new Mn(), i = new Mn()) {
        super(),
          (this.type = "CubicBezierCurve3"),
          (this.v0 = t),
          (this.v1 = e),
          (this.v2 = n),
          (this.v3 = i);
      }
      getPoint(t, e = new Mn()) {
        const n = e,
          i = this.v0,
          r = this.v1,
          s = this.v2,
          o = this.v3;
        return (
          n.set(
            rc(t, i.x, r.x, s.x, o.x),
            rc(t, i.y, r.y, s.y, o.y),
            rc(t, i.z, r.z, s.z, o.z)
          ),
          n
        );
      }
      copy(t) {
        return (
          super.copy(t),
          this.v0.copy(t.v0),
          this.v1.copy(t.v1),
          this.v2.copy(t.v2),
          this.v3.copy(t.v3),
          this
        );
      }
      toJSON() {
        const t = super.toJSON();
        return (
          (t.v0 = this.v0.toArray()),
          (t.v1 = this.v1.toArray()),
          (t.v2 = this.v2.toArray()),
          (t.v3 = this.v3.toArray()),
          t
        );
      }
      fromJSON(t) {
        return (
          super.fromJSON(t),
          this.v0.fromArray(t.v0),
          this.v1.fromArray(t.v1),
          this.v2.fromArray(t.v2),
          this.v3.fromArray(t.v3),
          this
        );
      }
    }
    oc.prototype.isCubicBezierCurve3 = !0;
    class ac extends $l {
      constructor(t = new hn(), e = new hn()) {
        super(), (this.type = "LineCurve"), (this.v1 = t), (this.v2 = e);
      }
      getPoint(t, e = new hn()) {
        const n = e;
        return (
          1 === t
            ? n.copy(this.v2)
            : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)),
          n
        );
      }
      getPointAt(t, e) {
        return this.getPoint(t, e);
      }
      getTangent(t, e) {
        const n = e || new hn();
        return n.copy(this.v2).sub(this.v1).normalize(), n;
      }
      copy(t) {
        return super.copy(t), this.v1.copy(t.v1), this.v2.copy(t.v2), this;
      }
      toJSON() {
        const t = super.toJSON();
        return (t.v1 = this.v1.toArray()), (t.v2 = this.v2.toArray()), t;
      }
      fromJSON(t) {
        return (
          super.fromJSON(t),
          this.v1.fromArray(t.v1),
          this.v2.fromArray(t.v2),
          this
        );
      }
    }
    ac.prototype.isLineCurve = !0;
    class lc extends $l {
      constructor(t = new hn(), e = new hn(), n = new hn()) {
        super(),
          (this.type = "QuadraticBezierCurve"),
          (this.v0 = t),
          (this.v1 = e),
          (this.v2 = n);
      }
      getPoint(t, e = new hn()) {
        const n = e,
          i = this.v0,
          r = this.v1,
          s = this.v2;
        return n.set(ic(t, i.x, r.x, s.x), ic(t, i.y, r.y, s.y)), n;
      }
      copy(t) {
        return (
          super.copy(t),
          this.v0.copy(t.v0),
          this.v1.copy(t.v1),
          this.v2.copy(t.v2),
          this
        );
      }
      toJSON() {
        const t = super.toJSON();
        return (
          (t.v0 = this.v0.toArray()),
          (t.v1 = this.v1.toArray()),
          (t.v2 = this.v2.toArray()),
          t
        );
      }
      fromJSON(t) {
        return (
          super.fromJSON(t),
          this.v0.fromArray(t.v0),
          this.v1.fromArray(t.v1),
          this.v2.fromArray(t.v2),
          this
        );
      }
    }
    lc.prototype.isQuadraticBezierCurve = !0;
    class cc extends $l {
      constructor(t = new Mn(), e = new Mn(), n = new Mn()) {
        super(),
          (this.type = "QuadraticBezierCurve3"),
          (this.v0 = t),
          (this.v1 = e),
          (this.v2 = n);
      }
      getPoint(t, e = new Mn()) {
        const n = e,
          i = this.v0,
          r = this.v1,
          s = this.v2;
        return (
          n.set(
            ic(t, i.x, r.x, s.x),
            ic(t, i.y, r.y, s.y),
            ic(t, i.z, r.z, s.z)
          ),
          n
        );
      }
      copy(t) {
        return (
          super.copy(t),
          this.v0.copy(t.v0),
          this.v1.copy(t.v1),
          this.v2.copy(t.v2),
          this
        );
      }
      toJSON() {
        const t = super.toJSON();
        return (
          (t.v0 = this.v0.toArray()),
          (t.v1 = this.v1.toArray()),
          (t.v2 = this.v2.toArray()),
          t
        );
      }
      fromJSON(t) {
        return (
          super.fromJSON(t),
          this.v0.fromArray(t.v0),
          this.v1.fromArray(t.v1),
          this.v2.fromArray(t.v2),
          this
        );
      }
    }
    cc.prototype.isQuadraticBezierCurve3 = !0;
    class uc extends $l {
      constructor(t = []) {
        super(), (this.type = "SplineCurve"), (this.points = t);
      }
      getPoint(t, e = new hn()) {
        const n = e,
          i = this.points,
          r = (i.length - 1) * t,
          s = Math.floor(r),
          o = r - s,
          a = i[0 === s ? s : s - 1],
          l = i[s],
          c = i[s > i.length - 2 ? i.length - 1 : s + 1],
          u = i[s > i.length - 3 ? i.length - 1 : s + 2];
        return n.set(nc(o, a.x, l.x, c.x, u.x), nc(o, a.y, l.y, c.y, u.y)), n;
      }
      copy(t) {
        super.copy(t), (this.points = []);
        for (let e = 0, n = t.points.length; e < n; e++) {
          const n = t.points[e];
          this.points.push(n.clone());
        }
        return this;
      }
      toJSON() {
        const t = super.toJSON();
        t.points = [];
        for (let e = 0, n = this.points.length; e < n; e++) {
          const n = this.points[e];
          t.points.push(n.toArray());
        }
        return t;
      }
      fromJSON(t) {
        super.fromJSON(t), (this.points = []);
        for (let e = 0, n = t.points.length; e < n; e++) {
          const n = t.points[e];
          this.points.push(new hn().fromArray(n));
        }
        return this;
      }
    }
    uc.prototype.isSplineCurve = !0;
    var hc = Object.freeze({
      __proto__: null,
      ArcCurve: Jl,
      CatmullRomCurve3: ec,
      CubicBezierCurve: sc,
      CubicBezierCurve3: oc,
      EllipseCurve: Xl,
      LineCurve: ac,
      LineCurve3: class extends $l {
        constructor(t = new Mn(), e = new Mn()) {
          super(),
            (this.type = "LineCurve3"),
            (this.isLineCurve3 = !0),
            (this.v1 = t),
            (this.v2 = e);
        }
        getPoint(t, e = new Mn()) {
          const n = e;
          return (
            1 === t
              ? n.copy(this.v2)
              : (n.copy(this.v2).sub(this.v1),
                n.multiplyScalar(t).add(this.v1)),
            n
          );
        }
        getPointAt(t, e) {
          return this.getPoint(t, e);
        }
        copy(t) {
          return super.copy(t), this.v1.copy(t.v1), this.v2.copy(t.v2), this;
        }
        toJSON() {
          const t = super.toJSON();
          return (t.v1 = this.v1.toArray()), (t.v2 = this.v2.toArray()), t;
        }
        fromJSON(t) {
          return (
            super.fromJSON(t),
            this.v1.fromArray(t.v1),
            this.v2.fromArray(t.v2),
            this
          );
        }
      },
      QuadraticBezierCurve: lc,
      QuadraticBezierCurve3: cc,
      SplineCurve: uc,
    });
    class dc extends $l {
      constructor() {
        super(),
          (this.type = "CurvePath"),
          (this.curves = []),
          (this.autoClose = !1);
      }
      add(t) {
        this.curves.push(t);
      }
      closePath() {
        const t = this.curves[0].getPoint(0),
          e = this.curves[this.curves.length - 1].getPoint(1);
        t.equals(e) || this.curves.push(new ac(e, t));
      }
      getPoint(t, e) {
        const n = t * this.getLength(),
          i = this.getCurveLengths();
        let r = 0;
        for (; r < i.length; ) {
          if (i[r] >= n) {
            const t = i[r] - n,
              s = this.curves[r],
              o = s.getLength(),
              a = 0 === o ? 0 : 1 - t / o;
            return s.getPointAt(a, e);
          }
          r++;
        }
        return null;
      }
      getLength() {
        const t = this.getCurveLengths();
        return t[t.length - 1];
      }
      updateArcLengths() {
        (this.needsUpdate = !0),
          (this.cacheLengths = null),
          this.getCurveLengths();
      }
      getCurveLengths() {
        if (
          this.cacheLengths &&
          this.cacheLengths.length === this.curves.length
        )
          return this.cacheLengths;
        const t = [];
        let e = 0;
        for (let n = 0, i = this.curves.length; n < i; n++)
          (e += this.curves[n].getLength()), t.push(e);
        return (this.cacheLengths = t), t;
      }
      getSpacedPoints(t = 40) {
        const e = [];
        for (let n = 0; n <= t; n++) e.push(this.getPoint(n / t));
        return this.autoClose && e.push(e[0]), e;
      }
      getPoints(t = 12) {
        const e = [];
        let n;
        for (let i = 0, r = this.curves; i < r.length; i++) {
          const s = r[i],
            o =
              s && s.isEllipseCurve
                ? 2 * t
                : s && (s.isLineCurve || s.isLineCurve3)
                ? 1
                : s && s.isSplineCurve
                ? t * s.points.length
                : t,
            a = s.getPoints(o);
          for (let t = 0; t < a.length; t++) {
            const i = a[t];
            (n && n.equals(i)) || (e.push(i), (n = i));
          }
        }
        return (
          this.autoClose &&
            e.length > 1 &&
            !e[e.length - 1].equals(e[0]) &&
            e.push(e[0]),
          e
        );
      }
      copy(t) {
        super.copy(t), (this.curves = []);
        for (let e = 0, n = t.curves.length; e < n; e++) {
          const n = t.curves[e];
          this.curves.push(n.clone());
        }
        return (this.autoClose = t.autoClose), this;
      }
      toJSON() {
        const t = super.toJSON();
        (t.autoClose = this.autoClose), (t.curves = []);
        for (let e = 0, n = this.curves.length; e < n; e++) {
          const n = this.curves[e];
          t.curves.push(n.toJSON());
        }
        return t;
      }
      fromJSON(t) {
        super.fromJSON(t), (this.autoClose = t.autoClose), (this.curves = []);
        for (let e = 0, n = t.curves.length; e < n; e++) {
          const n = t.curves[e];
          this.curves.push(new hc[n.type]().fromJSON(n));
        }
        return this;
      }
    }
    class pc extends dc {
      constructor(t) {
        super(),
          (this.type = "Path"),
          (this.currentPoint = new hn()),
          t && this.setFromPoints(t);
      }
      setFromPoints(t) {
        this.moveTo(t[0].x, t[0].y);
        for (let e = 1, n = t.length; e < n; e++) this.lineTo(t[e].x, t[e].y);
        return this;
      }
      moveTo(t, e) {
        return this.currentPoint.set(t, e), this;
      }
      lineTo(t, e) {
        const n = new ac(this.currentPoint.clone(), new hn(t, e));
        return this.curves.push(n), this.currentPoint.set(t, e), this;
      }
      quadraticCurveTo(t, e, n, i) {
        const r = new lc(this.currentPoint.clone(), new hn(t, e), new hn(n, i));
        return this.curves.push(r), this.currentPoint.set(n, i), this;
      }
      bezierCurveTo(t, e, n, i, r, s) {
        const o = new sc(
          this.currentPoint.clone(),
          new hn(t, e),
          new hn(n, i),
          new hn(r, s)
        );
        return this.curves.push(o), this.currentPoint.set(r, s), this;
      }
      splineThru(t) {
        const e = [this.currentPoint.clone()].concat(t),
          n = new uc(e);
        return (
          this.curves.push(n), this.currentPoint.copy(t[t.length - 1]), this
        );
      }
      arc(t, e, n, i, r, s) {
        const o = this.currentPoint.x,
          a = this.currentPoint.y;
        return this.absarc(t + o, e + a, n, i, r, s), this;
      }
      absarc(t, e, n, i, r, s) {
        return this.absellipse(t, e, n, n, i, r, s), this;
      }
      ellipse(t, e, n, i, r, s, o, a) {
        const l = this.currentPoint.x,
          c = this.currentPoint.y;
        return this.absellipse(t + l, e + c, n, i, r, s, o, a), this;
      }
      absellipse(t, e, n, i, r, s, o, a) {
        const l = new Xl(t, e, n, i, r, s, o, a);
        if (this.curves.length > 0) {
          const t = l.getPoint(0);
          t.equals(this.currentPoint) || this.lineTo(t.x, t.y);
        }
        this.curves.push(l);
        const c = l.getPoint(1);
        return this.currentPoint.copy(c), this;
      }
      copy(t) {
        return super.copy(t), this.currentPoint.copy(t.currentPoint), this;
      }
      toJSON() {
        const t = super.toJSON();
        return (t.currentPoint = this.currentPoint.toArray()), t;
      }
      fromJSON(t) {
        return (
          super.fromJSON(t), this.currentPoint.fromArray(t.currentPoint), this
        );
      }
    }
    class fc extends pc {
      constructor(t) {
        super(t), (this.uuid = sn()), (this.type = "Shape"), (this.holes = []);
      }
      getPointsHoles(t) {
        const e = [];
        for (let n = 0, i = this.holes.length; n < i; n++)
          e[n] = this.holes[n].getPoints(t);
        return e;
      }
      extractPoints(t) {
        return { shape: this.getPoints(t), holes: this.getPointsHoles(t) };
      }
      copy(t) {
        super.copy(t), (this.holes = []);
        for (let e = 0, n = t.holes.length; e < n; e++) {
          const n = t.holes[e];
          this.holes.push(n.clone());
        }
        return this;
      }
      toJSON() {
        const t = super.toJSON();
        (t.uuid = this.uuid), (t.holes = []);
        for (let e = 0, n = this.holes.length; e < n; e++) {
          const n = this.holes[e];
          t.holes.push(n.toJSON());
        }
        return t;
      }
      fromJSON(t) {
        super.fromJSON(t), (this.uuid = t.uuid), (this.holes = []);
        for (let e = 0, n = t.holes.length; e < n; e++) {
          const n = t.holes[e];
          this.holes.push(new pc().fromJSON(n));
        }
        return this;
      }
    }
    const mc = {
      triangulate: function (t, e, n = 2) {
        const i = e && e.length,
          r = i ? e[0] * n : t.length;
        let s = gc(t, 0, r, n, !0);
        const o = [];
        if (!s || s.next === s.prev) return o;
        let a, l, c, u, h, d, p;
        if (
          (i &&
            (s = (function (t, e, n, i) {
              const r = [];
              let s, o, a, l, c;
              for (s = 0, o = e.length; s < o; s++)
                (a = e[s] * i),
                  (l = s < o - 1 ? e[s + 1] * i : t.length),
                  (c = gc(t, a, l, i, !1)),
                  c === c.next && (c.steiner = !0),
                  r.push(Ac(c));
              for (r.sort(Sc), s = 0; s < r.length; s++)
                Mc(r[s], n), (n = vc(n, n.next));
              return n;
            })(t, e, s, n)),
          t.length > 80 * n)
        ) {
          (a = c = t[0]), (l = u = t[1]);
          for (let e = n; e < r; e += n)
            (h = t[e]),
              (d = t[e + 1]),
              h < a && (a = h),
              d < l && (l = d),
              h > c && (c = h),
              d > u && (u = d);
          (p = Math.max(c - a, u - l)), (p = 0 !== p ? 1 / p : 0);
        }
        return yc(s, o, n, a, l, p), o;
      },
    };
    function gc(t, e, n, i, r) {
      let s, o;
      if (
        r ===
        (function (t, e, n, i) {
          let r = 0;
          for (let s = e, o = n - i; s < n; s += i)
            (r += (t[o] - t[s]) * (t[s + 1] + t[o + 1])), (o = s);
          return r;
        })(t, e, n, i) >
          0
      )
        for (s = e; s < n; s += i) o = zc(s, t[s], t[s + 1], o);
      else for (s = n - i; s >= e; s -= i) o = zc(s, t[s], t[s + 1], o);
      return o && Pc(o, o.next) && (Hc(o), (o = o.next)), o;
    }
    function vc(t, e) {
      if (!t) return t;
      e || (e = t);
      let n,
        i = t;
      do {
        if (
          ((n = !1),
          i.steiner || (!Pc(i, i.next) && 0 !== Rc(i.prev, i, i.next)))
        )
          i = i.next;
        else {
          if ((Hc(i), (i = e = i.prev), i === i.next)) break;
          n = !0;
        }
      } while (n || i !== e);
      return e;
    }
    function yc(t, e, n, i, r, s, o) {
      if (!t) return;
      !o &&
        s &&
        (function (t, e, n, i) {
          let r = t;
          do {
            null === r.z && (r.z = Ec(r.x, r.y, e, n, i)),
              (r.prevZ = r.prev),
              (r.nextZ = r.next),
              (r = r.next);
          } while (r !== t);
          (r.prevZ.nextZ = null),
            (r.prevZ = null),
            (function (t) {
              let e,
                n,
                i,
                r,
                s,
                o,
                a,
                l,
                c = 1;
              do {
                for (n = t, t = null, s = null, o = 0; n; ) {
                  for (
                    o++, i = n, a = 0, e = 0;
                    e < c && (a++, (i = i.nextZ), i);
                    e++
                  );
                  for (l = c; a > 0 || (l > 0 && i); )
                    0 !== a && (0 === l || !i || n.z <= i.z)
                      ? ((r = n), (n = n.nextZ), a--)
                      : ((r = i), (i = i.nextZ), l--),
                      s ? (s.nextZ = r) : (t = r),
                      (r.prevZ = s),
                      (s = r);
                  n = i;
                }
                (s.nextZ = null), (c *= 2);
              } while (o > 1);
            })(r);
        })(t, i, r, s);
      let a,
        l,
        c = t;
      for (; t.prev !== t.next; )
        if (((a = t.prev), (l = t.next), s ? bc(t, i, r, s) : xc(t)))
          e.push(a.i / n),
            e.push(t.i / n),
            e.push(l.i / n),
            Hc(t),
            (t = l.next),
            (c = l.next);
        else if ((t = l) === c) {
          o
            ? 1 === o
              ? yc((t = _c(vc(t), e, n)), e, n, i, r, s, 2)
              : 2 === o && wc(t, e, n, i, r, s)
            : yc(vc(t), e, n, i, r, s, 1);
          break;
        }
    }
    function xc(t) {
      const e = t.prev,
        n = t,
        i = t.next;
      if (Rc(e, n, i) >= 0) return !1;
      let r = t.next.next;
      for (; r !== t.prev; ) {
        if (
          Cc(e.x, e.y, n.x, n.y, i.x, i.y, r.x, r.y) &&
          Rc(r.prev, r, r.next) >= 0
        )
          return !1;
        r = r.next;
      }
      return !0;
    }
    function bc(t, e, n, i) {
      const r = t.prev,
        s = t,
        o = t.next;
      if (Rc(r, s, o) >= 0) return !1;
      const a = r.x < s.x ? (r.x < o.x ? r.x : o.x) : s.x < o.x ? s.x : o.x,
        l = r.y < s.y ? (r.y < o.y ? r.y : o.y) : s.y < o.y ? s.y : o.y,
        c = r.x > s.x ? (r.x > o.x ? r.x : o.x) : s.x > o.x ? s.x : o.x,
        u = r.y > s.y ? (r.y > o.y ? r.y : o.y) : s.y > o.y ? s.y : o.y,
        h = Ec(a, l, e, n, i),
        d = Ec(c, u, e, n, i);
      let p = t.prevZ,
        f = t.nextZ;
      for (; p && p.z >= h && f && f.z <= d; ) {
        if (
          p !== t.prev &&
          p !== t.next &&
          Cc(r.x, r.y, s.x, s.y, o.x, o.y, p.x, p.y) &&
          Rc(p.prev, p, p.next) >= 0
        )
          return !1;
        if (
          ((p = p.prevZ),
          f !== t.prev &&
            f !== t.next &&
            Cc(r.x, r.y, s.x, s.y, o.x, o.y, f.x, f.y) &&
            Rc(f.prev, f, f.next) >= 0)
        )
          return !1;
        f = f.nextZ;
      }
      for (; p && p.z >= h; ) {
        if (
          p !== t.prev &&
          p !== t.next &&
          Cc(r.x, r.y, s.x, s.y, o.x, o.y, p.x, p.y) &&
          Rc(p.prev, p, p.next) >= 0
        )
          return !1;
        p = p.prevZ;
      }
      for (; f && f.z <= d; ) {
        if (
          f !== t.prev &&
          f !== t.next &&
          Cc(r.x, r.y, s.x, s.y, o.x, o.y, f.x, f.y) &&
          Rc(f.prev, f, f.next) >= 0
        )
          return !1;
        f = f.nextZ;
      }
      return !0;
    }
    function _c(t, e, n) {
      let i = t;
      do {
        const r = i.prev,
          s = i.next.next;
        !Pc(r, s) &&
          Dc(r, i, i.next, s) &&
          Nc(r, s) &&
          Nc(s, r) &&
          (e.push(r.i / n),
          e.push(i.i / n),
          e.push(s.i / n),
          Hc(i),
          Hc(i.next),
          (i = t = s)),
          (i = i.next);
      } while (i !== t);
      return vc(i);
    }
    function wc(t, e, n, i, r, s) {
      let o = t;
      do {
        let t = o.next.next;
        for (; t !== o.prev; ) {
          if (o.i !== t.i && Lc(o, t)) {
            let a = Oc(o, t);
            return (
              (o = vc(o, o.next)),
              (a = vc(a, a.next)),
              yc(o, e, n, i, r, s),
              void yc(a, e, n, i, r, s)
            );
          }
          t = t.next;
        }
        o = o.next;
      } while (o !== t);
    }
    function Sc(t, e) {
      return t.x - e.x;
    }
    function Mc(t, e) {
      if (
        (e = (function (t, e) {
          let n = e;
          const i = t.x,
            r = t.y;
          let s,
            o = -1 / 0;
          do {
            if (r <= n.y && r >= n.next.y && n.next.y !== n.y) {
              const t = n.x + ((r - n.y) * (n.next.x - n.x)) / (n.next.y - n.y);
              if (t <= i && t > o) {
                if (((o = t), t === i)) {
                  if (r === n.y) return n;
                  if (r === n.next.y) return n.next;
                }
                s = n.x < n.next.x ? n : n.next;
              }
            }
            n = n.next;
          } while (n !== e);
          if (!s) return null;
          if (i === o) return s;
          const a = s,
            l = s.x,
            c = s.y;
          let u,
            h = 1 / 0;
          n = s;
          do {
            i >= n.x &&
              n.x >= l &&
              i !== n.x &&
              Cc(r < c ? i : o, r, l, c, r < c ? o : i, r, n.x, n.y) &&
              ((u = Math.abs(r - n.y) / (i - n.x)),
              Nc(n, t) &&
                (u < h ||
                  (u === h && (n.x > s.x || (n.x === s.x && Tc(s, n))))) &&
                ((s = n), (h = u))),
              (n = n.next);
          } while (n !== a);
          return s;
        })(t, e))
      ) {
        const n = Oc(e, t);
        vc(e, e.next), vc(n, n.next);
      }
    }
    function Tc(t, e) {
      return Rc(t.prev, t, e.prev) < 0 && Rc(e.next, t, t.next) < 0;
    }
    function Ec(t, e, n, i, r) {
      return (
        (t =
          1431655765 &
          ((t =
            858993459 &
            ((t =
              252645135 &
              ((t = 16711935 & ((t = 32767 * (t - n) * r) | (t << 8))) |
                (t << 4))) |
              (t << 2))) |
            (t << 1))) |
        ((e =
          1431655765 &
          ((e =
            858993459 &
            ((e =
              252645135 &
              ((e = 16711935 & ((e = 32767 * (e - i) * r) | (e << 8))) |
                (e << 4))) |
              (e << 2))) |
            (e << 1))) <<
          1)
      );
    }
    function Ac(t) {
      let e = t,
        n = t;
      do {
        (e.x < n.x || (e.x === n.x && e.y < n.y)) && (n = e), (e = e.next);
      } while (e !== t);
      return n;
    }
    function Cc(t, e, n, i, r, s, o, a) {
      return (
        (r - o) * (e - a) - (t - o) * (s - a) >= 0 &&
        (t - o) * (i - a) - (n - o) * (e - a) >= 0 &&
        (n - o) * (s - a) - (r - o) * (i - a) >= 0
      );
    }
    function Lc(t, e) {
      return (
        t.next.i !== e.i &&
        t.prev.i !== e.i &&
        !(function (t, e) {
          let n = t;
          do {
            if (
              n.i !== t.i &&
              n.next.i !== t.i &&
              n.i !== e.i &&
              n.next.i !== e.i &&
              Dc(n, n.next, t, e)
            )
              return !0;
            n = n.next;
          } while (n !== t);
          return !1;
        })(t, e) &&
        ((Nc(t, e) &&
          Nc(e, t) &&
          (function (t, e) {
            let n = t,
              i = !1;
            const r = (t.x + e.x) / 2,
              s = (t.y + e.y) / 2;
            do {
              n.y > s != n.next.y > s &&
                n.next.y !== n.y &&
                r < ((n.next.x - n.x) * (s - n.y)) / (n.next.y - n.y) + n.x &&
                (i = !i),
                (n = n.next);
            } while (n !== t);
            return i;
          })(t, e) &&
          (Rc(t.prev, t, e.prev) || Rc(t, e.prev, e))) ||
          (Pc(t, e) && Rc(t.prev, t, t.next) > 0 && Rc(e.prev, e, e.next) > 0))
      );
    }
    function Rc(t, e, n) {
      return (e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y);
    }
    function Pc(t, e) {
      return t.x === e.x && t.y === e.y;
    }
    function Dc(t, e, n, i) {
      const r = Ic(Rc(t, e, n)),
        s = Ic(Rc(t, e, i)),
        o = Ic(Rc(n, i, t)),
        a = Ic(Rc(n, i, e));
      return (
        (r !== s && o !== a) ||
        !(0 !== r || !kc(t, n, e)) ||
        !(0 !== s || !kc(t, i, e)) ||
        !(0 !== o || !kc(n, t, i)) ||
        !(0 !== a || !kc(n, e, i))
      );
    }
    function kc(t, e, n) {
      return (
        e.x <= Math.max(t.x, n.x) &&
        e.x >= Math.min(t.x, n.x) &&
        e.y <= Math.max(t.y, n.y) &&
        e.y >= Math.min(t.y, n.y)
      );
    }
    function Ic(t) {
      return t > 0 ? 1 : t < 0 ? -1 : 0;
    }
    function Nc(t, e) {
      return Rc(t.prev, t, t.next) < 0
        ? Rc(t, e, t.next) >= 0 && Rc(t, t.prev, e) >= 0
        : Rc(t, e, t.prev) < 0 || Rc(t, t.next, e) < 0;
    }
    function Oc(t, e) {
      const n = new Bc(t.i, t.x, t.y),
        i = new Bc(e.i, e.x, e.y),
        r = t.next,
        s = e.prev;
      return (
        (t.next = e),
        (e.prev = t),
        (n.next = r),
        (r.prev = n),
        (i.next = n),
        (n.prev = i),
        (s.next = i),
        (i.prev = s),
        i
      );
    }
    function zc(t, e, n, i) {
      const r = new Bc(t, e, n);
      return (
        i
          ? ((r.next = i.next), (r.prev = i), (i.next.prev = r), (i.next = r))
          : ((r.prev = r), (r.next = r)),
        r
      );
    }
    function Hc(t) {
      (t.next.prev = t.prev),
        (t.prev.next = t.next),
        t.prevZ && (t.prevZ.nextZ = t.nextZ),
        t.nextZ && (t.nextZ.prevZ = t.prevZ);
    }
    function Bc(t, e, n) {
      (this.i = t),
        (this.x = e),
        (this.y = n),
        (this.prev = null),
        (this.next = null),
        (this.z = null),
        (this.prevZ = null),
        (this.nextZ = null),
        (this.steiner = !1);
    }
    class Uc {
      static area(t) {
        const e = t.length;
        let n = 0;
        for (let i = e - 1, r = 0; r < e; i = r++)
          n += t[i].x * t[r].y - t[r].x * t[i].y;
        return 0.5 * n;
      }
      static isClockWise(t) {
        return Uc.area(t) < 0;
      }
      static triangulateShape(t, e) {
        const n = [],
          i = [],
          r = [];
        Fc(t), Vc(n, t);
        let s = t.length;
        e.forEach(Fc);
        for (let t = 0; t < e.length; t++)
          i.push(s), (s += e[t].length), Vc(n, e[t]);
        const o = mc.triangulate(n, i);
        for (let t = 0; t < o.length; t += 3) r.push(o.slice(t, t + 3));
        return r;
      }
    }
    function Fc(t) {
      const e = t.length;
      e > 2 && t[e - 1].equals(t[0]) && t.pop();
    }
    function Vc(t, e) {
      for (let n = 0; n < e.length; n++) t.push(e[n].x), t.push(e[n].y);
    }
    class Wc extends ar {
      constructor(
        t = new fc([
          new hn(0.5, 0.5),
          new hn(-0.5, 0.5),
          new hn(-0.5, -0.5),
          new hn(0.5, -0.5),
        ]),
        e = {}
      ) {
        super(),
          (this.type = "ExtrudeGeometry"),
          (this.parameters = { shapes: t, options: e }),
          (t = Array.isArray(t) ? t : [t]);
        const n = this,
          i = [],
          r = [];
        for (let e = 0, n = t.length; e < n; e++) {
          s(t[e]);
        }
        function s(t) {
          const s = [],
            o = void 0 !== e.curveSegments ? e.curveSegments : 12,
            a = void 0 !== e.steps ? e.steps : 1;
          let l = void 0 !== e.depth ? e.depth : 1,
            c = void 0 === e.bevelEnabled || e.bevelEnabled,
            u = void 0 !== e.bevelThickness ? e.bevelThickness : 0.2,
            h = void 0 !== e.bevelSize ? e.bevelSize : u - 0.1,
            d = void 0 !== e.bevelOffset ? e.bevelOffset : 0,
            p = void 0 !== e.bevelSegments ? e.bevelSegments : 3;
          const f = e.extrudePath,
            m = void 0 !== e.UVGenerator ? e.UVGenerator : Gc;
          void 0 !== e.amount &&
            (console.warn(
              "THREE.ExtrudeBufferGeometry: amount has been renamed to depth."
            ),
            (l = e.amount));
          let g,
            v,
            y,
            x,
            b,
            _ = !1;
          f &&
            ((g = f.getSpacedPoints(a)),
            (_ = !0),
            (c = !1),
            (v = f.computeFrenetFrames(a, !1)),
            (y = new Mn()),
            (x = new Mn()),
            (b = new Mn())),
            c || ((p = 0), (u = 0), (h = 0), (d = 0));
          const w = t.extractPoints(o);
          let S = w.shape;
          const M = w.holes;
          if (!Uc.isClockWise(S)) {
            S = S.reverse();
            for (let t = 0, e = M.length; t < e; t++) {
              const e = M[t];
              Uc.isClockWise(e) && (M[t] = e.reverse());
            }
          }
          const T = Uc.triangulateShape(S, M),
            E = S;
          for (let t = 0, e = M.length; t < e; t++) {
            const e = M[t];
            S = S.concat(e);
          }
          function A(t, e, n) {
            return (
              e || console.error("THREE.ExtrudeGeometry: vec does not exist"),
              e.clone().multiplyScalar(n).add(t)
            );
          }
          const C = S.length,
            L = T.length;
          function R(t, e, n) {
            let i, r, s;
            const o = t.x - e.x,
              a = t.y - e.y,
              l = n.x - t.x,
              c = n.y - t.y,
              u = o * o + a * a,
              h = o * c - a * l;
            if (Math.abs(h) > Number.EPSILON) {
              const h = Math.sqrt(u),
                d = Math.sqrt(l * l + c * c),
                p = e.x - a / h,
                f = e.y + o / h,
                m =
                  ((n.x - c / d - p) * c - (n.y + l / d - f) * l) /
                  (o * c - a * l);
              (i = p + o * m - t.x), (r = f + a * m - t.y);
              const g = i * i + r * r;
              if (g <= 2) return new hn(i, r);
              s = Math.sqrt(g / 2);
            } else {
              let t = !1;
              o > Number.EPSILON
                ? l > Number.EPSILON && (t = !0)
                : o < -Number.EPSILON
                ? l < -Number.EPSILON && (t = !0)
                : Math.sign(a) === Math.sign(c) && (t = !0),
                t
                  ? ((i = -a), (r = o), (s = Math.sqrt(u)))
                  : ((i = o), (r = a), (s = Math.sqrt(u / 2)));
            }
            return new hn(i / s, r / s);
          }
          const P = [];
          for (
            let t = 0, e = E.length, n = e - 1, i = t + 1;
            t < e;
            t++, n++, i++
          )
            n === e && (n = 0),
              i === e && (i = 0),
              (P[t] = R(E[t], E[n], E[i]));
          const D = [];
          let k,
            I = P.concat();
          for (let t = 0, e = M.length; t < e; t++) {
            const e = M[t];
            k = [];
            for (
              let t = 0, n = e.length, i = n - 1, r = t + 1;
              t < n;
              t++, i++, r++
            )
              i === n && (i = 0),
                r === n && (r = 0),
                (k[t] = R(e[t], e[i], e[r]));
            D.push(k), (I = I.concat(k));
          }
          for (let t = 0; t < p; t++) {
            const e = t / p,
              n = u * Math.cos((e * Math.PI) / 2),
              i = h * Math.sin((e * Math.PI) / 2) + d;
            for (let t = 0, e = E.length; t < e; t++) {
              const e = A(E[t], P[t], i);
              z(e.x, e.y, -n);
            }
            for (let t = 0, e = M.length; t < e; t++) {
              const e = M[t];
              k = D[t];
              for (let t = 0, r = e.length; t < r; t++) {
                const r = A(e[t], k[t], i);
                z(r.x, r.y, -n);
              }
            }
          }
          const N = h + d;
          for (let t = 0; t < C; t++) {
            const e = c ? A(S[t], I[t], N) : S[t];
            _
              ? (x.copy(v.normals[0]).multiplyScalar(e.x),
                y.copy(v.binormals[0]).multiplyScalar(e.y),
                b.copy(g[0]).add(x).add(y),
                z(b.x, b.y, b.z))
              : z(e.x, e.y, 0);
          }
          for (let t = 1; t <= a; t++)
            for (let e = 0; e < C; e++) {
              const n = c ? A(S[e], I[e], N) : S[e];
              _
                ? (x.copy(v.normals[t]).multiplyScalar(n.x),
                  y.copy(v.binormals[t]).multiplyScalar(n.y),
                  b.copy(g[t]).add(x).add(y),
                  z(b.x, b.y, b.z))
                : z(n.x, n.y, (l / a) * t);
            }
          for (let t = p - 1; t >= 0; t--) {
            const e = t / p,
              n = u * Math.cos((e * Math.PI) / 2),
              i = h * Math.sin((e * Math.PI) / 2) + d;
            for (let t = 0, e = E.length; t < e; t++) {
              const e = A(E[t], P[t], i);
              z(e.x, e.y, l + n);
            }
            for (let t = 0, e = M.length; t < e; t++) {
              const e = M[t];
              k = D[t];
              for (let t = 0, r = e.length; t < r; t++) {
                const r = A(e[t], k[t], i);
                _
                  ? z(r.x, r.y + g[a - 1].y, g[a - 1].x + n)
                  : z(r.x, r.y, l + n);
              }
            }
          }
          function O(t, e) {
            let n = t.length;
            for (; --n >= 0; ) {
              const i = n;
              let r = n - 1;
              r < 0 && (r = t.length - 1);
              for (let t = 0, n = a + 2 * p; t < n; t++) {
                const n = C * t,
                  s = C * (t + 1);
                B(e + i + n, e + r + n, e + r + s, e + i + s);
              }
            }
          }
          function z(t, e, n) {
            s.push(t), s.push(e), s.push(n);
          }
          function H(t, e, r) {
            U(t), U(e), U(r);
            const s = i.length / 3,
              o = m.generateTopUV(n, i, s - 3, s - 2, s - 1);
            F(o[0]), F(o[1]), F(o[2]);
          }
          function B(t, e, r, s) {
            U(t), U(e), U(s), U(e), U(r), U(s);
            const o = i.length / 3,
              a = m.generateSideWallUV(n, i, o - 6, o - 3, o - 2, o - 1);
            F(a[0]), F(a[1]), F(a[3]), F(a[1]), F(a[2]), F(a[3]);
          }
          function U(t) {
            i.push(s[3 * t + 0]), i.push(s[3 * t + 1]), i.push(s[3 * t + 2]);
          }
          function F(t) {
            r.push(t.x), r.push(t.y);
          }
          !(function () {
            const t = i.length / 3;
            if (c) {
              let t = 0,
                e = C * t;
              for (let t = 0; t < L; t++) {
                const n = T[t];
                H(n[2] + e, n[1] + e, n[0] + e);
              }
              (t = a + 2 * p), (e = C * t);
              for (let t = 0; t < L; t++) {
                const n = T[t];
                H(n[0] + e, n[1] + e, n[2] + e);
              }
            } else {
              for (let t = 0; t < L; t++) {
                const e = T[t];
                H(e[2], e[1], e[0]);
              }
              for (let t = 0; t < L; t++) {
                const e = T[t];
                H(e[0] + C * a, e[1] + C * a, e[2] + C * a);
              }
            }
            n.addGroup(t, i.length / 3 - t, 0);
          })(),
            (function () {
              const t = i.length / 3;
              let e = 0;
              O(E, e), (e += E.length);
              for (let t = 0, n = M.length; t < n; t++) {
                const n = M[t];
                O(n, e), (e += n.length);
              }
              n.addGroup(t, i.length / 3 - t, 1);
            })();
        }
        this.setAttribute("position", new Ki(i, 3)),
          this.setAttribute("uv", new Ki(r, 2)),
          this.computeVertexNormals();
      }
      toJSON() {
        const t = super.toJSON();
        return (function (t, e, n) {
          if (((n.shapes = []), Array.isArray(t)))
            for (let e = 0, i = t.length; e < i; e++) {
              const i = t[e];
              n.shapes.push(i.uuid);
            }
          else n.shapes.push(t.uuid);
          void 0 !== e.extrudePath &&
            (n.options.extrudePath = e.extrudePath.toJSON());
          return n;
        })(this.parameters.shapes, this.parameters.options, t);
      }
      static fromJSON(t, e) {
        const n = [];
        for (let i = 0, r = t.shapes.length; i < r; i++) {
          const r = e[t.shapes[i]];
          n.push(r);
        }
        const i = t.options.extrudePath;
        return (
          void 0 !== i &&
            (t.options.extrudePath = new hc[i.type]().fromJSON(i)),
          new Wc(n, t.options)
        );
      }
    }
    const Gc = {
      generateTopUV: function (t, e, n, i, r) {
        const s = e[3 * n],
          o = e[3 * n + 1],
          a = e[3 * i],
          l = e[3 * i + 1],
          c = e[3 * r],
          u = e[3 * r + 1];
        return [new hn(s, o), new hn(a, l), new hn(c, u)];
      },
      generateSideWallUV: function (t, e, n, i, r, s) {
        const o = e[3 * n],
          a = e[3 * n + 1],
          l = e[3 * n + 2],
          c = e[3 * i],
          u = e[3 * i + 1],
          h = e[3 * i + 2],
          d = e[3 * r],
          p = e[3 * r + 1],
          f = e[3 * r + 2],
          m = e[3 * s],
          g = e[3 * s + 1],
          v = e[3 * s + 2];
        return Math.abs(a - u) < Math.abs(o - c)
          ? [
              new hn(o, 1 - l),
              new hn(c, 1 - h),
              new hn(d, 1 - f),
              new hn(m, 1 - v),
            ]
          : [
              new hn(a, 1 - l),
              new hn(u, 1 - h),
              new hn(p, 1 - f),
              new hn(g, 1 - v),
            ];
      },
    };
    class jc extends ar {
      constructor(
        t = new fc([new hn(0, 0.5), new hn(-0.5, -0.5), new hn(0.5, -0.5)]),
        e = 12
      ) {
        super(),
          (this.type = "ShapeGeometry"),
          (this.parameters = { shapes: t, curveSegments: e });
        const n = [],
          i = [],
          r = [],
          s = [];
        let o = 0,
          a = 0;
        if (!1 === Array.isArray(t)) l(t);
        else
          for (let e = 0; e < t.length; e++)
            l(t[e]), this.addGroup(o, a, e), (o += a), (a = 0);
        function l(t) {
          const o = i.length / 3,
            l = t.extractPoints(e);
          let c = l.shape;
          const u = l.holes;
          !1 === Uc.isClockWise(c) && (c = c.reverse());
          for (let t = 0, e = u.length; t < e; t++) {
            const e = u[t];
            !0 === Uc.isClockWise(e) && (u[t] = e.reverse());
          }
          const h = Uc.triangulateShape(c, u);
          for (let t = 0, e = u.length; t < e; t++) {
            const e = u[t];
            c = c.concat(e);
          }
          for (let t = 0, e = c.length; t < e; t++) {
            const e = c[t];
            i.push(e.x, e.y, 0), r.push(0, 0, 1), s.push(e.x, e.y);
          }
          for (let t = 0, e = h.length; t < e; t++) {
            const e = h[t],
              i = e[0] + o,
              r = e[1] + o,
              s = e[2] + o;
            n.push(i, r, s), (a += 3);
          }
        }
        this.setIndex(n),
          this.setAttribute("position", new Ki(i, 3)),
          this.setAttribute("normal", new Ki(r, 3)),
          this.setAttribute("uv", new Ki(s, 2));
      }
      toJSON() {
        const t = super.toJSON();
        return (function (t, e) {
          if (((e.shapes = []), Array.isArray(t)))
            for (let n = 0, i = t.length; n < i; n++) {
              const i = t[n];
              e.shapes.push(i.uuid);
            }
          else e.shapes.push(t.uuid);
          return e;
        })(this.parameters.shapes, t);
      }
      static fromJSON(t, e) {
        const n = [];
        for (let i = 0, r = t.shapes.length; i < r; i++) {
          const r = e[t.shapes[i]];
          n.push(r);
        }
        return new jc(n, t.curveSegments);
      }
    }
    class qc extends Bi {
      constructor(t) {
        super(),
          (this.type = "ShadowMaterial"),
          (this.color = new qi(0)),
          (this.transparent = !0),
          this.setValues(t);
      }
      copy(t) {
        return super.copy(t), this.color.copy(t.color), this;
      }
    }
    qc.prototype.isShadowMaterial = !0;
    class $c extends Bi {
      constructor(t) {
        super(),
          (this.defines = { STANDARD: "" }),
          (this.type = "MeshStandardMaterial"),
          (this.color = new qi(16777215)),
          (this.roughness = 1),
          (this.metalness = 0),
          (this.map = null),
          (this.lightMap = null),
          (this.lightMapIntensity = 1),
          (this.aoMap = null),
          (this.aoMapIntensity = 1),
          (this.emissive = new qi(0)),
          (this.emissiveIntensity = 1),
          (this.emissiveMap = null),
          (this.bumpMap = null),
          (this.bumpScale = 1),
          (this.normalMap = null),
          (this.normalMapType = $e),
          (this.normalScale = new hn(1, 1)),
          (this.displacementMap = null),
          (this.displacementScale = 1),
          (this.displacementBias = 0),
          (this.roughnessMap = null),
          (this.metalnessMap = null),
          (this.alphaMap = null),
          (this.envMap = null),
          (this.envMapIntensity = 1),
          (this.refractionRatio = 0.98),
          (this.wireframe = !1),
          (this.wireframeLinewidth = 1),
          (this.wireframeLinecap = "round"),
          (this.wireframeLinejoin = "round"),
          (this.flatShading = !1),
          this.setValues(t);
      }
      copy(t) {
        return (
          super.copy(t),
          (this.defines = { STANDARD: "" }),
          this.color.copy(t.color),
          (this.roughness = t.roughness),
          (this.metalness = t.metalness),
          (this.map = t.map),
          (this.lightMap = t.lightMap),
          (this.lightMapIntensity = t.lightMapIntensity),
          (this.aoMap = t.aoMap),
          (this.aoMapIntensity = t.aoMapIntensity),
          this.emissive.copy(t.emissive),
          (this.emissiveMap = t.emissiveMap),
          (this.emissiveIntensity = t.emissiveIntensity),
          (this.bumpMap = t.bumpMap),
          (this.bumpScale = t.bumpScale),
          (this.normalMap = t.normalMap),
          (this.normalMapType = t.normalMapType),
          this.normalScale.copy(t.normalScale),
          (this.displacementMap = t.displacementMap),
          (this.displacementScale = t.displacementScale),
          (this.displacementBias = t.displacementBias),
          (this.roughnessMap = t.roughnessMap),
          (this.metalnessMap = t.metalnessMap),
          (this.alphaMap = t.alphaMap),
          (this.envMap = t.envMap),
          (this.envMapIntensity = t.envMapIntensity),
          (this.refractionRatio = t.refractionRatio),
          (this.wireframe = t.wireframe),
          (this.wireframeLinewidth = t.wireframeLinewidth),
          (this.wireframeLinecap = t.wireframeLinecap),
          (this.wireframeLinejoin = t.wireframeLinejoin),
          (this.flatShading = t.flatShading),
          this
        );
      }
    }
    $c.prototype.isMeshStandardMaterial = !0;
    class Xc extends $c {
      constructor(t) {
        super(),
          (this.defines = { STANDARD: "", PHYSICAL: "" }),
          (this.type = "MeshPhysicalMaterial"),
          (this.clearcoatMap = null),
          (this.clearcoatRoughness = 0),
          (this.clearcoatRoughnessMap = null),
          (this.clearcoatNormalScale = new hn(1, 1)),
          (this.clearcoatNormalMap = null),
          (this.ior = 1.5),
          Object.defineProperty(this, "reflectivity", {
            get: function () {
              return on((2.5 * (this.ior - 1)) / (this.ior + 1), 0, 1);
            },
            set: function (t) {
              this.ior = (1 + 0.4 * t) / (1 - 0.4 * t);
            },
          }),
          (this.sheenColor = new qi(0)),
          (this.sheenColorMap = null),
          (this.sheenRoughness = 1),
          (this.sheenRoughnessMap = null),
          (this.transmissionMap = null),
          (this.thickness = 0),
          (this.thicknessMap = null),
          (this.attenuationDistance = 0),
          (this.attenuationColor = new qi(1, 1, 1)),
          (this.specularIntensity = 1),
          (this.specularIntensityMap = null),
          (this.specularColor = new qi(1, 1, 1)),
          (this.specularColorMap = null),
          (this._sheen = 0),
          (this._clearcoat = 0),
          (this._transmission = 0),
          this.setValues(t);
      }
      get sheen() {
        return this._sheen;
      }
      set sheen(t) {
        this._sheen > 0 != t > 0 && this.version++, (this._sheen = t);
      }
      get clearcoat() {
        return this._clearcoat;
      }
      set clearcoat(t) {
        this._clearcoat > 0 != t > 0 && this.version++, (this._clearcoat = t);
      }
      get transmission() {
        return this._transmission;
      }
      set transmission(t) {
        this._transmission > 0 != t > 0 && this.version++,
          (this._transmission = t);
      }
      copy(t) {
        return (
          super.copy(t),
          (this.defines = { STANDARD: "", PHYSICAL: "" }),
          (this.clearcoat = t.clearcoat),
          (this.clearcoatMap = t.clearcoatMap),
          (this.clearcoatRoughness = t.clearcoatRoughness),
          (this.clearcoatRoughnessMap = t.clearcoatRoughnessMap),
          (this.clearcoatNormalMap = t.clearcoatNormalMap),
          this.clearcoatNormalScale.copy(t.clearcoatNormalScale),
          (this.ior = t.ior),
          (this.sheen = t.sheen),
          this.sheenColor.copy(t.sheenColor),
          (this.sheenColorMap = t.sheenColorMap),
          (this.sheenRoughness = t.sheenRoughness),
          (this.sheenRoughnessMap = t.sheenRoughnessMap),
          (this.transmission = t.transmission),
          (this.transmissionMap = t.transmissionMap),
          (this.thickness = t.thickness),
          (this.thicknessMap = t.thicknessMap),
          (this.attenuationDistance = t.attenuationDistance),
          this.attenuationColor.copy(t.attenuationColor),
          (this.specularIntensity = t.specularIntensity),
          (this.specularIntensityMap = t.specularIntensityMap),
          this.specularColor.copy(t.specularColor),
          (this.specularColorMap = t.specularColorMap),
          this
        );
      }
    }
    Xc.prototype.isMeshPhysicalMaterial = !0;
    class Jc extends Bi {
      constructor(t) {
        super(),
          (this.type = "MeshPhongMaterial"),
          (this.color = new qi(16777215)),
          (this.specular = new qi(1118481)),
          (this.shininess = 30),
          (this.map = null),
          (this.lightMap = null),
          (this.lightMapIntensity = 1),
          (this.aoMap = null),
          (this.aoMapIntensity = 1),
          (this.emissive = new qi(0)),
          (this.emissiveIntensity = 1),
          (this.emissiveMap = null),
          (this.bumpMap = null),
          (this.bumpScale = 1),
          (this.normalMap = null),
          (this.normalMapType = $e),
          (this.normalScale = new hn(1, 1)),
          (this.displacementMap = null),
          (this.displacementScale = 1),
          (this.displacementBias = 0),
          (this.specularMap = null),
          (this.alphaMap = null),
          (this.envMap = null),
          (this.combine = Y),
          (this.reflectivity = 1),
          (this.refractionRatio = 0.98),
          (this.wireframe = !1),
          (this.wireframeLinewidth = 1),
          (this.wireframeLinecap = "round"),
          (this.wireframeLinejoin = "round"),
          (this.flatShading = !1),
          this.setValues(t);
      }
      copy(t) {
        return (
          super.copy(t),
          this.color.copy(t.color),
          this.specular.copy(t.specular),
          (this.shininess = t.shininess),
          (this.map = t.map),
          (this.lightMap = t.lightMap),
          (this.lightMapIntensity = t.lightMapIntensity),
          (this.aoMap = t.aoMap),
          (this.aoMapIntensity = t.aoMapIntensity),
          this.emissive.copy(t.emissive),
          (this.emissiveMap = t.emissiveMap),
          (this.emissiveIntensity = t.emissiveIntensity),
          (this.bumpMap = t.bumpMap),
          (this.bumpScale = t.bumpScale),
          (this.normalMap = t.normalMap),
          (this.normalMapType = t.normalMapType),
          this.normalScale.copy(t.normalScale),
          (this.displacementMap = t.displacementMap),
          (this.displacementScale = t.displacementScale),
          (this.displacementBias = t.displacementBias),
          (this.specularMap = t.specularMap),
          (this.alphaMap = t.alphaMap),
          (this.envMap = t.envMap),
          (this.combine = t.combine),
          (this.reflectivity = t.reflectivity),
          (this.refractionRatio = t.refractionRatio),
          (this.wireframe = t.wireframe),
          (this.wireframeLinewidth = t.wireframeLinewidth),
          (this.wireframeLinecap = t.wireframeLinecap),
          (this.wireframeLinejoin = t.wireframeLinejoin),
          (this.flatShading = t.flatShading),
          this
        );
      }
    }
    Jc.prototype.isMeshPhongMaterial = !0;
    class Yc extends Bi {
      constructor(t) {
        super(),
          (this.defines = { TOON: "" }),
          (this.type = "MeshToonMaterial"),
          (this.color = new qi(16777215)),
          (this.map = null),
          (this.gradientMap = null),
          (this.lightMap = null),
          (this.lightMapIntensity = 1),
          (this.aoMap = null),
          (this.aoMapIntensity = 1),
          (this.emissive = new qi(0)),
          (this.emissiveIntensity = 1),
          (this.emissiveMap = null),
          (this.bumpMap = null),
          (this.bumpScale = 1),
          (this.normalMap = null),
          (this.normalMapType = $e),
          (this.normalScale = new hn(1, 1)),
          (this.displacementMap = null),
          (this.displacementScale = 1),
          (this.displacementBias = 0),
          (this.alphaMap = null),
          (this.wireframe = !1),
          (this.wireframeLinewidth = 1),
          (this.wireframeLinecap = "round"),
          (this.wireframeLinejoin = "round"),
          this.setValues(t);
      }
      copy(t) {
        return (
          super.copy(t),
          this.color.copy(t.color),
          (this.map = t.map),
          (this.gradientMap = t.gradientMap),
          (this.lightMap = t.lightMap),
          (this.lightMapIntensity = t.lightMapIntensity),
          (this.aoMap = t.aoMap),
          (this.aoMapIntensity = t.aoMapIntensity),
          this.emissive.copy(t.emissive),
          (this.emissiveMap = t.emissiveMap),
          (this.emissiveIntensity = t.emissiveIntensity),
          (this.bumpMap = t.bumpMap),
          (this.bumpScale = t.bumpScale),
          (this.normalMap = t.normalMap),
          (this.normalMapType = t.normalMapType),
          this.normalScale.copy(t.normalScale),
          (this.displacementMap = t.displacementMap),
          (this.displacementScale = t.displacementScale),
          (this.displacementBias = t.displacementBias),
          (this.alphaMap = t.alphaMap),
          (this.wireframe = t.wireframe),
          (this.wireframeLinewidth = t.wireframeLinewidth),
          (this.wireframeLinecap = t.wireframeLinecap),
          (this.wireframeLinejoin = t.wireframeLinejoin),
          this
        );
      }
    }
    Yc.prototype.isMeshToonMaterial = !0;
    class Zc extends Bi {
      constructor(t) {
        super(),
          (this.type = "MeshNormalMaterial"),
          (this.bumpMap = null),
          (this.bumpScale = 1),
          (this.normalMap = null),
          (this.normalMapType = $e),
          (this.normalScale = new hn(1, 1)),
          (this.displacementMap = null),
          (this.displacementScale = 1),
          (this.displacementBias = 0),
          (this.wireframe = !1),
          (this.wireframeLinewidth = 1),
          (this.fog = !1),
          (this.flatShading = !1),
          this.setValues(t);
      }
      copy(t) {
        return (
          super.copy(t),
          (this.bumpMap = t.bumpMap),
          (this.bumpScale = t.bumpScale),
          (this.normalMap = t.normalMap),
          (this.normalMapType = t.normalMapType),
          this.normalScale.copy(t.normalScale),
          (this.displacementMap = t.displacementMap),
          (this.displacementScale = t.displacementScale),
          (this.displacementBias = t.displacementBias),
          (this.wireframe = t.wireframe),
          (this.wireframeLinewidth = t.wireframeLinewidth),
          (this.flatShading = t.flatShading),
          this
        );
      }
    }
    Zc.prototype.isMeshNormalMaterial = !0;
    class Qc extends Bi {
      constructor(t) {
        super(),
          (this.type = "MeshLambertMaterial"),
          (this.color = new qi(16777215)),
          (this.map = null),
          (this.lightMap = null),
          (this.lightMapIntensity = 1),
          (this.aoMap = null),
          (this.aoMapIntensity = 1),
          (this.emissive = new qi(0)),
          (this.emissiveIntensity = 1),
          (this.emissiveMap = null),
          (this.specularMap = null),
          (this.alphaMap = null),
          (this.envMap = null),
          (this.combine = Y),
          (this.reflectivity = 1),
          (this.refractionRatio = 0.98),
          (this.wireframe = !1),
          (this.wireframeLinewidth = 1),
          (this.wireframeLinecap = "round"),
          (this.wireframeLinejoin = "round"),
          this.setValues(t);
      }
      copy(t) {
        return (
          super.copy(t),
          this.color.copy(t.color),
          (this.map = t.map),
          (this.lightMap = t.lightMap),
          (this.lightMapIntensity = t.lightMapIntensity),
          (this.aoMap = t.aoMap),
          (this.aoMapIntensity = t.aoMapIntensity),
          this.emissive.copy(t.emissive),
          (this.emissiveMap = t.emissiveMap),
          (this.emissiveIntensity = t.emissiveIntensity),
          (this.specularMap = t.specularMap),
          (this.alphaMap = t.alphaMap),
          (this.envMap = t.envMap),
          (this.combine = t.combine),
          (this.reflectivity = t.reflectivity),
          (this.refractionRatio = t.refractionRatio),
          (this.wireframe = t.wireframe),
          (this.wireframeLinewidth = t.wireframeLinewidth),
          (this.wireframeLinecap = t.wireframeLinecap),
          (this.wireframeLinejoin = t.wireframeLinejoin),
          this
        );
      }
    }
    Qc.prototype.isMeshLambertMaterial = !0;
    class Kc extends Bi {
      constructor(t) {
        super(),
          (this.defines = { MATCAP: "" }),
          (this.type = "MeshMatcapMaterial"),
          (this.color = new qi(16777215)),
          (this.matcap = null),
          (this.map = null),
          (this.bumpMap = null),
          (this.bumpScale = 1),
          (this.normalMap = null),
          (this.normalMapType = $e),
          (this.normalScale = new hn(1, 1)),
          (this.displacementMap = null),
          (this.displacementScale = 1),
          (this.displacementBias = 0),
          (this.alphaMap = null),
          (this.flatShading = !1),
          this.setValues(t);
      }
      copy(t) {
        return (
          super.copy(t),
          (this.defines = { MATCAP: "" }),
          this.color.copy(t.color),
          (this.matcap = t.matcap),
          (this.map = t.map),
          (this.bumpMap = t.bumpMap),
          (this.bumpScale = t.bumpScale),
          (this.normalMap = t.normalMap),
          (this.normalMapType = t.normalMapType),
          this.normalScale.copy(t.normalScale),
          (this.displacementMap = t.displacementMap),
          (this.displacementScale = t.displacementScale),
          (this.displacementBias = t.displacementBias),
          (this.alphaMap = t.alphaMap),
          (this.flatShading = t.flatShading),
          this
        );
      }
    }
    Kc.prototype.isMeshMatcapMaterial = !0;
    class tu extends Cl {
      constructor(t) {
        super(),
          (this.type = "LineDashedMaterial"),
          (this.scale = 1),
          (this.dashSize = 3),
          (this.gapSize = 1),
          this.setValues(t);
      }
      copy(t) {
        return (
          super.copy(t),
          (this.scale = t.scale),
          (this.dashSize = t.dashSize),
          (this.gapSize = t.gapSize),
          this
        );
      }
    }
    tu.prototype.isLineDashedMaterial = !0;
    const eu = {
      arraySlice: function (t, e, n) {
        return eu.isTypedArray(t)
          ? new t.constructor(t.subarray(e, void 0 !== n ? n : t.length))
          : t.slice(e, n);
      },
      convertArray: function (t, e, n) {
        return !t || (!n && t.constructor === e)
          ? t
          : "number" == typeof e.BYTES_PER_ELEMENT
          ? new e(t)
          : Array.prototype.slice.call(t);
      },
      isTypedArray: function (t) {
        return ArrayBuffer.isView(t) && !(t instanceof DataView);
      },
      getKeyframeOrder: function (t) {
        const e = t.length,
          n = new Array(e);
        for (let t = 0; t !== e; ++t) n[t] = t;
        return (
          n.sort(function (e, n) {
            return t[e] - t[n];
          }),
          n
        );
      },
      sortedArray: function (t, e, n) {
        const i = t.length,
          r = new t.constructor(i);
        for (let s = 0, o = 0; o !== i; ++s) {
          const i = n[s] * e;
          for (let n = 0; n !== e; ++n) r[o++] = t[i + n];
        }
        return r;
      },
      flattenJSON: function (t, e, n, i) {
        let r = 1,
          s = t[0];
        for (; void 0 !== s && void 0 === s[i]; ) s = t[r++];
        if (void 0 === s) return;
        let o = s[i];
        if (void 0 !== o)
          if (Array.isArray(o))
            do {
              (o = s[i]),
                void 0 !== o && (e.push(s.time), n.push.apply(n, o)),
                (s = t[r++]);
            } while (void 0 !== s);
          else if (void 0 !== o.toArray)
            do {
              (o = s[i]),
                void 0 !== o && (e.push(s.time), o.toArray(n, n.length)),
                (s = t[r++]);
            } while (void 0 !== s);
          else
            do {
              (o = s[i]),
                void 0 !== o && (e.push(s.time), n.push(o)),
                (s = t[r++]);
            } while (void 0 !== s);
      },
      subclip: function (t, e, n, i, r = 30) {
        const s = t.clone();
        s.name = e;
        const o = [];
        for (let t = 0; t < s.tracks.length; ++t) {
          const e = s.tracks[t],
            a = e.getValueSize(),
            l = [],
            c = [];
          for (let t = 0; t < e.times.length; ++t) {
            const s = e.times[t] * r;
            if (!(s < n || s >= i)) {
              l.push(e.times[t]);
              for (let n = 0; n < a; ++n) c.push(e.values[t * a + n]);
            }
          }
          0 !== l.length &&
            ((e.times = eu.convertArray(l, e.times.constructor)),
            (e.values = eu.convertArray(c, e.values.constructor)),
            o.push(e));
        }
        s.tracks = o;
        let a = 1 / 0;
        for (let t = 0; t < s.tracks.length; ++t)
          a > s.tracks[t].times[0] && (a = s.tracks[t].times[0]);
        for (let t = 0; t < s.tracks.length; ++t) s.tracks[t].shift(-1 * a);
        return s.resetDuration(), s;
      },
      makeClipAdditive: function (t, e = 0, n = t, i = 30) {
        i <= 0 && (i = 30);
        const r = n.tracks.length,
          s = e / i;
        for (let e = 0; e < r; ++e) {
          const i = n.tracks[e],
            r = i.ValueTypeName;
          if ("bool" === r || "string" === r) continue;
          const o = t.tracks.find(function (t) {
            return t.name === i.name && t.ValueTypeName === r;
          });
          if (void 0 === o) continue;
          let a = 0;
          const l = i.getValueSize();
          i.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline &&
            (a = l / 3);
          let c = 0;
          const u = o.getValueSize();
          o.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline &&
            (c = u / 3);
          const h = i.times.length - 1;
          let d;
          if (s <= i.times[0]) {
            const t = a,
              e = l - a;
            d = eu.arraySlice(i.values, t, e);
          } else if (s >= i.times[h]) {
            const t = h * l + a,
              e = t + l - a;
            d = eu.arraySlice(i.values, t, e);
          } else {
            const t = i.createInterpolant(),
              e = a,
              n = l - a;
            t.evaluate(s), (d = eu.arraySlice(t.resultBuffer, e, n));
          }
          if ("quaternion" === r) {
            new Sn().fromArray(d).normalize().conjugate().toArray(d);
          }
          const p = o.times.length;
          for (let t = 0; t < p; ++t) {
            const e = t * u + c;
            if ("quaternion" === r)
              Sn.multiplyQuaternionsFlat(o.values, e, d, 0, o.values, e);
            else {
              const t = u - 2 * c;
              for (let n = 0; n < t; ++n) o.values[e + n] -= d[n];
            }
          }
        }
        return (t.blendMode = Ve), t;
      },
    };
    class nu {
      constructor(t, e, n, i) {
        (this.parameterPositions = t),
          (this._cachedIndex = 0),
          (this.resultBuffer = void 0 !== i ? i : new e.constructor(n)),
          (this.sampleValues = e),
          (this.valueSize = n),
          (this.settings = null),
          (this.DefaultSettings_ = {});
      }
      evaluate(t) {
        const e = this.parameterPositions;
        let n = this._cachedIndex,
          i = e[n],
          r = e[n - 1];
        t: {
          e: {
            let s;
            n: {
              i: if (!(t < i)) {
                for (let s = n + 2; ; ) {
                  if (void 0 === i) {
                    if (t < r) break i;
                    return (
                      (n = e.length),
                      (this._cachedIndex = n),
                      this.afterEnd_(n - 1, t, r)
                    );
                  }
                  if (n === s) break;
                  if (((r = i), (i = e[++n]), t < i)) break e;
                }
                s = e.length;
                break n;
              }
              if (t >= r) break t;
              {
                const o = e[1];
                t < o && ((n = 2), (r = o));
                for (let s = n - 2; ; ) {
                  if (void 0 === r)
                    return (this._cachedIndex = 0), this.beforeStart_(0, t, i);
                  if (n === s) break;
                  if (((i = r), (r = e[--n - 1]), t >= r)) break e;
                }
                (s = n), (n = 0);
              }
            }
            for (; n < s; ) {
              const i = (n + s) >>> 1;
              t < e[i] ? (s = i) : (n = i + 1);
            }
            if (((i = e[n]), (r = e[n - 1]), void 0 === r))
              return (this._cachedIndex = 0), this.beforeStart_(0, t, i);
            if (void 0 === i)
              return (
                (n = e.length),
                (this._cachedIndex = n),
                this.afterEnd_(n - 1, r, t)
              );
          }
          (this._cachedIndex = n), this.intervalChanged_(n, r, i);
        }
        return this.interpolate_(n, r, t, i);
      }
      getSettings_() {
        return this.settings || this.DefaultSettings_;
      }
      copySampleValue_(t) {
        const e = this.resultBuffer,
          n = this.sampleValues,
          i = this.valueSize,
          r = t * i;
        for (let t = 0; t !== i; ++t) e[t] = n[r + t];
        return e;
      }
      interpolate_() {
        throw new Error("call to abstract method");
      }
      intervalChanged_() {}
    }
    (nu.prototype.beforeStart_ = nu.prototype.copySampleValue_),
      (nu.prototype.afterEnd_ = nu.prototype.copySampleValue_);
    class iu extends nu {
      constructor(t, e, n, i) {
        super(t, e, n, i),
          (this._weightPrev = -0),
          (this._offsetPrev = -0),
          (this._weightNext = -0),
          (this._offsetNext = -0),
          (this.DefaultSettings_ = { endingStart: He, endingEnd: He });
      }
      intervalChanged_(t, e, n) {
        const i = this.parameterPositions;
        let r = t - 2,
          s = t + 1,
          o = i[r],
          a = i[s];
        if (void 0 === o)
          switch (this.getSettings_().endingStart) {
            case Be:
              (r = t), (o = 2 * e - n);
              break;
            case Ue:
              (r = i.length - 2), (o = e + i[r] - i[r + 1]);
              break;
            default:
              (r = t), (o = n);
          }
        if (void 0 === a)
          switch (this.getSettings_().endingEnd) {
            case Be:
              (s = t), (a = 2 * n - e);
              break;
            case Ue:
              (s = 1), (a = n + i[1] - i[0]);
              break;
            default:
              (s = t - 1), (a = e);
          }
        const l = 0.5 * (n - e),
          c = this.valueSize;
        (this._weightPrev = l / (e - o)),
          (this._weightNext = l / (a - n)),
          (this._offsetPrev = r * c),
          (this._offsetNext = s * c);
      }
      interpolate_(t, e, n, i) {
        const r = this.resultBuffer,
          s = this.sampleValues,
          o = this.valueSize,
          a = t * o,
          l = a - o,
          c = this._offsetPrev,
          u = this._offsetNext,
          h = this._weightPrev,
          d = this._weightNext,
          p = (n - e) / (i - e),
          f = p * p,
          m = f * p,
          g = -h * m + 2 * h * f - h * p,
          v = (1 + h) * m + (-1.5 - 2 * h) * f + (-0.5 + h) * p + 1,
          y = (-1 - d) * m + (1.5 + d) * f + 0.5 * p,
          x = d * m - d * f;
        for (let t = 0; t !== o; ++t)
          r[t] = g * s[c + t] + v * s[l + t] + y * s[a + t] + x * s[u + t];
        return r;
      }
    }
    class ru extends nu {
      constructor(t, e, n, i) {
        super(t, e, n, i);
      }
      interpolate_(t, e, n, i) {
        const r = this.resultBuffer,
          s = this.sampleValues,
          o = this.valueSize,
          a = t * o,
          l = a - o,
          c = (n - e) / (i - e),
          u = 1 - c;
        for (let t = 0; t !== o; ++t) r[t] = s[l + t] * u + s[a + t] * c;
        return r;
      }
    }
    class su extends nu {
      constructor(t, e, n, i) {
        super(t, e, n, i);
      }
      interpolate_(t) {
        return this.copySampleValue_(t - 1);
      }
    }
    class ou {
      constructor(t, e, n, i) {
        if (void 0 === t)
          throw new Error("THREE.KeyframeTrack: track name is undefined");
        if (void 0 === e || 0 === e.length)
          throw new Error(
            "THREE.KeyframeTrack: no keyframes in track named " + t
          );
        (this.name = t),
          (this.times = eu.convertArray(e, this.TimeBufferType)),
          (this.values = eu.convertArray(n, this.ValueBufferType)),
          this.setInterpolation(i || this.DefaultInterpolation);
      }
      static toJSON(t) {
        const e = t.constructor;
        let n;
        if (e.toJSON !== this.toJSON) n = e.toJSON(t);
        else {
          n = {
            name: t.name,
            times: eu.convertArray(t.times, Array),
            values: eu.convertArray(t.values, Array),
          };
          const e = t.getInterpolation();
          e !== t.DefaultInterpolation && (n.interpolation = e);
        }
        return (n.type = t.ValueTypeName), n;
      }
      InterpolantFactoryMethodDiscrete(t) {
        return new su(this.times, this.values, this.getValueSize(), t);
      }
      InterpolantFactoryMethodLinear(t) {
        return new ru(this.times, this.values, this.getValueSize(), t);
      }
      InterpolantFactoryMethodSmooth(t) {
        return new iu(this.times, this.values, this.getValueSize(), t);
      }
      setInterpolation(t) {
        let e;
        switch (t) {
          case Ne:
            e = this.InterpolantFactoryMethodDiscrete;
            break;
          case Oe:
            e = this.InterpolantFactoryMethodLinear;
            break;
          case ze:
            e = this.InterpolantFactoryMethodSmooth;
        }
        if (void 0 === e) {
          const e =
            "unsupported interpolation for " +
            this.ValueTypeName +
            " keyframe track named " +
            this.name;
          if (void 0 === this.createInterpolant) {
            if (t === this.DefaultInterpolation) throw new Error(e);
            this.setInterpolation(this.DefaultInterpolation);
          }
          return console.warn("THREE.KeyframeTrack:", e), this;
        }
        return (this.createInterpolant = e), this;
      }
      getInterpolation() {
        switch (this.createInterpolant) {
          case this.InterpolantFactoryMethodDiscrete:
            return Ne;
          case this.InterpolantFactoryMethodLinear:
            return Oe;
          case this.InterpolantFactoryMethodSmooth:
            return ze;
        }
      }
      getValueSize() {
        return this.values.length / this.times.length;
      }
      shift(t) {
        if (0 !== t) {
          const e = this.times;
          for (let n = 0, i = e.length; n !== i; ++n) e[n] += t;
        }
        return this;
      }
      scale(t) {
        if (1 !== t) {
          const e = this.times;
          for (let n = 0, i = e.length; n !== i; ++n) e[n] *= t;
        }
        return this;
      }
      trim(t, e) {
        const n = this.times,
          i = n.length;
        let r = 0,
          s = i - 1;
        for (; r !== i && n[r] < t; ) ++r;
        for (; -1 !== s && n[s] > e; ) --s;
        if ((++s, 0 !== r || s !== i)) {
          r >= s && ((s = Math.max(s, 1)), (r = s - 1));
          const t = this.getValueSize();
          (this.times = eu.arraySlice(n, r, s)),
            (this.values = eu.arraySlice(this.values, r * t, s * t));
        }
        return this;
      }
      validate() {
        let t = !0;
        const e = this.getValueSize();
        e - Math.floor(e) != 0 &&
          (console.error(
            "THREE.KeyframeTrack: Invalid value size in track.",
            this
          ),
          (t = !1));
        const n = this.times,
          i = this.values,
          r = n.length;
        0 === r &&
          (console.error("THREE.KeyframeTrack: Track is empty.", this),
          (t = !1));
        let s = null;
        for (let e = 0; e !== r; e++) {
          const i = n[e];
          if ("number" == typeof i && isNaN(i)) {
            console.error(
              "THREE.KeyframeTrack: Time is not a valid number.",
              this,
              e,
              i
            ),
              (t = !1);
            break;
          }
          if (null !== s && s > i) {
            console.error(
              "THREE.KeyframeTrack: Out of order keys.",
              this,
              e,
              i,
              s
            ),
              (t = !1);
            break;
          }
          s = i;
        }
        if (void 0 !== i && eu.isTypedArray(i))
          for (let e = 0, n = i.length; e !== n; ++e) {
            const n = i[e];
            if (isNaN(n)) {
              console.error(
                "THREE.KeyframeTrack: Value is not a valid number.",
                this,
                e,
                n
              ),
                (t = !1);
              break;
            }
          }
        return t;
      }
      optimize() {
        const t = eu.arraySlice(this.times),
          e = eu.arraySlice(this.values),
          n = this.getValueSize(),
          i = this.getInterpolation() === ze,
          r = t.length - 1;
        let s = 1;
        for (let o = 1; o < r; ++o) {
          let r = !1;
          const a = t[o];
          if (a !== t[o + 1] && (1 !== o || a !== t[0]))
            if (i) r = !0;
            else {
              const t = o * n,
                i = t - n,
                s = t + n;
              for (let o = 0; o !== n; ++o) {
                const n = e[t + o];
                if (n !== e[i + o] || n !== e[s + o]) {
                  r = !0;
                  break;
                }
              }
            }
          if (r) {
            if (o !== s) {
              t[s] = t[o];
              const i = o * n,
                r = s * n;
              for (let t = 0; t !== n; ++t) e[r + t] = e[i + t];
            }
            ++s;
          }
        }
        if (r > 0) {
          t[s] = t[r];
          for (let t = r * n, i = s * n, o = 0; o !== n; ++o)
            e[i + o] = e[t + o];
          ++s;
        }
        return (
          s !== t.length
            ? ((this.times = eu.arraySlice(t, 0, s)),
              (this.values = eu.arraySlice(e, 0, s * n)))
            : ((this.times = t), (this.values = e)),
          this
        );
      }
      clone() {
        const t = eu.arraySlice(this.times, 0),
          e = eu.arraySlice(this.values, 0),
          n = new (0, this.constructor)(this.name, t, e);
        return (n.createInterpolant = this.createInterpolant), n;
      }
    }
    (ou.prototype.TimeBufferType = Float32Array),
      (ou.prototype.ValueBufferType = Float32Array),
      (ou.prototype.DefaultInterpolation = Oe);
    class au extends ou {}
    (au.prototype.ValueTypeName = "bool"),
      (au.prototype.ValueBufferType = Array),
      (au.prototype.DefaultInterpolation = Ne),
      (au.prototype.InterpolantFactoryMethodLinear = void 0),
      (au.prototype.InterpolantFactoryMethodSmooth = void 0);
    class lu extends ou {}
    lu.prototype.ValueTypeName = "color";
    class cu extends ou {}
    cu.prototype.ValueTypeName = "number";
    class uu extends nu {
      constructor(t, e, n, i) {
        super(t, e, n, i);
      }
      interpolate_(t, e, n, i) {
        const r = this.resultBuffer,
          s = this.sampleValues,
          o = this.valueSize,
          a = (n - e) / (i - e);
        let l = t * o;
        for (let t = l + o; l !== t; l += 4)
          Sn.slerpFlat(r, 0, s, l - o, s, l, a);
        return r;
      }
    }
    class hu extends ou {
      InterpolantFactoryMethodLinear(t) {
        return new uu(this.times, this.values, this.getValueSize(), t);
      }
    }
    (hu.prototype.ValueTypeName = "quaternion"),
      (hu.prototype.DefaultInterpolation = Oe),
      (hu.prototype.InterpolantFactoryMethodSmooth = void 0);
    class du extends ou {}
    (du.prototype.ValueTypeName = "string"),
      (du.prototype.ValueBufferType = Array),
      (du.prototype.DefaultInterpolation = Ne),
      (du.prototype.InterpolantFactoryMethodLinear = void 0),
      (du.prototype.InterpolantFactoryMethodSmooth = void 0);
    class pu extends ou {}
    pu.prototype.ValueTypeName = "vector";
    class fu {
      constructor(t, e = -1, n, i = Fe) {
        (this.name = t),
          (this.tracks = n),
          (this.duration = e),
          (this.blendMode = i),
          (this.uuid = sn()),
          this.duration < 0 && this.resetDuration();
      }
      static parse(t) {
        const e = [],
          n = t.tracks,
          i = 1 / (t.fps || 1);
        for (let t = 0, r = n.length; t !== r; ++t) e.push(mu(n[t]).scale(i));
        const r = new this(t.name, t.duration, e, t.blendMode);
        return (r.uuid = t.uuid), r;
      }
      static toJSON(t) {
        const e = [],
          n = t.tracks,
          i = {
            name: t.name,
            duration: t.duration,
            tracks: e,
            uuid: t.uuid,
            blendMode: t.blendMode,
          };
        for (let t = 0, i = n.length; t !== i; ++t) e.push(ou.toJSON(n[t]));
        return i;
      }
      static CreateFromMorphTargetSequence(t, e, n, i) {
        const r = e.length,
          s = [];
        for (let t = 0; t < r; t++) {
          let o = [],
            a = [];
          o.push((t + r - 1) % r, t, (t + 1) % r), a.push(0, 1, 0);
          const l = eu.getKeyframeOrder(o);
          (o = eu.sortedArray(o, 1, l)),
            (a = eu.sortedArray(a, 1, l)),
            i || 0 !== o[0] || (o.push(r), a.push(a[0])),
            s.push(
              new cu(".morphTargetInfluences[" + e[t].name + "]", o, a).scale(
                1 / n
              )
            );
        }
        return new this(t, -1, s);
      }
      static findByName(t, e) {
        let n = t;
        if (!Array.isArray(t)) {
          const e = t;
          n = (e.geometry && e.geometry.animations) || e.animations;
        }
        for (let t = 0; t < n.length; t++) if (n[t].name === e) return n[t];
        return null;
      }
      static CreateClipsFromMorphTargetSequences(t, e, n) {
        const i = {},
          r = /^([\w-]*?)([\d]+)$/;
        for (let e = 0, n = t.length; e < n; e++) {
          const n = t[e],
            s = n.name.match(r);
          if (s && s.length > 1) {
            const t = s[1];
            let e = i[t];
            e || (i[t] = e = []), e.push(n);
          }
        }
        const s = [];
        for (const t in i)
          s.push(this.CreateFromMorphTargetSequence(t, i[t], e, n));
        return s;
      }
      static parseAnimation(t, e) {
        if (!t)
          return (
            console.error(
              "THREE.AnimationClip: No animation in JSONLoader data."
            ),
            null
          );
        const n = function (t, e, n, i, r) {
            if (0 !== n.length) {
              const s = [],
                o = [];
              eu.flattenJSON(n, s, o, i),
                0 !== s.length && r.push(new t(e, s, o));
            }
          },
          i = [],
          r = t.name || "default",
          s = t.fps || 30,
          o = t.blendMode;
        let a = t.length || -1;
        const l = t.hierarchy || [];
        for (let t = 0; t < l.length; t++) {
          const r = l[t].keys;
          if (r && 0 !== r.length)
            if (r[0].morphTargets) {
              const t = {};
              let e;
              for (e = 0; e < r.length; e++)
                if (r[e].morphTargets)
                  for (let n = 0; n < r[e].morphTargets.length; n++)
                    t[r[e].morphTargets[n]] = -1;
              for (const n in t) {
                const t = [],
                  s = [];
                for (let i = 0; i !== r[e].morphTargets.length; ++i) {
                  const i = r[e];
                  t.push(i.time), s.push(i.morphTarget === n ? 1 : 0);
                }
                i.push(new cu(".morphTargetInfluence[" + n + "]", t, s));
              }
              a = t.length * (s || 1);
            } else {
              const s = ".bones[" + e[t].name + "]";
              n(pu, s + ".position", r, "pos", i),
                n(hu, s + ".quaternion", r, "rot", i),
                n(pu, s + ".scale", r, "scl", i);
            }
        }
        return 0 === i.length ? null : new this(r, a, i, o);
      }
      resetDuration() {
        let t = 0;
        for (let e = 0, n = this.tracks.length; e !== n; ++e) {
          const n = this.tracks[e];
          t = Math.max(t, n.times[n.times.length - 1]);
        }
        return (this.duration = t), this;
      }
      trim() {
        for (let t = 0; t < this.tracks.length; t++)
          this.tracks[t].trim(0, this.duration);
        return this;
      }
      validate() {
        let t = !0;
        for (let e = 0; e < this.tracks.length; e++)
          t = t && this.tracks[e].validate();
        return t;
      }
      optimize() {
        for (let t = 0; t < this.tracks.length; t++) this.tracks[t].optimize();
        return this;
      }
      clone() {
        const t = [];
        for (let e = 0; e < this.tracks.length; e++)
          t.push(this.tracks[e].clone());
        return new this.constructor(
          this.name,
          this.duration,
          t,
          this.blendMode
        );
      }
      toJSON() {
        return this.constructor.toJSON(this);
      }
    }
    function mu(t) {
      if (void 0 === t.type)
        throw new Error(
          "THREE.KeyframeTrack: track type undefined, can not parse"
        );
      const e = (function (t) {
        switch (t.toLowerCase()) {
          case "scalar":
          case "double":
          case "float":
          case "number":
          case "integer":
            return cu;
          case "vector":
          case "vector2":
          case "vector3":
          case "vector4":
            return pu;
          case "color":
            return lu;
          case "quaternion":
            return hu;
          case "bool":
          case "boolean":
            return au;
          case "string":
            return du;
        }
        throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + t);
      })(t.type);
      if (void 0 === t.times) {
        const e = [],
          n = [];
        eu.flattenJSON(t.keys, e, n, "value"), (t.times = e), (t.values = n);
      }
      return void 0 !== e.parse
        ? e.parse(t)
        : new e(t.name, t.times, t.values, t.interpolation);
    }
    const gu = {
      enabled: !1,
      files: {},
      add: function (t, e) {
        !1 !== this.enabled && (this.files[t] = e);
      },
      get: function (t) {
        if (!1 !== this.enabled) return this.files[t];
      },
      remove: function (t) {
        delete this.files[t];
      },
      clear: function () {
        this.files = {};
      },
    };
    class vu {
      constructor(t, e, n) {
        const i = this;
        let r = !1,
          s = 0,
          o = 0,
          a = void 0;
        const l = [];
        (this.onStart = void 0),
          (this.onLoad = t),
          (this.onProgress = e),
          (this.onError = n),
          (this.itemStart = function (t) {
            o++,
              !1 === r && void 0 !== i.onStart && i.onStart(t, s, o),
              (r = !0);
          }),
          (this.itemEnd = function (t) {
            s++,
              void 0 !== i.onProgress && i.onProgress(t, s, o),
              s === o && ((r = !1), void 0 !== i.onLoad && i.onLoad());
          }),
          (this.itemError = function (t) {
            void 0 !== i.onError && i.onError(t);
          }),
          (this.resolveURL = function (t) {
            return a ? a(t) : t;
          }),
          (this.setURLModifier = function (t) {
            return (a = t), this;
          }),
          (this.addHandler = function (t, e) {
            return l.push(t, e), this;
          }),
          (this.removeHandler = function (t) {
            const e = l.indexOf(t);
            return -1 !== e && l.splice(e, 2), this;
          }),
          (this.getHandler = function (t) {
            for (let e = 0, n = l.length; e < n; e += 2) {
              const n = l[e],
                i = l[e + 1];
              if ((n.global && (n.lastIndex = 0), n.test(t))) return i;
            }
            return null;
          });
      }
    }
    const yu = new vu();
    class xu {
      constructor(t) {
        (this.manager = void 0 !== t ? t : yu),
          (this.crossOrigin = "anonymous"),
          (this.withCredentials = !1),
          (this.path = ""),
          (this.resourcePath = ""),
          (this.requestHeader = {});
      }
      load() {}
      loadAsync(t, e) {
        const n = this;
        return new Promise(function (i, r) {
          n.load(t, i, e, r);
        });
      }
      parse() {}
      setCrossOrigin(t) {
        return (this.crossOrigin = t), this;
      }
      setWithCredentials(t) {
        return (this.withCredentials = t), this;
      }
      setPath(t) {
        return (this.path = t), this;
      }
      setResourcePath(t) {
        return (this.resourcePath = t), this;
      }
      setRequestHeader(t) {
        return (this.requestHeader = t), this;
      }
    }
    const bu = {};
    class _u extends xu {
      constructor(t) {
        super(t);
      }
      load(t, e, n, i) {
        void 0 === t && (t = ""),
          void 0 !== this.path && (t = this.path + t),
          (t = this.manager.resolveURL(t));
        const r = gu.get(t);
        if (void 0 !== r)
          return (
            this.manager.itemStart(t),
            setTimeout(() => {
              e && e(r), this.manager.itemEnd(t);
            }, 0),
            r
          );
        if (void 0 !== bu[t])
          return void bu[t].push({ onLoad: e, onProgress: n, onError: i });
        (bu[t] = []), bu[t].push({ onLoad: e, onProgress: n, onError: i });
        const s = new Request(t, {
          headers: new Headers(this.requestHeader),
          credentials: this.withCredentials ? "include" : "same-origin",
        });
        fetch(s)
          .then((e) => {
            if (200 === e.status || 0 === e.status) {
              if (
                (0 === e.status &&
                  console.warn("THREE.FileLoader: HTTP Status 0 received."),
                "undefined" == typeof ReadableStream ||
                  void 0 === e.body.getReader)
              )
                return e;
              const n = bu[t],
                i = e.body.getReader(),
                r = e.headers.get("Content-Length"),
                s = r ? parseInt(r) : 0,
                o = 0 !== s;
              let a = 0;
              const l = new ReadableStream({
                start(t) {
                  !(function e() {
                    i.read().then(({ done: i, value: r }) => {
                      if (i) t.close();
                      else {
                        a += r.byteLength;
                        const i = new ProgressEvent("progress", {
                          lengthComputable: o,
                          loaded: a,
                          total: s,
                        });
                        for (let t = 0, e = n.length; t < e; t++) {
                          const e = n[t];
                          e.onProgress && e.onProgress(i);
                        }
                        t.enqueue(r), e();
                      }
                    });
                  })();
                },
              });
              return new Response(l);
            }
            throw Error(
              `fetch for "${e.url}" responded with ${e.status}: ${e.statusText}`
            );
          })
          .then((t) => {
            switch (this.responseType) {
              case "arraybuffer":
                return t.arrayBuffer();
              case "blob":
                return t.blob();
              case "document":
                return t.text().then((t) => {
                  return new DOMParser().parseFromString(t, this.mimeType);
                });
              case "json":
                return t.json();
              default:
                return t.text();
            }
          })
          .then((e) => {
            gu.add(t, e);
            const n = bu[t];
            delete bu[t];
            for (let t = 0, i = n.length; t < i; t++) {
              const i = n[t];
              i.onLoad && i.onLoad(e);
            }
          })
          .catch((e) => {
            const n = bu[t];
            if (void 0 === n) throw (this.manager.itemError(t), e);
            delete bu[t];
            for (let t = 0, i = n.length; t < i; t++) {
              const i = n[t];
              i.onError && i.onError(e);
            }
            this.manager.itemError(t);
          })
          .finally(() => {
            this.manager.itemEnd(t);
          }),
          this.manager.itemStart(t);
      }
      setResponseType(t) {
        return (this.responseType = t), this;
      }
      setMimeType(t) {
        return (this.mimeType = t), this;
      }
    }
    class wu extends xu {
      constructor(t) {
        super(t);
      }
      load(t, e, n, i) {
        void 0 !== this.path && (t = this.path + t),
          (t = this.manager.resolveURL(t));
        const r = this,
          s = gu.get(t);
        if (void 0 !== s)
          return (
            r.manager.itemStart(t),
            setTimeout(function () {
              e && e(s), r.manager.itemEnd(t);
            }, 0),
            s
          );
        const o = fn("img");
        function a() {
          c(), gu.add(t, this), e && e(this), r.manager.itemEnd(t);
        }
        function l(e) {
          c(), i && i(e), r.manager.itemError(t), r.manager.itemEnd(t);
        }
        function c() {
          o.removeEventListener("load", a, !1),
            o.removeEventListener("error", l, !1);
        }
        return (
          o.addEventListener("load", a, !1),
          o.addEventListener("error", l, !1),
          "data:" !== t.substr(0, 5) &&
            void 0 !== this.crossOrigin &&
            (o.crossOrigin = this.crossOrigin),
          r.manager.itemStart(t),
          (o.src = t),
          o
        );
      }
    }
    class Su extends xu {
      constructor(t) {
        super(t);
      }
      load(t, e, n, i) {
        const r = new Br(),
          s = new wu(this.manager);
        s.setCrossOrigin(this.crossOrigin), s.setPath(this.path);
        let o = 0;
        function a(n) {
          s.load(
            t[n],
            function (t) {
              (r.images[n] = t),
                o++,
                6 === o && ((r.needsUpdate = !0), e && e(r));
            },
            void 0,
            i
          );
        }
        for (let e = 0; e < t.length; ++e) a(e);
        return r;
      }
    }
    class Mu extends xu {
      constructor(t) {
        super(t);
      }
      load(t, e, n, i) {
        const r = new yn(),
          s = new wu(this.manager);
        return (
          s.setCrossOrigin(this.crossOrigin),
          s.setPath(this.path),
          s.load(
            t,
            function (t) {
              (r.image = t), (r.needsUpdate = !0), void 0 !== e && e(r);
            },
            n,
            i
          ),
          r
        );
      }
    }
    class Tu extends Ei {
      constructor(t, e = 1) {
        super(),
          (this.type = "Light"),
          (this.color = new qi(t)),
          (this.intensity = e);
      }
      dispose() {}
      copy(t) {
        return (
          super.copy(t),
          this.color.copy(t.color),
          (this.intensity = t.intensity),
          this
        );
      }
      toJSON(t) {
        const e = super.toJSON(t);
        return (
          (e.object.color = this.color.getHex()),
          (e.object.intensity = this.intensity),
          void 0 !== this.groundColor &&
            (e.object.groundColor = this.groundColor.getHex()),
          void 0 !== this.distance && (e.object.distance = this.distance),
          void 0 !== this.angle && (e.object.angle = this.angle),
          void 0 !== this.decay && (e.object.decay = this.decay),
          void 0 !== this.penumbra && (e.object.penumbra = this.penumbra),
          void 0 !== this.shadow && (e.object.shadow = this.shadow.toJSON()),
          e
        );
      }
    }
    Tu.prototype.isLight = !0;
    class Eu extends Tu {
      constructor(t, e, n) {
        super(t, n),
          (this.type = "HemisphereLight"),
          this.position.copy(Ei.DefaultUp),
          this.updateMatrix(),
          (this.groundColor = new qi(e));
      }
      copy(t) {
        return (
          Tu.prototype.copy.call(this, t),
          this.groundColor.copy(t.groundColor),
          this
        );
      }
    }
    Eu.prototype.isHemisphereLight = !0;
    const Au = new ei(),
      Cu = new Mn(),
      Lu = new Mn();
    class Ru {
      constructor(t) {
        (this.camera = t),
          (this.bias = 0),
          (this.normalBias = 0),
          (this.radius = 1),
          (this.blurSamples = 8),
          (this.mapSize = new hn(512, 512)),
          (this.map = null),
          (this.mapPass = null),
          (this.matrix = new ei()),
          (this.autoUpdate = !0),
          (this.needsUpdate = !1),
          (this._frustum = new $r()),
          (this._frameExtents = new hn(1, 1)),
          (this._viewportCount = 1),
          (this._viewports = [new bn(0, 0, 1, 1)]);
      }
      getViewportCount() {
        return this._viewportCount;
      }
      getFrustum() {
        return this._frustum;
      }
      updateMatrices(t) {
        const e = this.camera,
          n = this.matrix;
        Cu.setFromMatrixPosition(t.matrixWorld),
          e.position.copy(Cu),
          Lu.setFromMatrixPosition(t.target.matrixWorld),
          e.lookAt(Lu),
          e.updateMatrixWorld(),
          Au.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse),
          this._frustum.setFromProjectionMatrix(Au),
          n.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1),
          n.multiply(e.projectionMatrix),
          n.multiply(e.matrixWorldInverse);
      }
      getViewport(t) {
        return this._viewports[t];
      }
      getFrameExtents() {
        return this._frameExtents;
      }
      dispose() {
        this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
      }
      copy(t) {
        return (
          (this.camera = t.camera.clone()),
          (this.bias = t.bias),
          (this.radius = t.radius),
          this.mapSize.copy(t.mapSize),
          this
        );
      }
      clone() {
        return new this.constructor().copy(this);
      }
      toJSON() {
        const t = {};
        return (
          0 !== this.bias && (t.bias = this.bias),
          0 !== this.normalBias && (t.normalBias = this.normalBias),
          1 !== this.radius && (t.radius = this.radius),
          (512 === this.mapSize.x && 512 === this.mapSize.y) ||
            (t.mapSize = this.mapSize.toArray()),
          (t.camera = this.camera.toJSON(!1).object),
          delete t.camera.matrix,
          t
        );
      }
    }
    class Pu extends Ru {
      constructor() {
        super(new Nr(50, 1, 0.5, 500)), (this.focus = 1);
      }
      updateMatrices(t) {
        const e = this.camera,
          n = 2 * rn * t.angle * this.focus,
          i = this.mapSize.width / this.mapSize.height,
          r = t.distance || e.far;
        (n === e.fov && i === e.aspect && r === e.far) ||
          ((e.fov = n),
          (e.aspect = i),
          (e.far = r),
          e.updateProjectionMatrix()),
          super.updateMatrices(t);
      }
      copy(t) {
        return super.copy(t), (this.focus = t.focus), this;
      }
    }
    Pu.prototype.isSpotLightShadow = !0;
    class Du extends Tu {
      constructor(t, e, n = 0, i = Math.PI / 3, r = 0, s = 1) {
        super(t, e),
          (this.type = "SpotLight"),
          this.position.copy(Ei.DefaultUp),
          this.updateMatrix(),
          (this.target = new Ei()),
          (this.distance = n),
          (this.angle = i),
          (this.penumbra = r),
          (this.decay = s),
          (this.shadow = new Pu());
      }
      get power() {
        return this.intensity * Math.PI;
      }
      set power(t) {
        this.intensity = t / Math.PI;
      }
      dispose() {
        this.shadow.dispose();
      }
      copy(t) {
        return (
          super.copy(t),
          (this.distance = t.distance),
          (this.angle = t.angle),
          (this.penumbra = t.penumbra),
          (this.decay = t.decay),
          (this.target = t.target.clone()),
          (this.shadow = t.shadow.clone()),
          this
        );
      }
    }
    Du.prototype.isSpotLight = !0;
    const ku = new ei(),
      Iu = new Mn(),
      Nu = new Mn();
    class Ou extends Ru {
      constructor() {
        super(new Nr(90, 1, 0.5, 500)),
          (this._frameExtents = new hn(4, 2)),
          (this._viewportCount = 6),
          (this._viewports = [
            new bn(2, 1, 1, 1),
            new bn(0, 1, 1, 1),
            new bn(3, 1, 1, 1),
            new bn(1, 1, 1, 1),
            new bn(3, 0, 1, 1),
            new bn(1, 0, 1, 1),
          ]),
          (this._cubeDirections = [
            new Mn(1, 0, 0),
            new Mn(-1, 0, 0),
            new Mn(0, 0, 1),
            new Mn(0, 0, -1),
            new Mn(0, 1, 0),
            new Mn(0, -1, 0),
          ]),
          (this._cubeUps = [
            new Mn(0, 1, 0),
            new Mn(0, 1, 0),
            new Mn(0, 1, 0),
            new Mn(0, 1, 0),
            new Mn(0, 0, 1),
            new Mn(0, 0, -1),
          ]);
      }
      updateMatrices(t, e = 0) {
        const n = this.camera,
          i = this.matrix,
          r = t.distance || n.far;
        r !== n.far && ((n.far = r), n.updateProjectionMatrix()),
          Iu.setFromMatrixPosition(t.matrixWorld),
          n.position.copy(Iu),
          Nu.copy(n.position),
          Nu.add(this._cubeDirections[e]),
          n.up.copy(this._cubeUps[e]),
          n.lookAt(Nu),
          n.updateMatrixWorld(),
          i.makeTranslation(-Iu.x, -Iu.y, -Iu.z),
          ku.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse),
          this._frustum.setFromProjectionMatrix(ku);
      }
    }
    Ou.prototype.isPointLightShadow = !0;
    class zu extends Tu {
      constructor(t, e, n = 0, i = 1) {
        super(t, e),
          (this.type = "PointLight"),
          (this.distance = n),
          (this.decay = i),
          (this.shadow = new Ou());
      }
      get power() {
        return 4 * this.intensity * Math.PI;
      }
      set power(t) {
        this.intensity = t / (4 * Math.PI);
      }
      dispose() {
        this.shadow.dispose();
      }
      copy(t) {
        return (
          super.copy(t),
          (this.distance = t.distance),
          (this.decay = t.decay),
          (this.shadow = t.shadow.clone()),
          this
        );
      }
    }
    zu.prototype.isPointLight = !0;
    class Hu extends Ru {
      constructor() {
        super(new os(-5, 5, 5, -5, 0.5, 500));
      }
    }
    Hu.prototype.isDirectionalLightShadow = !0;
    class Bu extends Tu {
      constructor(t, e) {
        super(t, e),
          (this.type = "DirectionalLight"),
          this.position.copy(Ei.DefaultUp),
          this.updateMatrix(),
          (this.target = new Ei()),
          (this.shadow = new Hu());
      }
      dispose() {
        this.shadow.dispose();
      }
      copy(t) {
        return (
          super.copy(t),
          (this.target = t.target.clone()),
          (this.shadow = t.shadow.clone()),
          this
        );
      }
    }
    Bu.prototype.isDirectionalLight = !0;
    class Uu extends Tu {
      constructor(t, e) {
        super(t, e), (this.type = "AmbientLight");
      }
    }
    Uu.prototype.isAmbientLight = !0;
    class Fu extends Tu {
      constructor(t, e, n = 10, i = 10) {
        super(t, e),
          (this.type = "RectAreaLight"),
          (this.width = n),
          (this.height = i);
      }
      get power() {
        return this.intensity * this.width * this.height * Math.PI;
      }
      set power(t) {
        this.intensity = t / (this.width * this.height * Math.PI);
      }
      copy(t) {
        return (
          super.copy(t), (this.width = t.width), (this.height = t.height), this
        );
      }
      toJSON(t) {
        const e = super.toJSON(t);
        return (
          (e.object.width = this.width), (e.object.height = this.height), e
        );
      }
    }
    Fu.prototype.isRectAreaLight = !0;
    class Vu {
      constructor() {
        this.coefficients = [];
        for (let t = 0; t < 9; t++) this.coefficients.push(new Mn());
      }
      set(t) {
        for (let e = 0; e < 9; e++) this.coefficients[e].copy(t[e]);
        return this;
      }
      zero() {
        for (let t = 0; t < 9; t++) this.coefficients[t].set(0, 0, 0);
        return this;
      }
      getAt(t, e) {
        const n = t.x,
          i = t.y,
          r = t.z,
          s = this.coefficients;
        return (
          e.copy(s[0]).multiplyScalar(0.282095),
          e.addScaledVector(s[1], 0.488603 * i),
          e.addScaledVector(s[2], 0.488603 * r),
          e.addScaledVector(s[3], 0.488603 * n),
          e.addScaledVector(s[4], n * i * 1.092548),
          e.addScaledVector(s[5], i * r * 1.092548),
          e.addScaledVector(s[6], 0.315392 * (3 * r * r - 1)),
          e.addScaledVector(s[7], n * r * 1.092548),
          e.addScaledVector(s[8], 0.546274 * (n * n - i * i)),
          e
        );
      }
      getIrradianceAt(t, e) {
        const n = t.x,
          i = t.y,
          r = t.z,
          s = this.coefficients;
        return (
          e.copy(s[0]).multiplyScalar(0.886227),
          e.addScaledVector(s[1], 1.023328 * i),
          e.addScaledVector(s[2], 1.023328 * r),
          e.addScaledVector(s[3], 1.023328 * n),
          e.addScaledVector(s[4], 0.858086 * n * i),
          e.addScaledVector(s[5], 0.858086 * i * r),
          e.addScaledVector(s[6], 0.743125 * r * r - 0.247708),
          e.addScaledVector(s[7], 0.858086 * n * r),
          e.addScaledVector(s[8], 0.429043 * (n * n - i * i)),
          e
        );
      }
      add(t) {
        for (let e = 0; e < 9; e++) this.coefficients[e].add(t.coefficients[e]);
        return this;
      }
      addScaledSH(t, e) {
        for (let n = 0; n < 9; n++)
          this.coefficients[n].addScaledVector(t.coefficients[n], e);
        return this;
      }
      scale(t) {
        for (let e = 0; e < 9; e++) this.coefficients[e].multiplyScalar(t);
        return this;
      }
      lerp(t, e) {
        for (let n = 0; n < 9; n++)
          this.coefficients[n].lerp(t.coefficients[n], e);
        return this;
      }
      equals(t) {
        for (let e = 0; e < 9; e++)
          if (!this.coefficients[e].equals(t.coefficients[e])) return !1;
        return !0;
      }
      copy(t) {
        return this.set(t.coefficients);
      }
      clone() {
        return new this.constructor().copy(this);
      }
      fromArray(t, e = 0) {
        const n = this.coefficients;
        for (let i = 0; i < 9; i++) n[i].fromArray(t, e + 3 * i);
        return this;
      }
      toArray(t = [], e = 0) {
        const n = this.coefficients;
        for (let i = 0; i < 9; i++) n[i].toArray(t, e + 3 * i);
        return t;
      }
      static getBasisAt(t, e) {
        const n = t.x,
          i = t.y,
          r = t.z;
        (e[0] = 0.282095),
          (e[1] = 0.488603 * i),
          (e[2] = 0.488603 * r),
          (e[3] = 0.488603 * n),
          (e[4] = 1.092548 * n * i),
          (e[5] = 1.092548 * i * r),
          (e[6] = 0.315392 * (3 * r * r - 1)),
          (e[7] = 1.092548 * n * r),
          (e[8] = 0.546274 * (n * n - i * i));
      }
    }
    Vu.prototype.isSphericalHarmonics3 = !0;
    class Wu extends Tu {
      constructor(t = new Vu(), e = 1) {
        super(void 0, e), (this.sh = t);
      }
      copy(t) {
        return super.copy(t), this.sh.copy(t.sh), this;
      }
      fromJSON(t) {
        return (this.intensity = t.intensity), this.sh.fromArray(t.sh), this;
      }
      toJSON(t) {
        const e = super.toJSON(t);
        return (e.object.sh = this.sh.toArray()), e;
      }
    }
    Wu.prototype.isLightProbe = !0;
    class Gu {
      static decodeText(t) {
        if ("undefined" != typeof TextDecoder)
          return new TextDecoder().decode(t);
        let e = "";
        for (let n = 0, i = t.length; n < i; n++)
          e += String.fromCharCode(t[n]);
        try {
          return decodeURIComponent(escape(e));
        } catch (t) {
          return e;
        }
      }
      static extractUrlBase(t) {
        const e = t.lastIndexOf("/");
        return -1 === e ? "./" : t.substr(0, e + 1);
      }
      static resolveURL(t, e) {
        return "string" != typeof t || "" === t
          ? ""
          : (/^https?:\/\//i.test(e) &&
              /^\//.test(t) &&
              (e = e.replace(/(^https?:\/\/[^\/]+).*/i, "$1")),
            /^(https?:)?\/\//i.test(t)
              ? t
              : /^data:.*,.*$/i.test(t)
              ? t
              : /^blob:.*$/i.test(t)
              ? t
              : e + t);
      }
    }
    class ju extends ar {
      constructor() {
        super(),
          (this.type = "InstancedBufferGeometry"),
          (this.instanceCount = 1 / 0);
      }
      copy(t) {
        return super.copy(t), (this.instanceCount = t.instanceCount), this;
      }
      clone() {
        return new this.constructor().copy(this);
      }
      toJSON() {
        const t = super.toJSON(this);
        return (
          (t.instanceCount = this.instanceCount),
          (t.isInstancedBufferGeometry = !0),
          t
        );
      }
    }
    ju.prototype.isInstancedBufferGeometry = !0;
    let qu;
    (class extends xu {
      constructor(t) {
        super(t),
          "undefined" == typeof createImageBitmap &&
            console.warn(
              "THREE.ImageBitmapLoader: createImageBitmap() not supported."
            ),
          "undefined" == typeof fetch &&
            console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
          (this.options = { premultiplyAlpha: "none" });
      }
      setOptions(t) {
        return (this.options = t), this;
      }
      load(t, e, n, i) {
        void 0 === t && (t = ""),
          void 0 !== this.path && (t = this.path + t),
          (t = this.manager.resolveURL(t));
        const r = this,
          s = gu.get(t);
        if (void 0 !== s)
          return (
            r.manager.itemStart(t),
            setTimeout(function () {
              e && e(s), r.manager.itemEnd(t);
            }, 0),
            s
          );
        const o = {};
        (o.credentials =
          "anonymous" === this.crossOrigin ? "same-origin" : "include"),
          (o.headers = this.requestHeader),
          fetch(t, o)
            .then(function (t) {
              return t.blob();
            })
            .then(function (t) {
              return createImageBitmap(
                t,
                Object.assign(r.options, { colorSpaceConversion: "none" })
              );
            })
            .then(function (n) {
              gu.add(t, n), e && e(n), r.manager.itemEnd(t);
            })
            .catch(function (e) {
              i && i(e), r.manager.itemError(t), r.manager.itemEnd(t);
            }),
          r.manager.itemStart(t);
      }
    }.prototype.isImageBitmapLoader = !0);
    const $u = {
      getContext: function () {
        return (
          void 0 === qu &&
            (qu = new (window.AudioContext || window.webkitAudioContext)()),
          qu
        );
      },
      setContext: function (t) {
        qu = t;
      },
    };
    class Xu extends xu {
      constructor(t) {
        super(t);
      }
      load(t, e, n, i) {
        const r = this,
          s = new _u(this.manager);
        s.setResponseType("arraybuffer"),
          s.setPath(this.path),
          s.setRequestHeader(this.requestHeader),
          s.setWithCredentials(this.withCredentials),
          s.load(
            t,
            function (n) {
              try {
                const t = n.slice(0);
                $u.getContext().decodeAudioData(t, function (t) {
                  e(t);
                });
              } catch (e) {
                i ? i(e) : console.error(e), r.manager.itemError(t);
              }
            },
            n,
            i
          );
      }
    }
    (class extends Wu {
      constructor(t, e, n = 1) {
        super(void 0, n);
        const i = new qi().set(t),
          r = new qi().set(e),
          s = new Mn(i.r, i.g, i.b),
          o = new Mn(r.r, r.g, r.b),
          a = Math.sqrt(Math.PI),
          l = a * Math.sqrt(0.75);
        this.sh.coefficients[0].copy(s).add(o).multiplyScalar(a),
          this.sh.coefficients[1].copy(s).sub(o).multiplyScalar(l);
      }
    }.prototype.isHemisphereLightProbe = !0);
    (class extends Wu {
      constructor(t, e = 1) {
        super(void 0, e);
        const n = new qi().set(t);
        this.sh.coefficients[0]
          .set(n.r, n.g, n.b)
          .multiplyScalar(2 * Math.sqrt(Math.PI));
      }
    }.prototype.isAmbientLightProbe = !0);
    class Ju extends Ei {
      constructor(t) {
        super(),
          (this.type = "Audio"),
          (this.listener = t),
          (this.context = t.context),
          (this.gain = this.context.createGain()),
          this.gain.connect(t.getInput()),
          (this.autoplay = !1),
          (this.buffer = null),
          (this.detune = 0),
          (this.loop = !1),
          (this.loopStart = 0),
          (this.loopEnd = 0),
          (this.offset = 0),
          (this.duration = void 0),
          (this.playbackRate = 1),
          (this.isPlaying = !1),
          (this.hasPlaybackControl = !0),
          (this.source = null),
          (this.sourceType = "empty"),
          (this._startedAt = 0),
          (this._progress = 0),
          (this._connected = !1),
          (this.filters = []);
      }
      getOutput() {
        return this.gain;
      }
      setNodeSource(t) {
        return (
          (this.hasPlaybackControl = !1),
          (this.sourceType = "audioNode"),
          (this.source = t),
          this.connect(),
          this
        );
      }
      setMediaElementSource(t) {
        return (
          (this.hasPlaybackControl = !1),
          (this.sourceType = "mediaNode"),
          (this.source = this.context.createMediaElementSource(t)),
          this.connect(),
          this
        );
      }
      setMediaStreamSource(t) {
        return (
          (this.hasPlaybackControl = !1),
          (this.sourceType = "mediaStreamNode"),
          (this.source = this.context.createMediaStreamSource(t)),
          this.connect(),
          this
        );
      }
      setBuffer(t) {
        return (
          (this.buffer = t),
          (this.sourceType = "buffer"),
          this.autoplay && this.play(),
          this
        );
      }
      play(t = 0) {
        if (!0 === this.isPlaying)
          return void console.warn("THREE.Audio: Audio is already playing.");
        if (!1 === this.hasPlaybackControl)
          return void console.warn(
            "THREE.Audio: this Audio has no playback control."
          );
        this._startedAt = this.context.currentTime + t;
        const e = this.context.createBufferSource();
        return (
          (e.buffer = this.buffer),
          (e.loop = this.loop),
          (e.loopStart = this.loopStart),
          (e.loopEnd = this.loopEnd),
          (e.onended = this.onEnded.bind(this)),
          e.start(this._startedAt, this._progress + this.offset, this.duration),
          (this.isPlaying = !0),
          (this.source = e),
          this.setDetune(this.detune),
          this.setPlaybackRate(this.playbackRate),
          this.connect()
        );
      }
      pause() {
        if (!1 !== this.hasPlaybackControl)
          return (
            !0 === this.isPlaying &&
              ((this._progress +=
                Math.max(this.context.currentTime - this._startedAt, 0) *
                this.playbackRate),
              !0 === this.loop &&
                (this._progress =
                  this._progress % (this.duration || this.buffer.duration)),
              this.source.stop(),
              (this.source.onended = null),
              (this.isPlaying = !1)),
            this
          );
        console.warn("THREE.Audio: this Audio has no playback control.");
      }
      stop() {
        if (!1 !== this.hasPlaybackControl)
          return (
            (this._progress = 0),
            this.source.stop(),
            (this.source.onended = null),
            (this.isPlaying = !1),
            this
          );
        console.warn("THREE.Audio: this Audio has no playback control.");
      }
      connect() {
        if (this.filters.length > 0) {
          this.source.connect(this.filters[0]);
          for (let t = 1, e = this.filters.length; t < e; t++)
            this.filters[t - 1].connect(this.filters[t]);
          this.filters[this.filters.length - 1].connect(this.getOutput());
        } else this.source.connect(this.getOutput());
        return (this._connected = !0), this;
      }
      disconnect() {
        if (this.filters.length > 0) {
          this.source.disconnect(this.filters[0]);
          for (let t = 1, e = this.filters.length; t < e; t++)
            this.filters[t - 1].disconnect(this.filters[t]);
          this.filters[this.filters.length - 1].disconnect(this.getOutput());
        } else this.source.disconnect(this.getOutput());
        return (this._connected = !1), this;
      }
      getFilters() {
        return this.filters;
      }
      setFilters(t) {
        return (
          t || (t = []),
          !0 === this._connected
            ? (this.disconnect(), (this.filters = t.slice()), this.connect())
            : (this.filters = t.slice()),
          this
        );
      }
      setDetune(t) {
        if (((this.detune = t), void 0 !== this.source.detune))
          return (
            !0 === this.isPlaying &&
              this.source.detune.setTargetAtTime(
                this.detune,
                this.context.currentTime,
                0.01
              ),
            this
          );
      }
      getDetune() {
        return this.detune;
      }
      getFilter() {
        return this.getFilters()[0];
      }
      setFilter(t) {
        return this.setFilters(t ? [t] : []);
      }
      setPlaybackRate(t) {
        if (!1 !== this.hasPlaybackControl)
          return (
            (this.playbackRate = t),
            !0 === this.isPlaying &&
              this.source.playbackRate.setTargetAtTime(
                this.playbackRate,
                this.context.currentTime,
                0.01
              ),
            this
          );
        console.warn("THREE.Audio: this Audio has no playback control.");
      }
      getPlaybackRate() {
        return this.playbackRate;
      }
      onEnded() {
        this.isPlaying = !1;
      }
      getLoop() {
        return !1 === this.hasPlaybackControl
          ? (console.warn("THREE.Audio: this Audio has no playback control."),
            !1)
          : this.loop;
      }
      setLoop(t) {
        if (!1 !== this.hasPlaybackControl)
          return (
            (this.loop = t),
            !0 === this.isPlaying && (this.source.loop = this.loop),
            this
          );
        console.warn("THREE.Audio: this Audio has no playback control.");
      }
      setLoopStart(t) {
        return (this.loopStart = t), this;
      }
      setLoopEnd(t) {
        return (this.loopEnd = t), this;
      }
      getVolume() {
        return this.gain.gain.value;
      }
      setVolume(t) {
        return (
          this.gain.gain.setTargetAtTime(t, this.context.currentTime, 0.01),
          this
        );
      }
    }
    class Yu {
      constructor(t, e, n) {
        let i, r, s;
        switch (((this.binding = t), (this.valueSize = n), e)) {
          case "quaternion":
            (i = this._slerp),
              (r = this._slerpAdditive),
              (s = this._setAdditiveIdentityQuaternion),
              (this.buffer = new Float64Array(6 * n)),
              (this._workIndex = 5);
            break;
          case "string":
          case "bool":
            (i = this._select),
              (r = this._select),
              (s = this._setAdditiveIdentityOther),
              (this.buffer = new Array(5 * n));
            break;
          default:
            (i = this._lerp),
              (r = this._lerpAdditive),
              (s = this._setAdditiveIdentityNumeric),
              (this.buffer = new Float64Array(5 * n));
        }
        (this._mixBufferRegion = i),
          (this._mixBufferRegionAdditive = r),
          (this._setIdentity = s),
          (this._origIndex = 3),
          (this._addIndex = 4),
          (this.cumulativeWeight = 0),
          (this.cumulativeWeightAdditive = 0),
          (this.useCount = 0),
          (this.referenceCount = 0);
      }
      accumulate(t, e) {
        const n = this.buffer,
          i = this.valueSize,
          r = t * i + i;
        let s = this.cumulativeWeight;
        if (0 === s) {
          for (let t = 0; t !== i; ++t) n[r + t] = n[t];
          s = e;
        } else {
          s += e;
          const t = e / s;
          this._mixBufferRegion(n, r, 0, t, i);
        }
        this.cumulativeWeight = s;
      }
      accumulateAdditive(t) {
        const e = this.buffer,
          n = this.valueSize,
          i = n * this._addIndex;
        0 === this.cumulativeWeightAdditive && this._setIdentity(),
          this._mixBufferRegionAdditive(e, i, 0, t, n),
          (this.cumulativeWeightAdditive += t);
      }
      apply(t) {
        const e = this.valueSize,
          n = this.buffer,
          i = t * e + e,
          r = this.cumulativeWeight,
          s = this.cumulativeWeightAdditive,
          o = this.binding;
        if (
          ((this.cumulativeWeight = 0),
          (this.cumulativeWeightAdditive = 0),
          r < 1)
        ) {
          const t = e * this._origIndex;
          this._mixBufferRegion(n, i, t, 1 - r, e);
        }
        s > 0 && this._mixBufferRegionAdditive(n, i, this._addIndex * e, 1, e);
        for (let t = e, r = e + e; t !== r; ++t)
          if (n[t] !== n[t + e]) {
            o.setValue(n, i);
            break;
          }
      }
      saveOriginalState() {
        const t = this.binding,
          e = this.buffer,
          n = this.valueSize,
          i = n * this._origIndex;
        t.getValue(e, i);
        for (let t = n, r = i; t !== r; ++t) e[t] = e[i + (t % n)];
        this._setIdentity(),
          (this.cumulativeWeight = 0),
          (this.cumulativeWeightAdditive = 0);
      }
      restoreOriginalState() {
        const t = 3 * this.valueSize;
        this.binding.setValue(this.buffer, t);
      }
      _setAdditiveIdentityNumeric() {
        const t = this._addIndex * this.valueSize,
          e = t + this.valueSize;
        for (let n = t; n < e; n++) this.buffer[n] = 0;
      }
      _setAdditiveIdentityQuaternion() {
        this._setAdditiveIdentityNumeric(),
          (this.buffer[this._addIndex * this.valueSize + 3] = 1);
      }
      _setAdditiveIdentityOther() {
        const t = this._origIndex * this.valueSize,
          e = this._addIndex * this.valueSize;
        for (let n = 0; n < this.valueSize; n++)
          this.buffer[e + n] = this.buffer[t + n];
      }
      _select(t, e, n, i, r) {
        if (i >= 0.5) for (let i = 0; i !== r; ++i) t[e + i] = t[n + i];
      }
      _slerp(t, e, n, i) {
        Sn.slerpFlat(t, e, t, e, t, n, i);
      }
      _slerpAdditive(t, e, n, i, r) {
        const s = this._workIndex * r;
        Sn.multiplyQuaternionsFlat(t, s, t, e, t, n),
          Sn.slerpFlat(t, e, t, e, t, s, i);
      }
      _lerp(t, e, n, i, r) {
        const s = 1 - i;
        for (let o = 0; o !== r; ++o) {
          const r = e + o;
          t[r] = t[r] * s + t[n + o] * i;
        }
      }
      _lerpAdditive(t, e, n, i, r) {
        for (let s = 0; s !== r; ++s) {
          const r = e + s;
          t[r] = t[r] + t[n + s] * i;
        }
      }
    }
    const Zu = new RegExp("[\\[\\]\\.:\\/]", "g"),
      Qu = "[^" + "\\[\\]\\.:\\/".replace("\\.", "") + "]",
      Ku = /((?:WC+[\/:])*)/.source.replace("WC", "[^\\[\\]\\.:\\/]"),
      th = /(WCOD+)?/.source.replace("WCOD", Qu),
      eh = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", "[^\\[\\]\\.:\\/]"),
      nh = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", "[^\\[\\]\\.:\\/]"),
      ih = new RegExp("^" + Ku + th + eh + nh + "$"),
      rh = ["material", "materials", "bones"];
    class sh {
      constructor(t, e, n) {
        (this.path = e),
          (this.parsedPath = n || sh.parseTrackName(e)),
          (this.node = sh.findNode(t, this.parsedPath.nodeName) || t),
          (this.rootNode = t),
          (this.getValue = this._getValue_unbound),
          (this.setValue = this._setValue_unbound);
      }
      static create(t, e, n) {
        return t && t.isAnimationObjectGroup
          ? new sh.Composite(t, e, n)
          : new sh(t, e, n);
      }
      static sanitizeNodeName(t) {
        return t.replace(/\s/g, "_").replace(Zu, "");
      }
      static parseTrackName(t) {
        const e = ih.exec(t);
        if (!e)
          throw new Error("PropertyBinding: Cannot parse trackName: " + t);
        const n = {
            nodeName: e[2],
            objectName: e[3],
            objectIndex: e[4],
            propertyName: e[5],
            propertyIndex: e[6],
          },
          i = n.nodeName && n.nodeName.lastIndexOf(".");
        if (void 0 !== i && -1 !== i) {
          const t = n.nodeName.substring(i + 1);
          -1 !== rh.indexOf(t) &&
            ((n.nodeName = n.nodeName.substring(0, i)), (n.objectName = t));
        }
        if (null === n.propertyName || 0 === n.propertyName.length)
          throw new Error(
            "PropertyBinding: can not parse propertyName from trackName: " + t
          );
        return n;
      }
      static findNode(t, e) {
        if (
          !e ||
          "" === e ||
          "." === e ||
          -1 === e ||
          e === t.name ||
          e === t.uuid
        )
          return t;
        if (t.skeleton) {
          const n = t.skeleton.getBoneByName(e);
          if (void 0 !== n) return n;
        }
        if (t.children) {
          const n = function (t) {
              for (let i = 0; i < t.length; i++) {
                const r = t[i];
                if (r.name === e || r.uuid === e) return r;
                const s = n(r.children);
                if (s) return s;
              }
              return null;
            },
            i = n(t.children);
          if (i) return i;
        }
        return null;
      }
      _getValue_unavailable() {}
      _setValue_unavailable() {}
      _getValue_direct(t, e) {
        t[e] = this.targetObject[this.propertyName];
      }
      _getValue_array(t, e) {
        const n = this.resolvedProperty;
        for (let i = 0, r = n.length; i !== r; ++i) t[e++] = n[i];
      }
      _getValue_arrayElement(t, e) {
        t[e] = this.resolvedProperty[this.propertyIndex];
      }
      _getValue_toArray(t, e) {
        this.resolvedProperty.toArray(t, e);
      }
      _setValue_direct(t, e) {
        this.targetObject[this.propertyName] = t[e];
      }
      _setValue_direct_setNeedsUpdate(t, e) {
        (this.targetObject[this.propertyName] = t[e]),
          (this.targetObject.needsUpdate = !0);
      }
      _setValue_direct_setMatrixWorldNeedsUpdate(t, e) {
        (this.targetObject[this.propertyName] = t[e]),
          (this.targetObject.matrixWorldNeedsUpdate = !0);
      }
      _setValue_array(t, e) {
        const n = this.resolvedProperty;
        for (let i = 0, r = n.length; i !== r; ++i) n[i] = t[e++];
      }
      _setValue_array_setNeedsUpdate(t, e) {
        const n = this.resolvedProperty;
        for (let i = 0, r = n.length; i !== r; ++i) n[i] = t[e++];
        this.targetObject.needsUpdate = !0;
      }
      _setValue_array_setMatrixWorldNeedsUpdate(t, e) {
        const n = this.resolvedProperty;
        for (let i = 0, r = n.length; i !== r; ++i) n[i] = t[e++];
        this.targetObject.matrixWorldNeedsUpdate = !0;
      }
      _setValue_arrayElement(t, e) {
        this.resolvedProperty[this.propertyIndex] = t[e];
      }
      _setValue_arrayElement_setNeedsUpdate(t, e) {
        (this.resolvedProperty[this.propertyIndex] = t[e]),
          (this.targetObject.needsUpdate = !0);
      }
      _setValue_arrayElement_setMatrixWorldNeedsUpdate(t, e) {
        (this.resolvedProperty[this.propertyIndex] = t[e]),
          (this.targetObject.matrixWorldNeedsUpdate = !0);
      }
      _setValue_fromArray(t, e) {
        this.resolvedProperty.fromArray(t, e);
      }
      _setValue_fromArray_setNeedsUpdate(t, e) {
        this.resolvedProperty.fromArray(t, e),
          (this.targetObject.needsUpdate = !0);
      }
      _setValue_fromArray_setMatrixWorldNeedsUpdate(t, e) {
        this.resolvedProperty.fromArray(t, e),
          (this.targetObject.matrixWorldNeedsUpdate = !0);
      }
      _getValue_unbound(t, e) {
        this.bind(), this.getValue(t, e);
      }
      _setValue_unbound(t, e) {
        this.bind(), this.setValue(t, e);
      }
      bind() {
        let t = this.node;
        const e = this.parsedPath,
          n = e.objectName,
          i = e.propertyName;
        let r = e.propertyIndex;
        if (
          (t ||
            ((t = sh.findNode(this.rootNode, e.nodeName) || this.rootNode),
            (this.node = t)),
          (this.getValue = this._getValue_unavailable),
          (this.setValue = this._setValue_unavailable),
          !t)
        )
          return void console.error(
            "THREE.PropertyBinding: Trying to update node for track: " +
              this.path +
              " but it wasn't found."
          );
        if (n) {
          let i = e.objectIndex;
          switch (n) {
            case "materials":
              if (!t.material)
                return void console.error(
                  "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
                  this
                );
              if (!t.material.materials)
                return void console.error(
                  "THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",
                  this
                );
              t = t.material.materials;
              break;
            case "bones":
              if (!t.skeleton)
                return void console.error(
                  "THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",
                  this
                );
              t = t.skeleton.bones;
              for (let e = 0; e < t.length; e++)
                if (t[e].name === i) {
                  i = e;
                  break;
                }
              break;
            default:
              if (void 0 === t[n])
                return void console.error(
                  "THREE.PropertyBinding: Can not bind to objectName of node undefined.",
                  this
                );
              t = t[n];
          }
          if (void 0 !== i) {
            if (void 0 === t[i])
              return void console.error(
                "THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",
                this,
                t
              );
            t = t[i];
          }
        }
        const s = t[i];
        if (void 0 === s) {
          const n = e.nodeName;
          return void console.error(
            "THREE.PropertyBinding: Trying to update property for track: " +
              n +
              "." +
              i +
              " but it wasn't found.",
            t
          );
        }
        let o = this.Versioning.None;
        (this.targetObject = t),
          void 0 !== t.needsUpdate
            ? (o = this.Versioning.NeedsUpdate)
            : void 0 !== t.matrixWorldNeedsUpdate &&
              (o = this.Versioning.MatrixWorldNeedsUpdate);
        let a = this.BindingType.Direct;
        if (void 0 !== r) {
          if ("morphTargetInfluences" === i) {
            if (!t.geometry)
              return void console.error(
                "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",
                this
              );
            if (!t.geometry.isBufferGeometry)
              return void console.error(
                "THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.",
                this
              );
            if (!t.geometry.morphAttributes)
              return void console.error(
                "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",
                this
              );
            void 0 !== t.morphTargetDictionary[r] &&
              (r = t.morphTargetDictionary[r]);
          }
          (a = this.BindingType.ArrayElement),
            (this.resolvedProperty = s),
            (this.propertyIndex = r);
        } else
          void 0 !== s.fromArray && void 0 !== s.toArray
            ? ((a = this.BindingType.HasFromToArray),
              (this.resolvedProperty = s))
            : Array.isArray(s)
            ? ((a = this.BindingType.EntireArray), (this.resolvedProperty = s))
            : (this.propertyName = i);
        (this.getValue = this.GetterByBindingType[a]),
          (this.setValue = this.SetterByBindingTypeAndVersioning[a][o]);
      }
      unbind() {
        (this.node = null),
          (this.getValue = this._getValue_unbound),
          (this.setValue = this._setValue_unbound);
      }
    }
    (sh.Composite = class {
      constructor(t, e, n) {
        const i = n || sh.parseTrackName(e);
        (this._targetGroup = t), (this._bindings = t.subscribe_(e, i));
      }
      getValue(t, e) {
        this.bind();
        const n = this._targetGroup.nCachedObjects_,
          i = this._bindings[n];
        void 0 !== i && i.getValue(t, e);
      }
      setValue(t, e) {
        const n = this._bindings;
        for (
          let i = this._targetGroup.nCachedObjects_, r = n.length;
          i !== r;
          ++i
        )
          n[i].setValue(t, e);
      }
      bind() {
        const t = this._bindings;
        for (
          let e = this._targetGroup.nCachedObjects_, n = t.length;
          e !== n;
          ++e
        )
          t[e].bind();
      }
      unbind() {
        const t = this._bindings;
        for (
          let e = this._targetGroup.nCachedObjects_, n = t.length;
          e !== n;
          ++e
        )
          t[e].unbind();
      }
    }),
      (sh.prototype.BindingType = {
        Direct: 0,
        EntireArray: 1,
        ArrayElement: 2,
        HasFromToArray: 3,
      }),
      (sh.prototype.Versioning = {
        None: 0,
        NeedsUpdate: 1,
        MatrixWorldNeedsUpdate: 2,
      }),
      (sh.prototype.GetterByBindingType = [
        sh.prototype._getValue_direct,
        sh.prototype._getValue_array,
        sh.prototype._getValue_arrayElement,
        sh.prototype._getValue_toArray,
      ]),
      (sh.prototype.SetterByBindingTypeAndVersioning = [
        [
          sh.prototype._setValue_direct,
          sh.prototype._setValue_direct_setNeedsUpdate,
          sh.prototype._setValue_direct_setMatrixWorldNeedsUpdate,
        ],
        [
          sh.prototype._setValue_array,
          sh.prototype._setValue_array_setNeedsUpdate,
          sh.prototype._setValue_array_setMatrixWorldNeedsUpdate,
        ],
        [
          sh.prototype._setValue_arrayElement,
          sh.prototype._setValue_arrayElement_setNeedsUpdate,
          sh.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate,
        ],
        [
          sh.prototype._setValue_fromArray,
          sh.prototype._setValue_fromArray_setNeedsUpdate,
          sh.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate,
        ],
      ]);
    (class {
      constructor() {
        (this.uuid = sn()),
          (this._objects = Array.prototype.slice.call(arguments)),
          (this.nCachedObjects_ = 0);
        const t = {};
        this._indicesByUUID = t;
        for (let e = 0, n = arguments.length; e !== n; ++e)
          t[arguments[e].uuid] = e;
        (this._paths = []),
          (this._parsedPaths = []),
          (this._bindings = []),
          (this._bindingsIndicesByPath = {});
        const e = this;
        this.stats = {
          objects: {
            get total() {
              return e._objects.length;
            },
            get inUse() {
              return this.total - e.nCachedObjects_;
            },
          },
          get bindingsPerObject() {
            return e._bindings.length;
          },
        };
      }
      add() {
        const t = this._objects,
          e = this._indicesByUUID,
          n = this._paths,
          i = this._parsedPaths,
          r = this._bindings,
          s = r.length;
        let o = void 0,
          a = t.length,
          l = this.nCachedObjects_;
        for (let c = 0, u = arguments.length; c !== u; ++c) {
          const u = arguments[c],
            h = u.uuid;
          let d = e[h];
          if (void 0 === d) {
            (d = a++), (e[h] = d), t.push(u);
            for (let t = 0, e = s; t !== e; ++t)
              r[t].push(new sh(u, n[t], i[t]));
          } else if (d < l) {
            o = t[d];
            const a = --l,
              c = t[a];
            (e[c.uuid] = d), (t[d] = c), (e[h] = a), (t[a] = u);
            for (let t = 0, e = s; t !== e; ++t) {
              const e = r[t],
                s = e[a];
              let o = e[d];
              (e[d] = s),
                void 0 === o && (o = new sh(u, n[t], i[t])),
                (e[a] = o);
            }
          } else
            t[d] !== o &&
              console.error(
                "THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes."
              );
        }
        this.nCachedObjects_ = l;
      }
      remove() {
        const t = this._objects,
          e = this._indicesByUUID,
          n = this._bindings,
          i = n.length;
        let r = this.nCachedObjects_;
        for (let s = 0, o = arguments.length; s !== o; ++s) {
          const o = arguments[s],
            a = o.uuid,
            l = e[a];
          if (void 0 !== l && l >= r) {
            const s = r++,
              c = t[s];
            (e[c.uuid] = l), (t[l] = c), (e[a] = s), (t[s] = o);
            for (let t = 0, e = i; t !== e; ++t) {
              const e = n[t],
                i = e[s],
                r = e[l];
              (e[l] = i), (e[s] = r);
            }
          }
        }
        this.nCachedObjects_ = r;
      }
      uncache() {
        const t = this._objects,
          e = this._indicesByUUID,
          n = this._bindings,
          i = n.length;
        let r = this.nCachedObjects_,
          s = t.length;
        for (let o = 0, a = arguments.length; o !== a; ++o) {
          const a = arguments[o].uuid,
            l = e[a];
          if (void 0 !== l)
            if ((delete e[a], l < r)) {
              const o = --r,
                a = t[o],
                c = --s,
                u = t[c];
              (e[a.uuid] = l), (t[l] = a), (e[u.uuid] = o), (t[o] = u), t.pop();
              for (let t = 0, e = i; t !== e; ++t) {
                const e = n[t],
                  i = e[o],
                  r = e[c];
                (e[l] = i), (e[o] = r), e.pop();
              }
            } else {
              const r = --s,
                o = t[r];
              r > 0 && (e[o.uuid] = l), (t[l] = o), t.pop();
              for (let t = 0, e = i; t !== e; ++t) {
                const e = n[t];
                (e[l] = e[r]), e.pop();
              }
            }
        }
        this.nCachedObjects_ = r;
      }
      subscribe_(t, e) {
        const n = this._bindingsIndicesByPath;
        let i = n[t];
        const r = this._bindings;
        if (void 0 !== i) return r[i];
        const s = this._paths,
          o = this._parsedPaths,
          a = this._objects,
          l = a.length,
          c = this.nCachedObjects_,
          u = new Array(l);
        (i = r.length), (n[t] = i), s.push(t), o.push(e), r.push(u);
        for (let n = c, i = a.length; n !== i; ++n) {
          const i = a[n];
          u[n] = new sh(i, t, e);
        }
        return u;
      }
      unsubscribe_(t) {
        const e = this._bindingsIndicesByPath,
          n = e[t];
        if (void 0 !== n) {
          const i = this._paths,
            r = this._parsedPaths,
            s = this._bindings,
            o = s.length - 1,
            a = s[o];
          (e[t[o]] = n),
            (s[n] = a),
            s.pop(),
            (r[n] = r[o]),
            r.pop(),
            (i[n] = i[o]),
            i.pop();
        }
      }
    }.prototype.isAnimationObjectGroup = !0);
    class oh {
      constructor(t, e, n = null, i = e.blendMode) {
        (this._mixer = t),
          (this._clip = e),
          (this._localRoot = n),
          (this.blendMode = i);
        const r = e.tracks,
          s = r.length,
          o = new Array(s),
          a = { endingStart: He, endingEnd: He };
        for (let t = 0; t !== s; ++t) {
          const e = r[t].createInterpolant(null);
          (o[t] = e), (e.settings = a);
        }
        (this._interpolantSettings = a),
          (this._interpolants = o),
          (this._propertyBindings = new Array(s)),
          (this._cacheIndex = null),
          (this._byClipCacheIndex = null),
          (this._timeScaleInterpolant = null),
          (this._weightInterpolant = null),
          (this.loop = ke),
          (this._loopCount = -1),
          (this._startTime = null),
          (this.time = 0),
          (this.timeScale = 1),
          (this._effectiveTimeScale = 1),
          (this.weight = 1),
          (this._effectiveWeight = 1),
          (this.repetitions = 1 / 0),
          (this.paused = !1),
          (this.enabled = !0),
          (this.clampWhenFinished = !1),
          (this.zeroSlopeAtStart = !0),
          (this.zeroSlopeAtEnd = !0);
      }
      play() {
        return this._mixer._activateAction(this), this;
      }
      stop() {
        return this._mixer._deactivateAction(this), this.reset();
      }
      reset() {
        return (
          (this.paused = !1),
          (this.enabled = !0),
          (this.time = 0),
          (this._loopCount = -1),
          (this._startTime = null),
          this.stopFading().stopWarping()
        );
      }
      isRunning() {
        return (
          this.enabled &&
          !this.paused &&
          0 !== this.timeScale &&
          null === this._startTime &&
          this._mixer._isActiveAction(this)
        );
      }
      isScheduled() {
        return this._mixer._isActiveAction(this);
      }
      startAt(t) {
        return (this._startTime = t), this;
      }
      setLoop(t, e) {
        return (this.loop = t), (this.repetitions = e), this;
      }
      setEffectiveWeight(t) {
        return (
          (this.weight = t),
          (this._effectiveWeight = this.enabled ? t : 0),
          this.stopFading()
        );
      }
      getEffectiveWeight() {
        return this._effectiveWeight;
      }
      fadeIn(t) {
        return this._scheduleFading(t, 0, 1);
      }
      fadeOut(t) {
        return this._scheduleFading(t, 1, 0);
      }
      crossFadeFrom(t, e, n) {
        if ((t.fadeOut(e), this.fadeIn(e), n)) {
          const n = this._clip.duration,
            i = t._clip.duration,
            r = i / n,
            s = n / i;
          t.warp(1, r, e), this.warp(s, 1, e);
        }
        return this;
      }
      crossFadeTo(t, e, n) {
        return t.crossFadeFrom(this, e, n);
      }
      stopFading() {
        const t = this._weightInterpolant;
        return (
          null !== t &&
            ((this._weightInterpolant = null),
            this._mixer._takeBackControlInterpolant(t)),
          this
        );
      }
      setEffectiveTimeScale(t) {
        return (
          (this.timeScale = t),
          (this._effectiveTimeScale = this.paused ? 0 : t),
          this.stopWarping()
        );
      }
      getEffectiveTimeScale() {
        return this._effectiveTimeScale;
      }
      setDuration(t) {
        return (this.timeScale = this._clip.duration / t), this.stopWarping();
      }
      syncWith(t) {
        return (
          (this.time = t.time),
          (this.timeScale = t.timeScale),
          this.stopWarping()
        );
      }
      halt(t) {
        return this.warp(this._effectiveTimeScale, 0, t);
      }
      warp(t, e, n) {
        const i = this._mixer,
          r = i.time,
          s = this.timeScale;
        let o = this._timeScaleInterpolant;
        null === o &&
          ((o = i._lendControlInterpolant()), (this._timeScaleInterpolant = o));
        const a = o.parameterPositions,
          l = o.sampleValues;
        return (a[0] = r), (a[1] = r + n), (l[0] = t / s), (l[1] = e / s), this;
      }
      stopWarping() {
        const t = this._timeScaleInterpolant;
        return (
          null !== t &&
            ((this._timeScaleInterpolant = null),
            this._mixer._takeBackControlInterpolant(t)),
          this
        );
      }
      getMixer() {
        return this._mixer;
      }
      getClip() {
        return this._clip;
      }
      getRoot() {
        return this._localRoot || this._mixer._root;
      }
      _update(t, e, n, i) {
        if (!this.enabled) return void this._updateWeight(t);
        const r = this._startTime;
        if (null !== r) {
          const i = (t - r) * n;
          if (i < 0 || 0 === n) return;
          (this._startTime = null), (e = n * i);
        }
        e *= this._updateTimeScale(t);
        const s = this._updateTime(e),
          o = this._updateWeight(t);
        if (o > 0) {
          const t = this._interpolants,
            e = this._propertyBindings;
          switch (this.blendMode) {
            case Ve:
              for (let n = 0, i = t.length; n !== i; ++n)
                t[n].evaluate(s), e[n].accumulateAdditive(o);
              break;
            case Fe:
            default:
              for (let n = 0, r = t.length; n !== r; ++n)
                t[n].evaluate(s), e[n].accumulate(i, o);
          }
        }
      }
      _updateWeight(t) {
        let e = 0;
        if (this.enabled) {
          e = this.weight;
          const n = this._weightInterpolant;
          if (null !== n) {
            const i = n.evaluate(t)[0];
            (e *= i),
              t > n.parameterPositions[1] &&
                (this.stopFading(), 0 === i && (this.enabled = !1));
          }
        }
        return (this._effectiveWeight = e), e;
      }
      _updateTimeScale(t) {
        let e = 0;
        if (!this.paused) {
          e = this.timeScale;
          const n = this._timeScaleInterpolant;
          if (null !== n) {
            (e *= n.evaluate(t)[0]),
              t > n.parameterPositions[1] &&
                (this.stopWarping(),
                0 === e ? (this.paused = !0) : (this.timeScale = e));
          }
        }
        return (this._effectiveTimeScale = e), e;
      }
      _updateTime(t) {
        const e = this._clip.duration,
          n = this.loop;
        let i = this.time + t,
          r = this._loopCount;
        const s = n === Ie;
        if (0 === t) return -1 === r ? i : s && 1 == (1 & r) ? e - i : i;
        if (n === De) {
          -1 === r && ((this._loopCount = 0), this._setEndings(!0, !0, !1));
          t: {
            if (i >= e) i = e;
            else {
              if (!(i < 0)) {
                this.time = i;
                break t;
              }
              i = 0;
            }
            this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
              (this.time = i),
              this._mixer.dispatchEvent({
                type: "finished",
                action: this,
                direction: t < 0 ? -1 : 1,
              });
          }
        } else {
          if (
            (-1 === r &&
              (t >= 0
                ? ((r = 0), this._setEndings(!0, 0 === this.repetitions, s))
                : this._setEndings(0 === this.repetitions, !0, s)),
            i >= e || i < 0)
          ) {
            const n = Math.floor(i / e);
            (i -= e * n), (r += Math.abs(n));
            const o = this.repetitions - r;
            if (o <= 0)
              this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
                (i = t > 0 ? e : 0),
                (this.time = i),
                this._mixer.dispatchEvent({
                  type: "finished",
                  action: this,
                  direction: t > 0 ? 1 : -1,
                });
            else {
              if (1 === o) {
                const e = t < 0;
                this._setEndings(e, !e, s);
              } else this._setEndings(!1, !1, s);
              (this._loopCount = r),
                (this.time = i),
                this._mixer.dispatchEvent({
                  type: "loop",
                  action: this,
                  loopDelta: n,
                });
            }
          } else this.time = i;
          if (s && 1 == (1 & r)) return e - i;
        }
        return i;
      }
      _setEndings(t, e, n) {
        const i = this._interpolantSettings;
        n
          ? ((i.endingStart = Be), (i.endingEnd = Be))
          : ((i.endingStart = t ? (this.zeroSlopeAtStart ? Be : He) : Ue),
            (i.endingEnd = e ? (this.zeroSlopeAtEnd ? Be : He) : Ue));
      }
      _scheduleFading(t, e, n) {
        const i = this._mixer,
          r = i.time;
        let s = this._weightInterpolant;
        null === s &&
          ((s = i._lendControlInterpolant()), (this._weightInterpolant = s));
        const o = s.parameterPositions,
          a = s.sampleValues;
        return (o[0] = r), (a[0] = e), (o[1] = r + t), (a[1] = n), this;
      }
    }
    (class extends tn {
      constructor(t) {
        super(),
          (this._root = t),
          this._initMemoryManager(),
          (this._accuIndex = 0),
          (this.time = 0),
          (this.timeScale = 1);
      }
      _bindAction(t, e) {
        const n = t._localRoot || this._root,
          i = t._clip.tracks,
          r = i.length,
          s = t._propertyBindings,
          o = t._interpolants,
          a = n.uuid,
          l = this._bindingsByRootAndName;
        let c = l[a];
        void 0 === c && ((c = {}), (l[a] = c));
        for (let t = 0; t !== r; ++t) {
          const r = i[t],
            l = r.name;
          let u = c[l];
          if (void 0 !== u) s[t] = u;
          else {
            if (((u = s[t]), void 0 !== u)) {
              null === u._cacheIndex &&
                (++u.referenceCount, this._addInactiveBinding(u, a, l));
              continue;
            }
            const i = e && e._propertyBindings[t].binding.parsedPath;
            (u = new Yu(sh.create(n, l, i), r.ValueTypeName, r.getValueSize())),
              ++u.referenceCount,
              this._addInactiveBinding(u, a, l),
              (s[t] = u);
          }
          o[t].resultBuffer = u.buffer;
        }
      }
      _activateAction(t) {
        if (!this._isActiveAction(t)) {
          if (null === t._cacheIndex) {
            const e = (t._localRoot || this._root).uuid,
              n = t._clip.uuid,
              i = this._actionsByClip[n];
            this._bindAction(t, i && i.knownActions[0]),
              this._addInactiveAction(t, n, e);
          }
          const e = t._propertyBindings;
          for (let t = 0, n = e.length; t !== n; ++t) {
            const n = e[t];
            0 == n.useCount++ && (this._lendBinding(n), n.saveOriginalState());
          }
          this._lendAction(t);
        }
      }
      _deactivateAction(t) {
        if (this._isActiveAction(t)) {
          const e = t._propertyBindings;
          for (let t = 0, n = e.length; t !== n; ++t) {
            const n = e[t];
            0 == --n.useCount &&
              (n.restoreOriginalState(), this._takeBackBinding(n));
          }
          this._takeBackAction(t);
        }
      }
      _initMemoryManager() {
        (this._actions = []),
          (this._nActiveActions = 0),
          (this._actionsByClip = {}),
          (this._bindings = []),
          (this._nActiveBindings = 0),
          (this._bindingsByRootAndName = {}),
          (this._controlInterpolants = []),
          (this._nActiveControlInterpolants = 0);
        const t = this;
        this.stats = {
          actions: {
            get total() {
              return t._actions.length;
            },
            get inUse() {
              return t._nActiveActions;
            },
          },
          bindings: {
            get total() {
              return t._bindings.length;
            },
            get inUse() {
              return t._nActiveBindings;
            },
          },
          controlInterpolants: {
            get total() {
              return t._controlInterpolants.length;
            },
            get inUse() {
              return t._nActiveControlInterpolants;
            },
          },
        };
      }
      _isActiveAction(t) {
        const e = t._cacheIndex;
        return null !== e && e < this._nActiveActions;
      }
      _addInactiveAction(t, e, n) {
        const i = this._actions,
          r = this._actionsByClip;
        let s = r[e];
        if (void 0 === s)
          (s = { knownActions: [t], actionByRoot: {} }),
            (t._byClipCacheIndex = 0),
            (r[e] = s);
        else {
          const e = s.knownActions;
          (t._byClipCacheIndex = e.length), e.push(t);
        }
        (t._cacheIndex = i.length), i.push(t), (s.actionByRoot[n] = t);
      }
      _removeInactiveAction(t) {
        const e = this._actions,
          n = e[e.length - 1],
          i = t._cacheIndex;
        (n._cacheIndex = i), (e[i] = n), e.pop(), (t._cacheIndex = null);
        const r = t._clip.uuid,
          s = this._actionsByClip,
          o = s[r],
          a = o.knownActions,
          l = a[a.length - 1],
          c = t._byClipCacheIndex;
        (l._byClipCacheIndex = c),
          (a[c] = l),
          a.pop(),
          (t._byClipCacheIndex = null),
          delete o.actionByRoot[(t._localRoot || this._root).uuid],
          0 === a.length && delete s[r],
          this._removeInactiveBindingsForAction(t);
      }
      _removeInactiveBindingsForAction(t) {
        const e = t._propertyBindings;
        for (let t = 0, n = e.length; t !== n; ++t) {
          const n = e[t];
          0 == --n.referenceCount && this._removeInactiveBinding(n);
        }
      }
      _lendAction(t) {
        const e = this._actions,
          n = t._cacheIndex,
          i = this._nActiveActions++,
          r = e[i];
        (t._cacheIndex = i), (e[i] = t), (r._cacheIndex = n), (e[n] = r);
      }
      _takeBackAction(t) {
        const e = this._actions,
          n = t._cacheIndex,
          i = --this._nActiveActions,
          r = e[i];
        (t._cacheIndex = i), (e[i] = t), (r._cacheIndex = n), (e[n] = r);
      }
      _addInactiveBinding(t, e, n) {
        const i = this._bindingsByRootAndName,
          r = this._bindings;
        let s = i[e];
        void 0 === s && ((s = {}), (i[e] = s)),
          (s[n] = t),
          (t._cacheIndex = r.length),
          r.push(t);
      }
      _removeInactiveBinding(t) {
        const e = this._bindings,
          n = t.binding,
          i = n.rootNode.uuid,
          r = n.path,
          s = this._bindingsByRootAndName,
          o = s[i],
          a = e[e.length - 1],
          l = t._cacheIndex;
        (a._cacheIndex = l),
          (e[l] = a),
          e.pop(),
          delete o[r],
          0 === Object.keys(o).length && delete s[i];
      }
      _lendBinding(t) {
        const e = this._bindings,
          n = t._cacheIndex,
          i = this._nActiveBindings++,
          r = e[i];
        (t._cacheIndex = i), (e[i] = t), (r._cacheIndex = n), (e[n] = r);
      }
      _takeBackBinding(t) {
        const e = this._bindings,
          n = t._cacheIndex,
          i = --this._nActiveBindings,
          r = e[i];
        (t._cacheIndex = i), (e[i] = t), (r._cacheIndex = n), (e[n] = r);
      }
      _lendControlInterpolant() {
        const t = this._controlInterpolants,
          e = this._nActiveControlInterpolants++;
        let n = t[e];
        return (
          void 0 === n &&
            ((n = new ru(
              new Float32Array(2),
              new Float32Array(2),
              1,
              this._controlInterpolantsResultBuffer
            )),
            (n.__cacheIndex = e),
            (t[e] = n)),
          n
        );
      }
      _takeBackControlInterpolant(t) {
        const e = this._controlInterpolants,
          n = t.__cacheIndex,
          i = --this._nActiveControlInterpolants,
          r = e[i];
        (t.__cacheIndex = i), (e[i] = t), (r.__cacheIndex = n), (e[n] = r);
      }
      clipAction(t, e, n) {
        const i = e || this._root,
          r = i.uuid;
        let s = "string" == typeof t ? fu.findByName(i, t) : t;
        const o = null !== s ? s.uuid : t,
          a = this._actionsByClip[o];
        let l = null;
        if (
          (void 0 === n && (n = null !== s ? s.blendMode : Fe), void 0 !== a)
        ) {
          const t = a.actionByRoot[r];
          if (void 0 !== t && t.blendMode === n) return t;
          (l = a.knownActions[0]), null === s && (s = l._clip);
        }
        if (null === s) return null;
        const c = new oh(this, s, e, n);
        return this._bindAction(c, l), this._addInactiveAction(c, o, r), c;
      }
      existingAction(t, e) {
        const n = e || this._root,
          i = n.uuid,
          r = "string" == typeof t ? fu.findByName(n, t) : t,
          s = r ? r.uuid : t,
          o = this._actionsByClip[s];
        return (void 0 !== o && o.actionByRoot[i]) || null;
      }
      stopAllAction() {
        const t = this._actions;
        for (let e = this._nActiveActions - 1; e >= 0; --e) t[e].stop();
        return this;
      }
      update(t) {
        t *= this.timeScale;
        const e = this._actions,
          n = this._nActiveActions,
          i = (this.time += t),
          r = Math.sign(t),
          s = (this._accuIndex ^= 1);
        for (let o = 0; o !== n; ++o) {
          e[o]._update(i, t, r, s);
        }
        const o = this._bindings,
          a = this._nActiveBindings;
        for (let t = 0; t !== a; ++t) o[t].apply(s);
        return this;
      }
      setTime(t) {
        this.time = 0;
        for (let t = 0; t < this._actions.length; t++)
          this._actions[t].time = 0;
        return this.update(t);
      }
      getRoot() {
        return this._root;
      }
      uncacheClip(t) {
        const e = this._actions,
          n = t.uuid,
          i = this._actionsByClip,
          r = i[n];
        if (void 0 !== r) {
          const t = r.knownActions;
          for (let n = 0, i = t.length; n !== i; ++n) {
            const i = t[n];
            this._deactivateAction(i);
            const r = i._cacheIndex,
              s = e[e.length - 1];
            (i._cacheIndex = null),
              (i._byClipCacheIndex = null),
              (s._cacheIndex = r),
              (e[r] = s),
              e.pop(),
              this._removeInactiveBindingsForAction(i);
          }
          delete i[n];
        }
      }
      uncacheRoot(t) {
        const e = t.uuid,
          n = this._actionsByClip;
        for (const t in n) {
          const i = n[t].actionByRoot[e];
          void 0 !== i &&
            (this._deactivateAction(i), this._removeInactiveAction(i));
        }
        const i = this._bindingsByRootAndName[e];
        if (void 0 !== i)
          for (const t in i) {
            const e = i[t];
            e.restoreOriginalState(), this._removeInactiveBinding(e);
          }
      }
      uncacheAction(t, e) {
        const n = this.existingAction(t, e);
        null !== n &&
          (this._deactivateAction(n), this._removeInactiveAction(n));
      }
    }.prototype._controlInterpolantsResultBuffer = new Float32Array(1));
    class ah {
      constructor(t) {
        "string" == typeof t &&
          (console.warn("THREE.Uniform: Type parameter is no longer needed."),
          (t = arguments[1])),
          (this.value = t);
      }
      clone() {
        return new ah(
          void 0 === this.value.clone ? this.value : this.value.clone()
        );
      }
    }
    (class extends Ja {
      constructor(t, e, n = 1) {
        super(t, e), (this.meshPerAttribute = n);
      }
      copy(t) {
        return (
          super.copy(t), (this.meshPerAttribute = t.meshPerAttribute), this
        );
      }
      clone(t) {
        const e = super.clone(t);
        return (e.meshPerAttribute = this.meshPerAttribute), e;
      }
      toJSON(t) {
        const e = super.toJSON(t);
        return (
          (e.isInstancedInterleavedBuffer = !0),
          (e.meshPerAttribute = this.meshPerAttribute),
          e
        );
      }
    }.prototype.isInstancedInterleavedBuffer = !0);
    (class {
      constructor(t, e, n, i, r) {
        (this.buffer = t),
          (this.type = e),
          (this.itemSize = n),
          (this.elementSize = i),
          (this.count = r),
          (this.version = 0);
      }
      set needsUpdate(t) {
        !0 === t && this.version++;
      }
      setBuffer(t) {
        return (this.buffer = t), this;
      }
      setType(t, e) {
        return (this.type = t), (this.elementSize = e), this;
      }
      setItemSize(t) {
        return (this.itemSize = t), this;
      }
      setCount(t) {
        return (this.count = t), this;
      }
    }.prototype.isGLBufferAttribute = !0);
    const lh = new hn();
    class ch {
      constructor(t = new hn(1 / 0, 1 / 0), e = new hn(-1 / 0, -1 / 0)) {
        (this.min = t), (this.max = e);
      }
      set(t, e) {
        return this.min.copy(t), this.max.copy(e), this;
      }
      setFromPoints(t) {
        this.makeEmpty();
        for (let e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]);
        return this;
      }
      setFromCenterAndSize(t, e) {
        const n = lh.copy(e).multiplyScalar(0.5);
        return this.min.copy(t).sub(n), this.max.copy(t).add(n), this;
      }
      clone() {
        return new this.constructor().copy(this);
      }
      copy(t) {
        return this.min.copy(t.min), this.max.copy(t.max), this;
      }
      makeEmpty() {
        return (
          (this.min.x = this.min.y = 1 / 0),
          (this.max.x = this.max.y = -1 / 0),
          this
        );
      }
      isEmpty() {
        return this.max.x < this.min.x || this.max.y < this.min.y;
      }
      getCenter(t) {
        return this.isEmpty()
          ? t.set(0, 0)
          : t.addVectors(this.min, this.max).multiplyScalar(0.5);
      }
      getSize(t) {
        return this.isEmpty() ? t.set(0, 0) : t.subVectors(this.max, this.min);
      }
      expandByPoint(t) {
        return this.min.min(t), this.max.max(t), this;
      }
      expandByVector(t) {
        return this.min.sub(t), this.max.add(t), this;
      }
      expandByScalar(t) {
        return this.min.addScalar(-t), this.max.addScalar(t), this;
      }
      containsPoint(t) {
        return !(
          t.x < this.min.x ||
          t.x > this.max.x ||
          t.y < this.min.y ||
          t.y > this.max.y
        );
      }
      containsBox(t) {
        return (
          this.min.x <= t.min.x &&
          t.max.x <= this.max.x &&
          this.min.y <= t.min.y &&
          t.max.y <= this.max.y
        );
      }
      getParameter(t, e) {
        return e.set(
          (t.x - this.min.x) / (this.max.x - this.min.x),
          (t.y - this.min.y) / (this.max.y - this.min.y)
        );
      }
      intersectsBox(t) {
        return !(
          t.max.x < this.min.x ||
          t.min.x > this.max.x ||
          t.max.y < this.min.y ||
          t.min.y > this.max.y
        );
      }
      clampPoint(t, e) {
        return e.copy(t).clamp(this.min, this.max);
      }
      distanceToPoint(t) {
        return lh.copy(t).clamp(this.min, this.max).sub(t).length();
      }
      intersect(t) {
        return this.min.max(t.min), this.max.min(t.max), this;
      }
      union(t) {
        return this.min.min(t.min), this.max.max(t.max), this;
      }
      translate(t) {
        return this.min.add(t), this.max.add(t), this;
      }
      equals(t) {
        return t.min.equals(this.min) && t.max.equals(this.max);
      }
    }
    ch.prototype.isBox2 = !0;
    const uh = new Mn(),
      hh = new Mn();
    const dh = new Mn(),
      ph = new ei(),
      fh = new ei();
    const mh = new Float32Array(1);
    new Int32Array(mh.buffer);
    ($l.create = function (t, e) {
      return (
        console.log("THREE.Curve.create() has been deprecated"),
        (t.prototype = Object.create($l.prototype)),
        (t.prototype.constructor = t),
        (t.prototype.getPoint = e),
        t
      );
    }),
      (pc.prototype.fromPoints = function (t) {
        return (
          console.warn(
            "THREE.Path: .fromPoints() has been renamed to .setFromPoints()."
          ),
          this.setFromPoints(t)
        );
      }),
      (class extends zl {
        constructor(t = 10, e = 10, n = 4473924, i = 8947848) {
          (n = new qi(n)), (i = new qi(i));
          const r = e / 2,
            s = t / e,
            o = t / 2,
            a = [],
            l = [];
          for (let t = 0, c = 0, u = -o; t <= e; t++, u += s) {
            a.push(-o, 0, u, o, 0, u), a.push(u, 0, -o, u, 0, o);
            const e = t === r ? n : i;
            e.toArray(l, c),
              (c += 3),
              e.toArray(l, c),
              (c += 3),
              e.toArray(l, c),
              (c += 3),
              e.toArray(l, c),
              (c += 3);
          }
          const c = new ar();
          c.setAttribute("position", new Ki(a, 3)),
            c.setAttribute("color", new Ki(l, 3)),
            super(c, new Cl({ vertexColors: !0, toneMapped: !1 })),
            (this.type = "GridHelper");
        }
      }.prototype.setColors = function () {
        console.error(
          "THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead."
        );
      }),
      (class extends zl {
        constructor(t) {
          const e = (function t(e) {
              const n = [];
              e && e.isBone && n.push(e);
              for (let i = 0; i < e.children.length; i++)
                n.push.apply(n, t(e.children[i]));
              return n;
            })(t),
            n = new ar(),
            i = [],
            r = [],
            s = new qi(0, 0, 1),
            o = new qi(0, 1, 0);
          for (let t = 0; t < e.length; t++) {
            const n = e[t];
            n.parent &&
              n.parent.isBone &&
              (i.push(0, 0, 0),
              i.push(0, 0, 0),
              r.push(s.r, s.g, s.b),
              r.push(o.r, o.g, o.b));
          }
          n.setAttribute("position", new Ki(i, 3)),
            n.setAttribute("color", new Ki(r, 3)),
            super(
              n,
              new Cl({
                vertexColors: !0,
                depthTest: !1,
                depthWrite: !1,
                toneMapped: !1,
                transparent: !0,
              })
            ),
            (this.type = "SkeletonHelper"),
            (this.isSkeletonHelper = !0),
            (this.root = t),
            (this.bones = e),
            (this.matrix = t.matrixWorld),
            (this.matrixAutoUpdate = !1);
        }
        updateMatrixWorld(t) {
          const e = this.bones,
            n = this.geometry,
            i = n.getAttribute("position");
          fh.copy(this.root.matrixWorld).invert();
          for (let t = 0, n = 0; t < e.length; t++) {
            const r = e[t];
            r.parent &&
              r.parent.isBone &&
              (ph.multiplyMatrices(fh, r.matrixWorld),
              dh.setFromMatrixPosition(ph),
              i.setXYZ(n, dh.x, dh.y, dh.z),
              ph.multiplyMatrices(fh, r.parent.matrixWorld),
              dh.setFromMatrixPosition(ph),
              i.setXYZ(n + 1, dh.x, dh.y, dh.z),
              (n += 2));
          }
          (n.getAttribute("position").needsUpdate = !0),
            super.updateMatrixWorld(t);
        }
      }.prototype.update = function () {
        console.error(
          "THREE.SkeletonHelper: update() no longer needs to be called."
        );
      }),
      (xu.prototype.extractUrlBase = function (t) {
        return (
          console.warn(
            "THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."
          ),
          Gu.extractUrlBase(t)
        );
      }),
      (xu.Handlers = {
        add: function () {
          console.error(
            "THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead."
          );
        },
        get: function () {
          console.error(
            "THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead."
          );
        },
      }),
      (ch.prototype.center = function (t) {
        return (
          console.warn(
            "THREE.Box2: .center() has been renamed to .getCenter()."
          ),
          this.getCenter(t)
        );
      }),
      (ch.prototype.empty = function () {
        return (
          console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."),
          this.isEmpty()
        );
      }),
      (ch.prototype.isIntersectionBox = function (t) {
        return (
          console.warn(
            "THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."
          ),
          this.intersectsBox(t)
        );
      }),
      (ch.prototype.size = function (t) {
        return (
          console.warn("THREE.Box2: .size() has been renamed to .getSize()."),
          this.getSize(t)
        );
      }),
      (An.prototype.center = function (t) {
        return (
          console.warn(
            "THREE.Box3: .center() has been renamed to .getCenter()."
          ),
          this.getCenter(t)
        );
      }),
      (An.prototype.empty = function () {
        return (
          console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."),
          this.isEmpty()
        );
      }),
      (An.prototype.isIntersectionBox = function (t) {
        return (
          console.warn(
            "THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."
          ),
          this.intersectsBox(t)
        );
      }),
      (An.prototype.isIntersectionSphere = function (t) {
        return (
          console.warn(
            "THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."
          ),
          this.intersectsSphere(t)
        );
      }),
      (An.prototype.size = function (t) {
        return (
          console.warn("THREE.Box3: .size() has been renamed to .getSize()."),
          this.getSize(t)
        );
      }),
      (qn.prototype.empty = function () {
        return (
          console.warn(
            "THREE.Sphere: .empty() has been renamed to .isEmpty()."
          ),
          this.isEmpty()
        );
      }),
      ($r.prototype.setFromMatrix = function (t) {
        return (
          console.warn(
            "THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."
          ),
          this.setFromProjectionMatrix(t)
        );
      }),
      (class {
        constructor(t = new Mn(), e = new Mn()) {
          (this.start = t), (this.end = e);
        }
        set(t, e) {
          return this.start.copy(t), this.end.copy(e), this;
        }
        copy(t) {
          return this.start.copy(t.start), this.end.copy(t.end), this;
        }
        getCenter(t) {
          return t.addVectors(this.start, this.end).multiplyScalar(0.5);
        }
        delta(t) {
          return t.subVectors(this.end, this.start);
        }
        distanceSq() {
          return this.start.distanceToSquared(this.end);
        }
        distance() {
          return this.start.distanceTo(this.end);
        }
        at(t, e) {
          return this.delta(e).multiplyScalar(t).add(this.start);
        }
        closestPointToPointParameter(t, e) {
          uh.subVectors(t, this.start), hh.subVectors(this.end, this.start);
          const n = hh.dot(hh);
          let i = hh.dot(uh) / n;
          return e && (i = on(i, 0, 1)), i;
        }
        closestPointToPoint(t, e, n) {
          const i = this.closestPointToPointParameter(t, e);
          return this.delta(n).multiplyScalar(i).add(this.start);
        }
        applyMatrix4(t) {
          return this.start.applyMatrix4(t), this.end.applyMatrix4(t), this;
        }
        equals(t) {
          return t.start.equals(this.start) && t.end.equals(this.end);
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }.prototype.center = function (t) {
        return (
          console.warn(
            "THREE.Line3: .center() has been renamed to .getCenter()."
          ),
          this.getCenter(t)
        );
      }),
      (dn.prototype.flattenToArrayOffset = function (t, e) {
        return (
          console.warn(
            "THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."
          ),
          this.toArray(t, e)
        );
      }),
      (dn.prototype.multiplyVector3 = function (t) {
        return (
          console.warn(
            "THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."
          ),
          t.applyMatrix3(this)
        );
      }),
      (dn.prototype.multiplyVector3Array = function () {
        console.error(
          "THREE.Matrix3: .multiplyVector3Array() has been removed."
        );
      }),
      (dn.prototype.applyToBufferAttribute = function (t) {
        return (
          console.warn(
            "THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."
          ),
          t.applyMatrix3(this)
        );
      }),
      (dn.prototype.applyToVector3Array = function () {
        console.error(
          "THREE.Matrix3: .applyToVector3Array() has been removed."
        );
      }),
      (dn.prototype.getInverse = function (t) {
        return (
          console.warn(
            "THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."
          ),
          this.copy(t).invert()
        );
      }),
      (ei.prototype.extractPosition = function (t) {
        return (
          console.warn(
            "THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."
          ),
          this.copyPosition(t)
        );
      }),
      (ei.prototype.flattenToArrayOffset = function (t, e) {
        return (
          console.warn(
            "THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."
          ),
          this.toArray(t, e)
        );
      }),
      (ei.prototype.getPosition = function () {
        return (
          console.warn(
            "THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."
          ),
          new Mn().setFromMatrixColumn(this, 3)
        );
      }),
      (ei.prototype.setRotationFromQuaternion = function (t) {
        return (
          console.warn(
            "THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."
          ),
          this.makeRotationFromQuaternion(t)
        );
      }),
      (ei.prototype.multiplyToArray = function () {
        console.warn("THREE.Matrix4: .multiplyToArray() has been removed.");
      }),
      (ei.prototype.multiplyVector3 = function (t) {
        return (
          console.warn(
            "THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."
          ),
          t.applyMatrix4(this)
        );
      }),
      (ei.prototype.multiplyVector4 = function (t) {
        return (
          console.warn(
            "THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."
          ),
          t.applyMatrix4(this)
        );
      }),
      (ei.prototype.multiplyVector3Array = function () {
        console.error(
          "THREE.Matrix4: .multiplyVector3Array() has been removed."
        );
      }),
      (ei.prototype.rotateAxis = function (t) {
        console.warn(
          "THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."
        ),
          t.transformDirection(this);
      }),
      (ei.prototype.crossVector = function (t) {
        return (
          console.warn(
            "THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."
          ),
          t.applyMatrix4(this)
        );
      }),
      (ei.prototype.translate = function () {
        console.error("THREE.Matrix4: .translate() has been removed.");
      }),
      (ei.prototype.rotateX = function () {
        console.error("THREE.Matrix4: .rotateX() has been removed.");
      }),
      (ei.prototype.rotateY = function () {
        console.error("THREE.Matrix4: .rotateY() has been removed.");
      }),
      (ei.prototype.rotateZ = function () {
        console.error("THREE.Matrix4: .rotateZ() has been removed.");
      }),
      (ei.prototype.rotateByAxis = function () {
        console.error("THREE.Matrix4: .rotateByAxis() has been removed.");
      }),
      (ei.prototype.applyToBufferAttribute = function (t) {
        return (
          console.warn(
            "THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."
          ),
          t.applyMatrix4(this)
        );
      }),
      (ei.prototype.applyToVector3Array = function () {
        console.error(
          "THREE.Matrix4: .applyToVector3Array() has been removed."
        );
      }),
      (ei.prototype.makeFrustum = function (t, e, n, i, r, s) {
        return (
          console.warn(
            "THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."
          ),
          this.makePerspective(t, e, i, n, r, s)
        );
      }),
      (ei.prototype.getInverse = function (t) {
        return (
          console.warn(
            "THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."
          ),
          this.copy(t).invert()
        );
      }),
      (Gr.prototype.isIntersectionLine = function (t) {
        return (
          console.warn(
            "THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."
          ),
          this.intersectsLine(t)
        );
      }),
      (Sn.prototype.multiplyVector3 = function (t) {
        return (
          console.warn(
            "THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."
          ),
          t.applyQuaternion(this)
        );
      }),
      (Sn.prototype.inverse = function () {
        return (
          console.warn(
            "THREE.Quaternion: .inverse() has been renamed to invert()."
          ),
          this.invert()
        );
      }),
      (ti.prototype.isIntersectionBox = function (t) {
        return (
          console.warn(
            "THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."
          ),
          this.intersectsBox(t)
        );
      }),
      (ti.prototype.isIntersectionPlane = function (t) {
        return (
          console.warn(
            "THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."
          ),
          this.intersectsPlane(t)
        );
      }),
      (ti.prototype.isIntersectionSphere = function (t) {
        return (
          console.warn(
            "THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."
          ),
          this.intersectsSphere(t)
        );
      }),
      (zi.prototype.area = function () {
        return (
          console.warn(
            "THREE.Triangle: .area() has been renamed to .getArea()."
          ),
          this.getArea()
        );
      }),
      (zi.prototype.barycoordFromPoint = function (t, e) {
        return (
          console.warn(
            "THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."
          ),
          this.getBarycoord(t, e)
        );
      }),
      (zi.prototype.midpoint = function (t) {
        return (
          console.warn(
            "THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."
          ),
          this.getMidpoint(t)
        );
      }),
      (zi.prototypenormal = function (t) {
        return (
          console.warn(
            "THREE.Triangle: .normal() has been renamed to .getNormal()."
          ),
          this.getNormal(t)
        );
      }),
      (zi.prototype.plane = function (t) {
        return (
          console.warn(
            "THREE.Triangle: .plane() has been renamed to .getPlane()."
          ),
          this.getPlane(t)
        );
      }),
      (zi.barycoordFromPoint = function (t, e, n, i, r) {
        return (
          console.warn(
            "THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."
          ),
          zi.getBarycoord(t, e, n, i, r)
        );
      }),
      (zi.normal = function (t, e, n, i) {
        return (
          console.warn(
            "THREE.Triangle: .normal() has been renamed to .getNormal()."
          ),
          zi.getNormal(t, e, n, i)
        );
      }),
      (fc.prototype.extractAllPoints = function (t) {
        return (
          console.warn(
            "THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."
          ),
          this.extractPoints(t)
        );
      }),
      (fc.prototype.extrude = function (t) {
        return (
          console.warn(
            "THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."
          ),
          new Wc(this, t)
        );
      }),
      (fc.prototype.makeGeometry = function (t) {
        return (
          console.warn(
            "THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."
          ),
          new jc(this, t)
        );
      }),
      (hn.prototype.fromAttribute = function (t, e, n) {
        return (
          console.warn(
            "THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."
          ),
          this.fromBufferAttribute(t, e, n)
        );
      }),
      (hn.prototype.distanceToManhattan = function (t) {
        return (
          console.warn(
            "THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."
          ),
          this.manhattanDistanceTo(t)
        );
      }),
      (hn.prototype.lengthManhattan = function () {
        return (
          console.warn(
            "THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."
          ),
          this.manhattanLength()
        );
      }),
      (Mn.prototype.setEulerFromRotationMatrix = function () {
        console.error(
          "THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead."
        );
      }),
      (Mn.prototype.setEulerFromQuaternion = function () {
        console.error(
          "THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead."
        );
      }),
      (Mn.prototype.getPositionFromMatrix = function (t) {
        return (
          console.warn(
            "THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."
          ),
          this.setFromMatrixPosition(t)
        );
      }),
      (Mn.prototype.getScaleFromMatrix = function (t) {
        return (
          console.warn(
            "THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."
          ),
          this.setFromMatrixScale(t)
        );
      }),
      (Mn.prototype.getColumnFromMatrix = function (t, e) {
        return (
          console.warn(
            "THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."
          ),
          this.setFromMatrixColumn(e, t)
        );
      }),
      (Mn.prototype.applyProjection = function (t) {
        return (
          console.warn(
            "THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."
          ),
          this.applyMatrix4(t)
        );
      }),
      (Mn.prototype.fromAttribute = function (t, e, n) {
        return (
          console.warn(
            "THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."
          ),
          this.fromBufferAttribute(t, e, n)
        );
      }),
      (Mn.prototype.distanceToManhattan = function (t) {
        return (
          console.warn(
            "THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."
          ),
          this.manhattanDistanceTo(t)
        );
      }),
      (Mn.prototype.lengthManhattan = function () {
        return (
          console.warn(
            "THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."
          ),
          this.manhattanLength()
        );
      }),
      (bn.prototype.fromAttribute = function (t, e, n) {
        return (
          console.warn(
            "THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."
          ),
          this.fromBufferAttribute(t, e, n)
        );
      }),
      (bn.prototype.lengthManhattan = function () {
        return (
          console.warn(
            "THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."
          ),
          this.manhattanLength()
        );
      }),
      (Ei.prototype.getChildByName = function (t) {
        return (
          console.warn(
            "THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."
          ),
          this.getObjectByName(t)
        );
      }),
      (Ei.prototype.renderDepth = function () {
        console.warn(
          "THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead."
        );
      }),
      (Ei.prototype.translate = function (t, e) {
        return (
          console.warn(
            "THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."
          ),
          this.translateOnAxis(e, t)
        );
      }),
      (Ei.prototype.getWorldRotation = function () {
        console.error(
          "THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead."
        );
      }),
      (Ei.prototype.applyMatrix = function (t) {
        return (
          console.warn(
            "THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."
          ),
          this.applyMatrix4(t)
        );
      }),
      Object.defineProperties(Ei.prototype, {
        eulerOrder: {
          get: function () {
            return (
              console.warn(
                "THREE.Object3D: .eulerOrder is now .rotation.order."
              ),
              this.rotation.order
            );
          },
          set: function (t) {
            console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),
              (this.rotation.order = t);
          },
        },
        useQuaternion: {
          get: function () {
            console.warn(
              "THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default."
            );
          },
          set: function () {
            console.warn(
              "THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default."
            );
          },
        },
      }),
      (Tr.prototype.setDrawMode = function () {
        console.error(
          "THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary."
        );
      }),
      Object.defineProperties(Tr.prototype, {
        drawMode: {
          get: function () {
            return (
              console.error(
                "THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."
              ),
              0
            );
          },
          set: function () {
            console.error(
              "THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary."
            );
          },
        },
      }),
      (xl.prototype.initBones = function () {
        console.error("THREE.SkinnedMesh: initBones() has been removed.");
      }),
      (Nr.prototype.setLens = function (t, e) {
        console.warn(
          "THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."
        ),
          void 0 !== e && (this.filmGauge = e),
          this.setFocalLength(t);
      }),
      Object.defineProperties(Tu.prototype, {
        onlyShadow: {
          set: function () {
            console.warn("THREE.Light: .onlyShadow has been removed.");
          },
        },
        shadowCameraFov: {
          set: function (t) {
            console.warn(
              "THREE.Light: .shadowCameraFov is now .shadow.camera.fov."
            ),
              (this.shadow.camera.fov = t);
          },
        },
        shadowCameraLeft: {
          set: function (t) {
            console.warn(
              "THREE.Light: .shadowCameraLeft is now .shadow.camera.left."
            ),
              (this.shadow.camera.left = t);
          },
        },
        shadowCameraRight: {
          set: function (t) {
            console.warn(
              "THREE.Light: .shadowCameraRight is now .shadow.camera.right."
            ),
              (this.shadow.camera.right = t);
          },
        },
        shadowCameraTop: {
          set: function (t) {
            console.warn(
              "THREE.Light: .shadowCameraTop is now .shadow.camera.top."
            ),
              (this.shadow.camera.top = t);
          },
        },
        shadowCameraBottom: {
          set: function (t) {
            console.warn(
              "THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."
            ),
              (this.shadow.camera.bottom = t);
          },
        },
        shadowCameraNear: {
          set: function (t) {
            console.warn(
              "THREE.Light: .shadowCameraNear is now .shadow.camera.near."
            ),
              (this.shadow.camera.near = t);
          },
        },
        shadowCameraFar: {
          set: function (t) {
            console.warn(
              "THREE.Light: .shadowCameraFar is now .shadow.camera.far."
            ),
              (this.shadow.camera.far = t);
          },
        },
        shadowCameraVisible: {
          set: function () {
            console.warn(
              "THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead."
            );
          },
        },
        shadowBias: {
          set: function (t) {
            console.warn("THREE.Light: .shadowBias is now .shadow.bias."),
              (this.shadow.bias = t);
          },
        },
        shadowDarkness: {
          set: function () {
            console.warn("THREE.Light: .shadowDarkness has been removed.");
          },
        },
        shadowMapWidth: {
          set: function (t) {
            console.warn(
              "THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."
            ),
              (this.shadow.mapSize.width = t);
          },
        },
        shadowMapHeight: {
          set: function (t) {
            console.warn(
              "THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."
            ),
              (this.shadow.mapSize.height = t);
          },
        },
      }),
      Object.defineProperties(Yi.prototype, {
        length: {
          get: function () {
            return (
              console.warn(
                "THREE.BufferAttribute: .length has been deprecated. Use .count instead."
              ),
              this.array.length
            );
          },
        },
        dynamic: {
          get: function () {
            return (
              console.warn(
                "THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."
              ),
              this.usage === Qe
            );
          },
          set: function () {
            console.warn(
              "THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."
            ),
              this.setUsage(Qe);
          },
        },
      }),
      (Yi.prototype.setDynamic = function (t) {
        return (
          console.warn(
            "THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."
          ),
          this.setUsage(!0 === t ? Qe : Ze),
          this
        );
      }),
      (Yi.prototype.copyIndicesArray = function () {
        console.error(
          "THREE.BufferAttribute: .copyIndicesArray() has been removed."
        );
      }),
      (Yi.prototype.setArray = function () {
        console.error(
          "THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers"
        );
      }),
      (ar.prototype.addIndex = function (t) {
        console.warn(
          "THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."
        ),
          this.setIndex(t);
      }),
      (ar.prototype.addAttribute = function (t, e) {
        return (
          console.warn(
            "THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."
          ),
          (e && e.isBufferAttribute) || (e && e.isInterleavedBufferAttribute)
            ? "index" === t
              ? (console.warn(
                  "THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."
                ),
                this.setIndex(e),
                this)
              : this.setAttribute(t, e)
            : (console.warn(
                "THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."
              ),
              this.setAttribute(t, new Yi(arguments[1], arguments[2])))
        );
      }),
      (ar.prototype.addDrawCall = function (t, e, n) {
        void 0 !== n &&
          console.warn(
            "THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."
          ),
          console.warn(
            "THREE.BufferGeometry: .addDrawCall() is now .addGroup()."
          ),
          this.addGroup(t, e);
      }),
      (ar.prototype.clearDrawCalls = function () {
        console.warn(
          "THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."
        ),
          this.clearGroups();
      }),
      (ar.prototype.computeOffsets = function () {
        console.warn(
          "THREE.BufferGeometry: .computeOffsets() has been removed."
        );
      }),
      (ar.prototype.removeAttribute = function (t) {
        return (
          console.warn(
            "THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."
          ),
          this.deleteAttribute(t)
        );
      }),
      (ar.prototype.applyMatrix = function (t) {
        return (
          console.warn(
            "THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."
          ),
          this.applyMatrix4(t)
        );
      }),
      Object.defineProperties(ar.prototype, {
        drawcalls: {
          get: function () {
            return (
              console.error(
                "THREE.BufferGeometry: .drawcalls has been renamed to .groups."
              ),
              this.groups
            );
          },
        },
        offsets: {
          get: function () {
            return (
              console.warn(
                "THREE.BufferGeometry: .offsets has been renamed to .groups."
              ),
              this.groups
            );
          },
        },
      }),
      (Ja.prototype.setDynamic = function (t) {
        return (
          console.warn(
            "THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."
          ),
          this.setUsage(!0 === t ? Qe : Ze),
          this
        );
      }),
      (Ja.prototype.setArray = function () {
        console.error(
          "THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers"
        );
      }),
      (Wc.prototype.getArrays = function () {
        console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.");
      }),
      (Wc.prototype.addShapeList = function () {
        console.error(
          "THREE.ExtrudeGeometry: .addShapeList() has been removed."
        );
      }),
      (Wc.prototype.addShape = function () {
        console.error("THREE.ExtrudeGeometry: .addShape() has been removed.");
      }),
      (Xa.prototype.dispose = function () {
        console.error("THREE.Scene: .dispose() has been removed.");
      }),
      (ah.prototype.onUpdate = function () {
        return (
          console.warn(
            "THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."
          ),
          this
        );
      }),
      Object.defineProperties(Bi.prototype, {
        wrapAround: {
          get: function () {
            console.warn("THREE.Material: .wrapAround has been removed.");
          },
          set: function () {
            console.warn("THREE.Material: .wrapAround has been removed.");
          },
        },
        overdraw: {
          get: function () {
            console.warn("THREE.Material: .overdraw has been removed.");
          },
          set: function () {
            console.warn("THREE.Material: .overdraw has been removed.");
          },
        },
        wrapRGB: {
          get: function () {
            return (
              console.warn("THREE.Material: .wrapRGB has been removed."),
              new qi()
            );
          },
        },
        shading: {
          get: function () {
            console.error(
              "THREE." +
                this.type +
                ": .shading has been removed. Use the boolean .flatShading instead."
            );
          },
          set: function (t) {
            console.warn(
              "THREE." +
                this.type +
                ": .shading has been removed. Use the boolean .flatShading instead."
            ),
              (this.flatShading = t === y);
          },
        },
        stencilMask: {
          get: function () {
            return (
              console.warn(
                "THREE." +
                  this.type +
                  ": .stencilMask has been removed. Use .stencilFuncMask instead."
              ),
              this.stencilFuncMask
            );
          },
          set: function (t) {
            console.warn(
              "THREE." +
                this.type +
                ": .stencilMask has been removed. Use .stencilFuncMask instead."
            ),
              (this.stencilFuncMask = t);
          },
        },
        vertexTangents: {
          get: function () {
            console.warn(
              "THREE." + this.type + ": .vertexTangents has been removed."
            );
          },
          set: function () {
            console.warn(
              "THREE." + this.type + ": .vertexTangents has been removed."
            );
          },
        },
      }),
      Object.defineProperties(kr.prototype, {
        derivatives: {
          get: function () {
            return (
              console.warn(
                "THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."
              ),
              this.extensions.derivatives
            );
          },
          set: function (t) {
            console.warn(
              "THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."
            ),
              (this.extensions.derivatives = t);
          },
        },
      }),
      (ja.prototype.clearTarget = function (t, e, n, i) {
        console.warn(
          "THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."
        ),
          this.setRenderTarget(t),
          this.clear(e, n, i);
      }),
      (ja.prototype.animate = function (t) {
        console.warn(
          "THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."
        ),
          this.setAnimationLoop(t);
      }),
      (ja.prototype.getCurrentRenderTarget = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."
          ),
          this.getRenderTarget()
        );
      }),
      (ja.prototype.getMaxAnisotropy = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."
          ),
          this.capabilities.getMaxAnisotropy()
        );
      }),
      (ja.prototype.getPrecision = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."
          ),
          this.capabilities.precision
        );
      }),
      (ja.prototype.resetGLState = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .resetGLState() is now .state.reset()."
          ),
          this.state.reset()
        );
      }),
      (ja.prototype.supportsFloatTextures = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."
          ),
          this.extensions.get("OES_texture_float")
        );
      }),
      (ja.prototype.supportsHalfFloatTextures = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."
          ),
          this.extensions.get("OES_texture_half_float")
        );
      }),
      (ja.prototype.supportsStandardDerivatives = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."
          ),
          this.extensions.get("OES_standard_derivatives")
        );
      }),
      (ja.prototype.supportsCompressedTextureS3TC = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."
          ),
          this.extensions.get("WEBGL_compressed_texture_s3tc")
        );
      }),
      (ja.prototype.supportsCompressedTexturePVRTC = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."
          ),
          this.extensions.get("WEBGL_compressed_texture_pvrtc")
        );
      }),
      (ja.prototype.supportsBlendMinMax = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."
          ),
          this.extensions.get("EXT_blend_minmax")
        );
      }),
      (ja.prototype.supportsVertexTextures = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."
          ),
          this.capabilities.vertexTextures
        );
      }),
      (ja.prototype.supportsInstancedArrays = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."
          ),
          this.extensions.get("ANGLE_instanced_arrays")
        );
      }),
      (ja.prototype.enableScissorTest = function (t) {
        console.warn(
          "THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."
        ),
          this.setScissorTest(t);
      }),
      (ja.prototype.initMaterial = function () {
        console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.");
      }),
      (ja.prototype.addPrePlugin = function () {
        console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.");
      }),
      (ja.prototype.addPostPlugin = function () {
        console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.");
      }),
      (ja.prototype.updateShadowMap = function () {
        console.warn(
          "THREE.WebGLRenderer: .updateShadowMap() has been removed."
        );
      }),
      (ja.prototype.setFaceCulling = function () {
        console.warn(
          "THREE.WebGLRenderer: .setFaceCulling() has been removed."
        );
      }),
      (ja.prototype.allocTextureUnit = function () {
        console.warn(
          "THREE.WebGLRenderer: .allocTextureUnit() has been removed."
        );
      }),
      (ja.prototype.setTexture = function () {
        console.warn("THREE.WebGLRenderer: .setTexture() has been removed.");
      }),
      (ja.prototype.setTexture2D = function () {
        console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.");
      }),
      (ja.prototype.setTextureCube = function () {
        console.warn(
          "THREE.WebGLRenderer: .setTextureCube() has been removed."
        );
      }),
      (ja.prototype.getActiveMipMapLevel = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."
          ),
          this.getActiveMipmapLevel()
        );
      }),
      Object.defineProperties(ja.prototype, {
        shadowMapEnabled: {
          get: function () {
            return this.shadowMap.enabled;
          },
          set: function (t) {
            console.warn(
              "THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."
            ),
              (this.shadowMap.enabled = t);
          },
        },
        shadowMapType: {
          get: function () {
            return this.shadowMap.type;
          },
          set: function (t) {
            console.warn(
              "THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."
            ),
              (this.shadowMap.type = t);
          },
        },
        shadowMapCullFace: {
          get: function () {
            console.warn(
              "THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead."
            );
          },
          set: function () {
            console.warn(
              "THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead."
            );
          },
        },
        context: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."
              ),
              this.getContext()
            );
          },
        },
        vr: {
          get: function () {
            return (
              console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"),
              this.xr
            );
          },
        },
        gammaInput: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."
              ),
              !1
            );
          },
          set: function () {
            console.warn(
              "THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."
            );
          },
        },
        gammaOutput: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."
              ),
              !1
            );
          },
          set: function (t) {
            console.warn(
              "THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."
            ),
              (this.outputEncoding = !0 === t ? Ge : We);
          },
        },
        toneMappingWhitePoint: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."
              ),
              1
            );
          },
          set: function () {
            console.warn(
              "THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."
            );
          },
        },
        gammaFactor: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .gammaFactor has been removed."
              ),
              2
            );
          },
          set: function () {
            console.warn("THREE.WebGLRenderer: .gammaFactor has been removed.");
          },
        },
      }),
      Object.defineProperties(Ia.prototype, {
        cullFace: {
          get: function () {
            console.warn(
              "THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead."
            );
          },
          set: function () {
            console.warn(
              "THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead."
            );
          },
        },
        renderReverseSided: {
          get: function () {
            console.warn(
              "THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead."
            );
          },
          set: function () {
            console.warn(
              "THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead."
            );
          },
        },
        renderSingleSided: {
          get: function () {
            console.warn(
              "THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead."
            );
          },
          set: function () {
            console.warn(
              "THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead."
            );
          },
        },
      }),
      Object.defineProperties(_n.prototype, {
        wrapS: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."
              ),
              this.texture.wrapS
            );
          },
          set: function (t) {
            console.warn(
              "THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."
            ),
              (this.texture.wrapS = t);
          },
        },
        wrapT: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."
              ),
              this.texture.wrapT
            );
          },
          set: function (t) {
            console.warn(
              "THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."
            ),
              (this.texture.wrapT = t);
          },
        },
        magFilter: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."
              ),
              this.texture.magFilter
            );
          },
          set: function (t) {
            console.warn(
              "THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."
            ),
              (this.texture.magFilter = t);
          },
        },
        minFilter: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."
              ),
              this.texture.minFilter
            );
          },
          set: function (t) {
            console.warn(
              "THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."
            ),
              (this.texture.minFilter = t);
          },
        },
        anisotropy: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."
              ),
              this.texture.anisotropy
            );
          },
          set: function (t) {
            console.warn(
              "THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."
            ),
              (this.texture.anisotropy = t);
          },
        },
        offset: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .offset is now .texture.offset."
              ),
              this.texture.offset
            );
          },
          set: function (t) {
            console.warn(
              "THREE.WebGLRenderTarget: .offset is now .texture.offset."
            ),
              (this.texture.offset = t);
          },
        },
        repeat: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .repeat is now .texture.repeat."
              ),
              this.texture.repeat
            );
          },
          set: function (t) {
            console.warn(
              "THREE.WebGLRenderTarget: .repeat is now .texture.repeat."
            ),
              (this.texture.repeat = t);
          },
        },
        format: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .format is now .texture.format."
              ),
              this.texture.format
            );
          },
          set: function (t) {
            console.warn(
              "THREE.WebGLRenderTarget: .format is now .texture.format."
            ),
              (this.texture.format = t);
          },
        },
        type: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .type is now .texture.type."
              ),
              this.texture.type
            );
          },
          set: function (t) {
            console.warn(
              "THREE.WebGLRenderTarget: .type is now .texture.type."
            ),
              (this.texture.type = t);
          },
        },
        generateMipmaps: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."
              ),
              this.texture.generateMipmaps
            );
          },
          set: function (t) {
            console.warn(
              "THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."
            ),
              (this.texture.generateMipmaps = t);
          },
        },
      }),
      (Ju.prototype.load = function (t) {
        console.warn(
          "THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead."
        );
        const e = this;
        return (
          new Xu().load(t, function (t) {
            e.setBuffer(t);
          }),
          this
        );
      }),
      (class {
        constructor(t, e = 2048) {
          (this.analyser = t.context.createAnalyser()),
            (this.analyser.fftSize = e),
            (this.data = new Uint8Array(this.analyser.frequencyBinCount)),
            t.getOutput().connect(this.analyser);
        }
        getFrequencyData() {
          return this.analyser.getByteFrequencyData(this.data), this.data;
        }
        getAverageFrequency() {
          let t = 0;
          const e = this.getFrequencyData();
          for (let n = 0; n < e.length; n++) t += e[n];
          return t / e.length;
        }
      }.prototype.getData = function () {
        return (
          console.warn(
            "THREE.AudioAnalyser: .getData() is now .getFrequencyData()."
          ),
          this.getFrequencyData()
        );
      }),
      (Hr.prototype.updateCubeMap = function (t, e) {
        return (
          console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."),
          this.update(t, e)
        );
      }),
      (Hr.prototype.clear = function (t, e, n, i) {
        return (
          console.warn(
            "THREE.CubeCamera: .clear() is now .renderTarget.clear()."
          ),
          this.renderTarget.clear(t, e, n, i)
        );
      }),
      (gn.crossOrigin = void 0),
      (gn.loadTexture = function (t, e, n, i) {
        console.warn(
          "THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead."
        );
        const r = new Mu();
        r.setCrossOrigin(this.crossOrigin);
        const s = r.load(t, n, void 0, i);
        return e && (s.mapping = e), s;
      }),
      (gn.loadTextureCube = function (t, e, n, i) {
        console.warn(
          "THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead."
        );
        const r = new Su();
        r.setCrossOrigin(this.crossOrigin);
        const s = r.load(t, n, void 0, i);
        return e && (s.mapping = e), s;
      }),
      (gn.loadCompressedTexture = function () {
        console.error(
          "THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead."
        );
      }),
      (gn.loadCompressedTextureCube = function () {
        console.error(
          "THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead."
        );
      });
    function gh(t, e) {
      for (var n = 0; n < e.length; n++) {
        var i = e[n];
        (i.enumerable = i.enumerable || !1),
          (i.configurable = !0),
          "value" in i && (i.writable = !0),
          Object.defineProperty(t, i.key, i);
      }
    }
    "undefined" != typeof __THREE_DEVTOOLS__ &&
      __THREE_DEVTOOLS__.dispatchEvent(
        new CustomEvent("register", { detail: { revision: l } })
      ),
      "undefined" != typeof window &&
        (window.__THREE__
          ? console.warn(
              "WARNING: Multiple instances of Three.js being imported."
            )
          : (window.__THREE__ = l));
    var vh = (function () {
        function t() {
          !(function (t, e) {
            if (!(t instanceof e))
              throw new TypeError("Cannot call a class as a function");
          })(this, t),
            (this.body = document.body),
            (this.isVisible = !1),
            (this.distance = 100),
            (this.amount_x = 50),
            (this.amount_y = 50),
            (this.count = 0),
            (this.cameraX = 250),
            (this.cameraY = 300),
            (this.themes = {
              default: { color: new qi(16746217), alpha: 0.15 },
              light: { color: new qi(15001322), alpha: 0.5 },
            }),
            this.bindMethods(),
            this.initCanvas(),
            this.initWebGL(),
            this.initScene(),
            this.initEvents(),
            this.onResize();
        }
        var e, n, i;
        return (
          (e = t),
          (n = [
            {
              key: "init",
              value: function () {
                (this.numParticles = this.amount_x * this.amount_y),
                  (this.positions = new Float32Array(3 * this.numParticles)),
                  (this.scales = new Float32Array(this.numParticles));
                for (var t = 0, e = 0, n = 0; n < this.amount_x; n++)
                  for (var i = 0; i < this.amount_y; i++)
                    (this.positions[t] =
                      n * this.distance - (this.amount_x * this.distance) / 2),
                      (this.positions[t + 1] = 0),
                      (this.positions[t + 2] =
                        i * this.distance -
                        (this.amount_y * this.distance) / 2),
                      (this.scales[e] = 1),
                      (t += 3),
                      e++;
                var r = new ar();
                r.setAttribute("position", new Yi(this.positions, 3)),
                  r.setAttribute("scale", new Yi(this.scales, 1));
                var s = new kr({
                  transparent: !0,
                  uniforms: {
                    color: { value: this.themes[this.theme].color },
                    alpha: { value: this.themes[this.theme].alpha },
                  },
                  vertexShader:
                    "attribute float scale;\n                void main() {\n                vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n                gl_PointSize = scale * ( 300.0 / - mvPosition.z );\n                gl_Position = projectionMatrix * mvPosition;\n            }",
                  fragmentShader:
                    "uniform vec3 color; uniform float alpha;\n                void main() {\n                if ( length( gl_PointCoord - vec2( 0.5, 0.5 ) ) > 0.475 ) discard;\n                    gl_FragColor = vec4( color, alpha );\n                }",
                });
                (this.particles = new Gl(r, s)), this.scene.add(this.particles);
              },
            },
            {
              key: "initScene",
              value: function () {
                this.init(), this.render();
              },
            },
            {
              key: "initCanvas",
              value: function () {
                var t = this;
                (this.wrapper = {}),
                  (this.wrapper.el = document.getElementById(
                    "scene-wrapper--hero-wave"
                  )),
                  (this.wrapper.width = this.wrapper.el.offsetWidth),
                  (this.wrapper.height = this.wrapper.el.offsetHeight),
                  (this.canvas = {}),
                  (this.canvas.el = document.getElementById("scene-hero-wave")),
                  (this.canvas.width = this.canvas.el.offsetWidth),
                  (this.canvas.height = this.canvas.el.offsetHeight),
                  (this.theme = this.canvas.el.dataset.waveTheme || "default"),
                  (this.observer = new IntersectionObserver(function (e) {
                    e.forEach(function (e) {
                      return (t.isVisible = e.intersectionRatio > 0);
                    });
                  })),
                  this.observer.observe(this.wrapper.el);
              },
            },
            {
              key: "initWebGL",
              value: function () {
                (this.scene = new Xa()),
                  (this.camera = new Nr(
                    75,
                    this.canvas.width / this.canvas.height,
                    1,
                    1e4
                  )),
                  (this.camera.position.z = 1500),
                  (this.camera.position.x =
                    this.cameraX - this.camera.position.x),
                  (this.camera.position.y =
                    this.cameraY - this.camera.position.y),
                  this.camera.lookAt(this.scene.position),
                  (this.renderer = new ja({
                    alpha: !0,
                    antialias: !0,
                    canvas: this.canvas.el,
                  })),
                  this.renderer.setPixelRatio(1.5),
                  this.renderer.setSize(
                    this.wrapper.width,
                    this.wrapper.height
                  ),
                  this.renderer.setClearColor(0, 0);
              },
            },
            {
              key: "render",
              value: function () {
                if (this.isVisible) {
                  for (
                    var t = this.particles.geometry.attributes.position.array,
                      e = this.particles.geometry.attributes.scale.array,
                      n = 0,
                      i = 0,
                      r = 0;
                    r < this.amount_x;
                    r++
                  )
                    for (var s = 0; s < this.amount_y; s++)
                      (t[n + 1] =
                        50 * Math.sin(0.3 * (r + this.count)) +
                        50 * Math.sin(0.5 * (s + this.count))),
                        (e[i] =
                          20 * (Math.sin(0.3 * (r + this.count)) + 1) +
                          20 * (Math.sin(0.5 * (s + this.count)) + 1)),
                        (n += 3),
                        i++;
                  (this.particles.geometry.attributes.position.needsUpdate =
                    !0),
                    (this.particles.geometry.attributes.scale.needsUpdate = !0),
                    (this.count += 0.008),
                    (this.particles.rotation.y += 8e-5);
                }
                this.renderer.render(this.scene, this.camera),
                  window.requestAnimationFrame(this.render);
              },
            },
            {
              key: "onResize",
              value: function () {
                (this.wrapper.width = this.wrapper.el.offsetWidth),
                  (this.wrapper.height = this.wrapper.el.offsetHeight),
                  (this.wrapper.rect = this.wrapper.el.getBoundingClientRect()),
                  (this.canvas.rect = this.canvas.el.getBoundingClientRect()),
                  (this.camera.aspect =
                    this.wrapper.width / this.wrapper.height),
                  this.camera.updateProjectionMatrix(),
                  this.renderer.setSize(
                    this.wrapper.width,
                    this.wrapper.height
                  ),
                  this.renderer.render(this.scene, this.camera);
              },
            },
            {
              key: "initEvents",
              value: function () {
                window.addEventListener("resize", this.onResize, {
                  passive: !0,
                });
              },
            },
            {
              key: "bindMethods",
              value: function () {
                var t = this;
                ["onResize", "render"].forEach(function (e) {
                  return (t[e] = t[e].bind(t));
                });
              },
            },
          ]) && gh(e.prototype, n),
          i && gh(e, i),
          t
        );
      })(),
      yh = function () {
        var t = 500,
          e = 500;
        $("a.share-popup").on("click", function (n) {
          n.preventDefault();
          var i = Math.floor(((screen.availWidth || 1024) - t) / 2),
            r = Math.floor(((screen.availHeight || 700) - e) / 2),
            s = window.open(
              $(this).attr("href"),
              "social",
              "width=" +
                t +
                ",height=" +
                e +
                ",left=" +
                i +
                ",top=" +
                r +
                ",location=0,menubar=0,toolbar=0,status=0,scrollbars=1,resizable=1"
            );
          s &&
            (s.focus(),
            n.preventDefault && n.preventDefault(),
            (n.returnValue = !1));
        });
      },
      xh = function () {
        var t = jQuery("#header");
        jQuery(window).scroll(function () {
          $(this).scrollTop() > 0
            ? t.addClass("fixed-position")
            : t.removeClass("fixed-position");
        });
      },
      bh = function () {
        var t = $(".nav-opener"),
          e = $(".nav"),
          n = e.find("a");
        t.click(function () {
          $("body").toggleClass("nav-active");
        }),
          $(".nav li").each(function () {
            var t = $(this),
              e = t.find("ul"),
              n = t.find("a").eq(0);
            e.length &&
              (t.addClass("hasdrop"),
              n.length &&
                (n[0].href.includes("#")
                  ? n
                      .addClass("hasdrop-a")
                      .attr({ "data-more": "", "data-outside": "" })
                  : n.after(
                      '<span class="hasdrop-a" data-more data-outside></span>'
                    )));
          }),
          n.click(function () {
            !$(this).hasClass("hasdrop-a") &&
              $("body").removeClass("nav-active");
          }),
          $("html").on(
            "click touchstart pointerdown MSPointerDown",
            function (n) {
              var i = $(n.target);
              i.closest(t).length ||
                i.closest(e).length ||
                $("body").removeClass("nav-active");
            }
          );
      },
      _h = function () {
        $("[data-more]").next().hide(),
          $("[data-more].active").next().show(),
          $("[data-more]").click(function (t) {
            t.preventDefault(),
              $(this).hasClass("active")
                ? $(this).removeClass("active").next().slideUp(200)
                : $(this).addClass("active").next().slideToggle(200),
              $(this).closest("[data-accordion]").length &&
                ($(this)
                  .parent()
                  .siblings()
                  .find("[data-more]")
                  .removeClass("active"),
                $(this)
                  .parent()
                  .siblings()
                  .find("[data-more]")
                  .next()
                  .slideUp(200));
          }),
          $("[data-toggle-active]").click(function (t) {
            t.preventDefault(),
              $(this).hasClass("active")
                ? $(this).removeClass("active")
                : $(this).addClass("active");
          }),
          $("[data-outside]")
            .next()
            .find("a:not(.hasdrop-a):not([data-more])")
            .click(function () {
              $("[data-outside]").removeClass("active"),
                $("[data-outside]:not([data-toggle-active])")
                  .next()
                  .slideUp(200);
            }),
          $("[data-outside]").click(function (t) {
            $("[data-outside]").not(this).removeClass("active"),
              $("[data-outside]:not([data-toggle-active])")
                .not(this)
                .next()
                .slideUp(200);
          }),
          $("html").on(
            "click touchstart pointerdown MSPointerDown",
            function (t) {
              var e = $(t.target);
              e.closest("[data-outside]").length ||
                e.closest("[data-outside] + *").length ||
                setTimeout(function () {
                  $("[data-outside]").removeClass("active"),
                    $("[data-outside]:not([data-toggle-active])")
                      .next()
                      .slideUp(200);
                }, 200),
                e.closest("[data-outside-1]").length ||
                  e.closest("[data-outside-1] + *").length ||
                  setTimeout(function () {
                    $("[data-outside-1]")
                      .removeClass("active")
                      .next()
                      .slideUp(200);
                  }, 200);
            }
          );
      },
      wh = function () {
        $("[data-tab]").click(function (t) {
          t.preventDefault();
          var e = $(this).attr("data-tab");
          $(this).parent().siblings().find("[data-tab]").removeClass("active"),
            $("#" + e)
              .siblings()
              .removeClass("active"),
            $(this).addClass("active"),
            $("#" + e).addClass("active");
        }),
          $("#" + $("[data-tab].active").data("tab")).addClass("active");
      },
      Sh = function () {
        $(".inline-svg").each(function () {
          var t = $(this);
          t.length > 0 &&
            $.get(t[0].src, function (e) {
              var n = document.importNode(e.documentElement, !0);
              t.hasClass("no-fill")
                ? t.parent().html(n)
                : t.parent().html(n).find("svg").addClass("fill-current");
            });
        });
      },
      Mh = function () {
        $(".play-video").click(function (t) {
          t.preventDefault(), $("body").append('<div id="video-wrap"></div>');
          var e = (function (t) {
            if (void 0 !== (e = t.attr("data-video"))) {
              var e, n;
              if (-1 !== (e = e.toString()).indexOf("youtube"))
                -1 !== (i = e.lastIndexOf("&")) && (e = e.substring(0, i)),
                  -1 !== (r = e.indexOf("embed")) &&
                    (e =
                      "https://www.youtube.com/watch?v=" +
                      e.substring(r + 6, r + 17)),
                  (n =
                    "https://www.youtube.com/embed/" +
                    e.substring(e.length - 11, e.length) +
                    "?autoplay=1&mute=1&loop=1&playlist=" +
                    e.substring(e.length - 11, e.length));
              else if (-1 !== e.indexOf("youtu")) {
                var i, r;
                -1 !== (i = e.lastIndexOf("&")) && (e = e.substring(0, i)),
                  -1 !== (r = e.indexOf("embed")) &&
                    (e = "https://youtu.be/" + e.substring(r + 6, r + 17)),
                  (n =
                    "https://www.youtube.com/embed/" +
                    e.substring(e.length - 11, e.length) +
                    "?autoplay=1&mute=1&loop=1&playlist=" +
                    e.substring(e.length - 11, e.length));
              } else {
                if (-1 === e.indexOf("vimeo"))
                  return -1 !== e.indexOf("mp4")
                    ? '<video loop playsinline autoplay controls><source src="' +
                        e +
                        '" type="video/mp4"></video>'
                    : (alert(
                        "The video assigned is not from Youtube, Vimeo or MP4, remember to enter the correct complete video link .\n - Youtube: https://www.youtube.com/watch?v=43ngkc2Ejgw\n - Vimeo: https://vimeo.com/111939668\n - MP4 https://server.com/file.mp4"
                      ),
                      !1);
                n =
                  "https://player.vimeo.com/video/" +
                  e
                    .substring(e.indexOf(".com") + 5, e.length)
                    .replace("/", "") +
                  "?autoplay=1";
              }
              return (
                '<iframe src="' +
                n +
                '" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>'
              );
            }
            return alert("No video assigned."), !1;
          })($(this));
          e &&
            ($("#video-wrap")
              .html(
                '<span class="video-overlay"></span><div class="video-container"><div class="video-wrap"><div class="video-frame"><button class="close-video"></button>' +
                  e +
                  "</div></div></div>"
              )
              .addClass("active"),
            $("body").addClass("video-active"));
        }),
          $(document).on("click", ".close-video, .video-overlay", function () {
            $("#video-wrap").empty().removeClass("active"),
              $("body").removeClass("video-active"),
              $("#video-wrap").remove();
          });
      },
      Th = function () {
        $("a[href^='#modal-']").on("click", function () {
          var t = $($(this).attr("href"));
          return (
            $("body").addClass("modal-active"),
            $(".modal").removeClass("show"),
            t.addClass("show"),
            !1
          );
        }),
          $("[data-modal]").on("click", function () {
            return (
              $("body").addClass("modal-active"),
              $(".modal").removeClass("show"),
              $($(this).attr("href")).addClass("show"),
              !1
            );
          }),
          jQuery("[data-modal-close]").click(function (t) {
            t.preventDefault(),
              $("body").removeClass("modal-active"),
              $(".modal").removeClass("show");
          }),
          jQuery("html").on(
            "click touchstart pointerdown MSPointerDown",
            function (t) {
              var e = jQuery(t.target);
              e.closest("[data-modal-box]").length ||
                ($("[data-modal-box]").parents(".show").removeClass("show"),
                $("[data-modal-box].show").removeClass("show"),
                $(e).parents(".modal-active").removeClass("modal-active"));
            }
          );
      },
      Eh = function () {
        jQuery("a[href^='#anchor-'], .anchor").on("click", function () {
          if (
            location.pathname.replace(/^\//, "") ==
              this.pathname.replace(/^\//, "") &&
            location.hostname == this.hostname
          ) {
            var t = jQuery(this.hash.replace("#anchor-", "#"));
            if (
              (t = t.length ? t : jQuery("[name=" + this.hash.slice(1) + "]"))
                .length
            ) {
              var e = t.offset().top;
              return (
                jQuery("html, body").animate(
                  { scrollTop: e - $("header").outerHeight() },
                  800
                ),
                !1
              );
            }
          }
        });
      },
      Ah = function () {
        $(".match").matchHeight({});
      };
    $(document).ready(function (t) {
      var e;
      xh(),
        bh(),
        jQuery("[data-select]").each(function () {
          var t = jQuery(this),
            e = t.next(),
            n = e.find("a");
          t.attr({ "data-outside": "", "data-more": "" }),
            n.on("click", function (n) {
              n.preventDefault(),
                t.text(jQuery(this).text()),
                e.slideUp(200),
                t.removeClass("active").addClass("selected"),
                e.find("li").removeClass("active"),
                jQuery(this).parent().addClass("active");
            }),
            e.children().hasClass("active") &&
              t
                .text(jQuery(this).next().find(".active a").text())
                .addClass("selected");
        }),
        _h(),
        wh(),
        (function () {
          function t(t) {
            t.$slider
              .closest(
                ".slider-holder, .customer-slider-hold , .testimonials, .column-slider-wrap"
              )
              .find(".slideCount")
              .text("0" + (t.currentSlide + 1) + " / 0" + t.slideCount);
          }
          jQuery(".member-slider").slick({
            dots: !1,
            prevArrow: '<button class="icon-prev slick-prev"></button>',
            nextArrow: '<button class="icon-next slick-next"></button>',
            arrows: !0,
            slidesToShow: 3,
            slidesToScroll: 1,
            rows: 0,
            autoplay: !0,
            responsive: [
              {
                breakpoint: 1023,
                settings: { slidesToShow: 2, slidesToScroll: 1 },
              },
              {
                breakpoint: 640,
                settings: { slidesToShow: 1, slidesToScroll: 1 },
              },
            ],
          }),
            jQuery(
              ".slider , .customer-slider , .testimonials-slider , .testimonials-slider-01, .column-slider"
            ).on("init", function (e, n) {
              t(n);
            }),
            jQuery(
              ".slider , .customer-slider , .testimonials-slider , .testimonials-slider-01, .column-slider"
            ).on("afterChange", function (e, n) {
              t(n);
            }),
            jQuery(".slider").each(function () {
              var t = jQuery(this);
              t.hasClass("slick-initialized") ||
                t.slick({
                  slidesToShow: 1,
                  slidesToScroll: 1,
                  rows: 0,
                  autoplay: !0,
                  prevArrow: '<button class="icon-prev slick-prev"></button>',
                  nextArrow: '<button class="icon-next slick-next"></button>',
                });
            }),
            jQuery(".customer-slider").each(function () {
              var t = jQuery(this),
                e = t.closest(".customer-slider-hold").find(".slider-nav");
              t.hasClass("slick-initialized") ||
                t.slick({
                  slidesToShow: 1,
                  rows: 0,
                  variableWidth: !0,
                  infinite: !0,
                  appendArrows: e,
                  prevArrow: '<button class="icon-prev slick-prev"></button>',
                  nextArrow: '<button class="icon-next slick-next"></button>',
                });
            }),
            jQuery(".main-slider").slick({
              slidesToShow: 1,
              slidesToScroll: 1,
              arrows: !0,
              autoplay: !0,
              prevArrow: '<button class="icon-prev slick-prev"></button>',
              nextArrow: '<button class="icon-next slick-next"></button>',
            }),
            jQuery(".tab-content-slider").slick({
              slidesToShow: 1,
              slidesToScroll: 1,
              arrows: !1,
              asNavFor: ".navs-slider",
              rows: 0,
              fade: !0,
            }),
            jQuery(".news-slider-for").slick({
              slidesToShow: 1,
              slidesToScroll: 1,
              arrows: !1,
              asNavFor: ".small-slider",
              fade: !0,
              adaptiveHeight: !0,
            }),
            jQuery(".navs-slider").slick({
              slidesToShow: 3,
              slidesToScroll: 1,
              asNavFor: ".tab-content-slider",
              dots: !1,
              focusOnSelect: !0,
              arrows: !1,
              fade: !0,
              rows: 0,
              responsive: [
                {
                  breakpoint: 768,
                  settings: { slidesToShow: 1, slidesToScroll: 1, dots: !0 },
                },
              ],
            }),
            jQuery(".partners .partners-slider").slick({
              slidesToShow: 5,
              slidesToScroll: 1,
              rows: 0,
              autoplay: !0,
              arrows: !1,
              autoplaySpeed: 0,
              speed: 4e3,
              pauseOnHover: !1,
              cssEase: "linear",
              infinite: !0,
              responsive: [
                { breakpoint: 1024, settings: { slidesToShow: 4 } },
                { breakpoint: 768, settings: { slidesToShow: 3 } },
                { breakpoint: 480, settings: { slidesToShow: 2 } },
              ],
            }),
            jQuery(".testimonials-slider").each(function () {
              var t = jQuery(this),
                e = t.closest(".testimonials").find(".slider-nav");
              t.hasClass("slick-initialized") ||
                t.slick({
                  prevArrow: '<button class="icon-prev slick-prev"></button>',
                  nextArrow: '<button class="icon-next slick-next"></button>',
                  arrows: !0,
                  slidesToShow: 3,
                  slidesToScroll: 1,
                  rows: 0,
                  autoplay: !0,
                  appendArrows: e,
                  responsive: [
                    {
                      breakpoint: 1023,
                      settings: { slidesToShow: 2, slidesToScroll: 1 },
                    },
                    {
                      breakpoint: 768,
                      settings: { slidesToShow: 1, slidesToScroll: 1 },
                    },
                  ],
                });
            }),
            jQuery(".testimonials-slider-01").each(function () {
              var t = jQuery(this),
                e = t.closest(".testimonials").find(".slider-nav");
              t.hasClass("slick-initialized") ||
                t.slick({
                  prevArrow: '<button class="icon-prev slick-prev"></button>',
                  nextArrow: '<button class="icon-next slick-next"></button>',
                  arrows: !0,
                  slidesToShow: 2,
                  slidesToScroll: 1,
                  rows: 0,
                  autoplay: !0,
                  appendArrows: e,
                  adaptiveHeight: !0,
                  responsive: [
                    {
                      breakpoint: 1023,
                      settings: { slidesToShow: 2, slidesToScroll: 1 },
                    },
                    {
                      breakpoint: 768,
                      settings: { slidesToShow: 1, slidesToScroll: 1 },
                    },
                  ],
                });
            }),
            jQuery(".column-slider").each(function () {
              var t = jQuery(this),
                e = t.closest(".column-slider-wrap").find(".slider-nav");
              t.hasClass("slick-initialized") ||
                t.slick({
                  prevArrow: '<button class="icon-prev slick-prev"></button>',
                  nextArrow: '<button class="icon-next slick-next"></button>',
                  arrows: !0,
                  slidesToShow: 2,
                  slidesToScroll: 1,
                  rows: 0,
                  adaptiveHeight: !0,
                  autoplay: !0,
                  appendArrows: e,
                  responsive: [
                    {
                      breakpoint: 1023,
                      settings: { slidesToShow: 2, slidesToScroll: 1 },
                    },
                    {
                      breakpoint: 768,
                      settings: { slidesToShow: 1, slidesToScroll: 1 },
                    },
                  ],
                });
            }),
            jQuery(".features-slideshow").slick({
              mobileFirst: !0,
              slidesToShow: 1,
              slidesToScroll: 1,
              arrows: !1,
              dots: !0,
              rows: 0,
              adaptiveHeight: !0,
              responsive: [{ breakpoint: 767, settings: "unslick" }],
            }),
            jQuery(".our-team-slider").slick({
              slidesToShow: 3,
              slidesToScroll: 1,
              rows: 0,
              responsive: [
                {
                  breakpoint: 1024,
                  settings: { slidesToShow: 2, slidesToScroll: 1 },
                },
                {
                  breakpoint: 580,
                  settings: { slidesToShow: 1, slidesToScroll: 1 },
                },
              ],
            }),
            jQuery(".investors-slider").slick({
              mobileFirst: !0,
              slidesToShow: 1,
              slidesToScroll: 1,
              arrows: !1,
              rows: 0,
              dots: !0,
              adaptiveHeight: !0,
              responsive: [{ breakpoint: 767, settings: "unslick" }],
            }),
            jQuery(".toc-slider").slick({
              slidesToShow: 3,
              slidesToScroll: 1,
              dots: !1,
              arrows: !1,
              variableWidth: !0,
              infinite: !1,
              responsive: [
                {
                  breakpoint: 767,
                  settings: { slidesToShow: 1, slidesToScroll: 1 },
                },
              ],
            }),
            jQuery(".fabric-member-slider").slick({
              dots: !1,
              infinite: !0,
              speed: 500,
              autoplaySpeed: 3e3,
              rows: 0,
              slidesToShow: 3,
              slidesToScroll: 1,
              centerPadding: "0",
              centerMode: !0,
              arrows: !1,
              vertical: !0,
              verticalSwiping: !0,
              focusOnSelect: !0,
              autoplay: !0,
              responsive: [
                {
                  breakpoint: 767,
                  settings: {
                    slidesToShow: 4,
                    slidesToScroll: 1,
                    centerMode: !1,
                  },
                },
              ],
            });
        })(),
        (function () {
          var t = jQuery(window),
            e = jQuery("#wrapper"),
            n = jQuery(".media-06 .video"),
            i = jQuery(".desktop-content"),
            r = jQuery(".mobile-content");
          function s() {
            9 == e.css("z-index") ? r.append(n) : i.append(n);
          }
          s(),
            t.resize(function () {
              s();
            });
        })(),
        Mh(),
        Th(),
        (e = document.querySelectorAll(".fabric-slider")) &&
          Array.from(e).forEach(function (t) {
            new o(t);
          }),
        new a.a(),
        document.getElementById("scene-hero-wave") && new vh(),
        Eh(),
        Ah(),
        Sh(),
        yh();
    });
  },
  tQ2B: function (t, e, n) {
    "use strict";
    var i = n("xTJ+"),
      r = n("Rn+g"),
      s = n("eqyj"),
      o = n("MLWZ"),
      a = n("g7np"),
      l = n("w0Vi"),
      c = n("OTTw"),
      u = n("LYNF");
    t.exports = function (t) {
      return new Promise(function (e, n) {
        var h = t.data,
          d = t.headers,
          p = t.responseType;
        i.isFormData(h) && delete d["Content-Type"];
        var f = new XMLHttpRequest();
        if (t.auth) {
          var m = t.auth.username || "",
            g = t.auth.password
              ? unescape(encodeURIComponent(t.auth.password))
              : "";
          d.Authorization = "Basic " + btoa(m + ":" + g);
        }
        var v = a(t.baseURL, t.url);
        function y() {
          if (f) {
            var i =
                "getAllResponseHeaders" in f
                  ? l(f.getAllResponseHeaders())
                  : null,
              s = {
                data:
                  p && "text" !== p && "json" !== p
                    ? f.response
                    : f.responseText,
                status: f.status,
                statusText: f.statusText,
                headers: i,
                config: t,
                request: f,
              };
            r(e, n, s), (f = null);
          }
        }
        if (
          (f.open(
            t.method.toUpperCase(),
            o(v, t.params, t.paramsSerializer),
            !0
          ),
          (f.timeout = t.timeout),
          "onloadend" in f
            ? (f.onloadend = y)
            : (f.onreadystatechange = function () {
                f &&
                  4 === f.readyState &&
                  (0 !== f.status ||
                    (f.responseURL && 0 === f.responseURL.indexOf("file:"))) &&
                  setTimeout(y);
              }),
          (f.onabort = function () {
            f && (n(u("Request aborted", t, "ECONNABORTED", f)), (f = null));
          }),
          (f.onerror = function () {
            n(u("Network Error", t, null, f)), (f = null);
          }),
          (f.ontimeout = function () {
            var e = "timeout of " + t.timeout + "ms exceeded";
            t.timeoutErrorMessage && (e = t.timeoutErrorMessage),
              n(
                u(
                  e,
                  t,
                  t.transitional && t.transitional.clarifyTimeoutError
                    ? "ETIMEDOUT"
                    : "ECONNABORTED",
                  f
                )
              ),
              (f = null);
          }),
          i.isStandardBrowserEnv())
        ) {
          var x =
            (t.withCredentials || c(v)) && t.xsrfCookieName
              ? s.read(t.xsrfCookieName)
              : void 0;
          x && (d[t.xsrfHeaderName] = x);
        }
        "setRequestHeader" in f &&
          i.forEach(d, function (t, e) {
            void 0 === h && "content-type" === e.toLowerCase()
              ? delete d[e]
              : f.setRequestHeader(e, t);
          }),
          i.isUndefined(t.withCredentials) ||
            (f.withCredentials = !!t.withCredentials),
          p && "json" !== p && (f.responseType = t.responseType),
          "function" == typeof t.onDownloadProgress &&
            f.addEventListener("progress", t.onDownloadProgress),
          "function" == typeof t.onUploadProgress &&
            f.upload &&
            f.upload.addEventListener("progress", t.onUploadProgress),
          t.cancelToken &&
            t.cancelToken.promise.then(function (t) {
              f && (f.abort(), n(t), (f = null));
            }),
          h || (h = null),
          f.send(h);
      });
    };
  },
  tyWD: function (t, e, n) {
    var i = n("lFy7");
    "string" == typeof i && (i = [[t.i, i, ""]]);
    var r = { hmr: !0, transform: void 0, insertInto: void 0 };
    n("aET+")(i, r);
    i.locals && (t.exports = i.locals);
  },
  vDqi: function (t, e, n) {
    t.exports = n("zuR4");
  },
  w0Vi: function (t, e, n) {
    "use strict";
    var i = n("xTJ+"),
      r = [
        "age",
        "authorization",
        "content-length",
        "content-type",
        "etag",
        "expires",
        "from",
        "host",
        "if-modified-since",
        "if-unmodified-since",
        "last-modified",
        "location",
        "max-forwards",
        "proxy-authorization",
        "referer",
        "retry-after",
        "user-agent",
      ];
    t.exports = function (t) {
      var e,
        n,
        s,
        o = {};
      return t
        ? (i.forEach(t.split("\n"), function (t) {
            if (
              ((s = t.indexOf(":")),
              (e = i.trim(t.substr(0, s)).toLowerCase()),
              (n = i.trim(t.substr(s + 1))),
              e)
            ) {
              if (o[e] && r.indexOf(e) >= 0) return;
              o[e] =
                "set-cookie" === e
                  ? (o[e] ? o[e] : []).concat([n])
                  : o[e]
                  ? o[e] + ", " + n
                  : n;
            }
          }),
          o)
        : o;
    };
  },
  xAGQ: function (t, e, n) {
    "use strict";
    var i = n("xTJ+"),
      r = n("JEQr");
    t.exports = function (t, e, n) {
      var s = this || r;
      return (
        i.forEach(n, function (n) {
          t = n.call(s, t, e);
        }),
        t
      );
    };
  },
  "xTJ+": function (t, e, n) {
    "use strict";
    var i = n("HSsa"),
      r = Object.prototype.toString;
    function s(t) {
      return "[object Array]" === r.call(t);
    }
    function o(t) {
      return void 0 === t;
    }
    function a(t) {
      return null !== t && "object" == typeof t;
    }
    function l(t) {
      if ("[object Object]" !== r.call(t)) return !1;
      var e = Object.getPrototypeOf(t);
      return null === e || e === Object.prototype;
    }
    function c(t) {
      return "[object Function]" === r.call(t);
    }
    function u(t, e) {
      if (null != t)
        if (("object" != typeof t && (t = [t]), s(t)))
          for (var n = 0, i = t.length; n < i; n++) e.call(null, t[n], n, t);
        else
          for (var r in t)
            Object.prototype.hasOwnProperty.call(t, r) &&
              e.call(null, t[r], r, t);
    }
    t.exports = {
      isArray: s,
      isArrayBuffer: function (t) {
        return "[object ArrayBuffer]" === r.call(t);
      },
      isBuffer: function (t) {
        return (
          null !== t &&
          !o(t) &&
          null !== t.constructor &&
          !o(t.constructor) &&
          "function" == typeof t.constructor.isBuffer &&
          t.constructor.isBuffer(t)
        );
      },
      isFormData: function (t) {
        return "undefined" != typeof FormData && t instanceof FormData;
      },
      isArrayBufferView: function (t) {
        return "undefined" != typeof ArrayBuffer && ArrayBuffer.isView
          ? ArrayBuffer.isView(t)
          : t && t.buffer && t.buffer instanceof ArrayBuffer;
      },
      isString: function (t) {
        return "string" == typeof t;
      },
      isNumber: function (t) {
        return "number" == typeof t;
      },
      isObject: a,
      isPlainObject: l,
      isUndefined: o,
      isDate: function (t) {
        return "[object Date]" === r.call(t);
      },
      isFile: function (t) {
        return "[object File]" === r.call(t);
      },
      isBlob: function (t) {
        return "[object Blob]" === r.call(t);
      },
      isFunction: c,
      isStream: function (t) {
        return a(t) && c(t.pipe);
      },
      isURLSearchParams: function (t) {
        return (
          "undefined" != typeof URLSearchParams && t instanceof URLSearchParams
        );
      },
      isStandardBrowserEnv: function () {
        return (
          ("undefined" == typeof navigator ||
            ("ReactNative" !== navigator.product &&
              "NativeScript" !== navigator.product &&
              "NS" !== navigator.product)) &&
          "undefined" != typeof window &&
          "undefined" != typeof document
        );
      },
      forEach: u,
      merge: function t() {
        var e = {};
        function n(n, i) {
          l(e[i]) && l(n)
            ? (e[i] = t(e[i], n))
            : l(n)
            ? (e[i] = t({}, n))
            : s(n)
            ? (e[i] = n.slice())
            : (e[i] = n);
        }
        for (var i = 0, r = arguments.length; i < r; i++) u(arguments[i], n);
        return e;
      },
      extend: function (t, e, n) {
        return (
          u(e, function (e, r) {
            t[r] = n && "function" == typeof e ? i(e, n) : e;
          }),
          t
        );
      },
      trim: function (t) {
        return t.trim ? t.trim() : t.replace(/^\s+|\s+$/g, "");
      },
      stripBOM: function (t) {
        return 65279 === t.charCodeAt(0) && (t = t.slice(1)), t;
      },
    };
  },
  yK9s: function (t, e, n) {
    "use strict";
    var i = n("xTJ+");
    t.exports = function (t, e) {
      i.forEach(t, function (n, i) {
        i !== e &&
          i.toUpperCase() === e.toUpperCase() &&
          ((t[e] = n), delete t[i]);
      });
    };
  },
  yLpj: function (t, e) {
    var n;
    n = (function () {
      return this;
    })();
    try {
      n = n || new Function("return this")();
    } catch (t) {
      "object" == typeof window && (n = window);
    }
    t.exports = n;
  },
  zuR4: function (t, e, n) {
    "use strict";
    var i = n("xTJ+"),
      r = n("HSsa"),
      s = n("CgaS"),
      o = n("SntB");
    function a(t) {
      var e = new s(t),
        n = r(s.prototype.request, e);
      return i.extend(n, s.prototype, e), i.extend(n, e), n;
    }
    var l = a(n("JEQr"));
    (l.Axios = s),
      (l.create = function (t) {
        return a(o(l.defaults, t));
      }),
      (l.Cancel = n("endd")),
      (l.CancelToken = n("jfS+")),
      (l.isCancel = n("Lmem")),
      (l.all = function (t) {
        return Promise.all(t);
      }),
      (l.spread = n("DfZB")),
      (l.isAxiosError = n("XwJu")),
      (t.exports = l),
      (t.exports.default = l);
  },
});
